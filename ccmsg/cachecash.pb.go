// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cachecash.proto

package ccmsg

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Error struct {
	Code                 uint64   `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{0}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(dst, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetCode() uint64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type PublicKey struct {
	// TODO: Add an enum for key type.
	PublicKey            []byte   `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PublicKey) Reset()         { *m = PublicKey{} }
func (m *PublicKey) String() string { return proto.CompactTextString(m) }
func (*PublicKey) ProtoMessage()    {}
func (*PublicKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{1}
}
func (m *PublicKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublicKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublicKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PublicKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublicKey.Merge(dst, src)
}
func (m *PublicKey) XXX_Size() int {
	return m.Size()
}
func (m *PublicKey) XXX_DiscardUnknown() {
	xxx_messageInfo_PublicKey.DiscardUnknown(m)
}

var xxx_messageInfo_PublicKey proto.InternalMessageInfo

func (m *PublicKey) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

type Envelope struct {
	Version uint32 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	// Types that are valid to be assigned to Msg:
	//	*Envelope_ContentRequest
	Msg                  isEnvelope_Msg `protobuf_oneof:"msg"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Envelope) Reset()         { *m = Envelope{} }
func (m *Envelope) String() string { return proto.CompactTextString(m) }
func (*Envelope) ProtoMessage()    {}
func (*Envelope) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{2}
}
func (m *Envelope) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Envelope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Envelope.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Envelope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Envelope.Merge(dst, src)
}
func (m *Envelope) XXX_Size() int {
	return m.Size()
}
func (m *Envelope) XXX_DiscardUnknown() {
	xxx_messageInfo_Envelope.DiscardUnknown(m)
}

var xxx_messageInfo_Envelope proto.InternalMessageInfo

type isEnvelope_Msg interface {
	isEnvelope_Msg()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Envelope_ContentRequest struct {
	ContentRequest *ContentRequest `protobuf:"bytes,2,opt,name=content_request,json=contentRequest,oneof"`
}

func (*Envelope_ContentRequest) isEnvelope_Msg() {}

func (m *Envelope) GetMsg() isEnvelope_Msg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *Envelope) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Envelope) GetContentRequest() *ContentRequest {
	if x, ok := m.GetMsg().(*Envelope_ContentRequest); ok {
		return x.ContentRequest
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Envelope) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Envelope_OneofMarshaler, _Envelope_OneofUnmarshaler, _Envelope_OneofSizer, []interface{}{
		(*Envelope_ContentRequest)(nil),
	}
}

func _Envelope_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Envelope)
	// msg
	switch x := m.Msg.(type) {
	case *Envelope_ContentRequest:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ContentRequest); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Envelope.Msg has unexpected type %T", x)
	}
	return nil
}

func _Envelope_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Envelope)
	switch tag {
	case 2: // msg.content_request
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ContentRequest)
		err := b.DecodeMessage(msg)
		m.Msg = &Envelope_ContentRequest{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Envelope_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Envelope)
	// msg
	switch x := m.Msg.(type) {
	case *Envelope_ContentRequest:
		s := proto.Size(x.ContentRequest)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type EscrowInfo struct {
	PublicKey         *PublicKey `protobuf:"bytes,1,opt,name=public_key,json=publicKey" json:"public_key,omitempty"`
	ProviderPublicKey *PublicKey `protobuf:"bytes,2,opt,name=provider_public_key,json=providerPublicKey" json:"provider_public_key,omitempty"`
	DrawDelay         uint64     `protobuf:"varint,3,opt,name=draw_delay,json=drawDelay,proto3" json:"draw_delay,omitempty"`
	ExpirationDelay   uint64     `protobuf:"varint,4,opt,name=expiration_delay,json=expirationDelay,proto3" json:"expiration_delay,omitempty"`
	StartBlock        uint64     `protobuf:"varint,5,opt,name=start_block,json=startBlock,proto3" json:"start_block,omitempty"`
	TicketsPerBlock   []*Segment `protobuf:"bytes,6,rep,name=tickets_per_block,json=ticketsPerBlock" json:"tickets_per_block,omitempty"`
	// If we are using block/transaction-index based IDs, then this field must not be part of what is actually committed
	// to the blockchain.
	Id                   *EscrowID `protobuf:"bytes,7,opt,name=id" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *EscrowInfo) Reset()         { *m = EscrowInfo{} }
func (m *EscrowInfo) String() string { return proto.CompactTextString(m) }
func (*EscrowInfo) ProtoMessage()    {}
func (*EscrowInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{3}
}
func (m *EscrowInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EscrowInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EscrowInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EscrowInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EscrowInfo.Merge(dst, src)
}
func (m *EscrowInfo) XXX_Size() int {
	return m.Size()
}
func (m *EscrowInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_EscrowInfo.DiscardUnknown(m)
}

var xxx_messageInfo_EscrowInfo proto.InternalMessageInfo

func (m *EscrowInfo) GetPublicKey() *PublicKey {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *EscrowInfo) GetProviderPublicKey() *PublicKey {
	if m != nil {
		return m.ProviderPublicKey
	}
	return nil
}

func (m *EscrowInfo) GetDrawDelay() uint64 {
	if m != nil {
		return m.DrawDelay
	}
	return 0
}

func (m *EscrowInfo) GetExpirationDelay() uint64 {
	if m != nil {
		return m.ExpirationDelay
	}
	return 0
}

func (m *EscrowInfo) GetStartBlock() uint64 {
	if m != nil {
		return m.StartBlock
	}
	return 0
}

func (m *EscrowInfo) GetTicketsPerBlock() []*Segment {
	if m != nil {
		return m.TicketsPerBlock
	}
	return nil
}

func (m *EscrowInfo) GetId() *EscrowID {
	if m != nil {
		return m.Id
	}
	return nil
}

type Segment struct {
	Length               uint64   `protobuf:"varint,1,opt,name=length,proto3" json:"length,omitempty"`
	Value                uint64   `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Segment) Reset()         { *m = Segment{} }
func (m *Segment) String() string { return proto.CompactTextString(m) }
func (*Segment) ProtoMessage()    {}
func (*Segment) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{4}
}
func (m *Segment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Segment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Segment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Segment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Segment.Merge(dst, src)
}
func (m *Segment) XXX_Size() int {
	return m.Size()
}
func (m *Segment) XXX_DiscardUnknown() {
	xxx_messageInfo_Segment.DiscardUnknown(m)
}

var xxx_messageInfo_Segment proto.InternalMessageInfo

func (m *Segment) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *Segment) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type TicketBundle struct {
	Remainder         *TicketBundleRemainder `protobuf:"bytes,1,opt,name=remainder" json:"remainder,omitempty"`
	TicketRequest     []*TicketRequest       `protobuf:"bytes,5,rep,name=ticket_request,json=ticketRequest" json:"ticket_request,omitempty"`
	TicketL1          []*TicketL1            `protobuf:"bytes,6,rep,name=ticket_l1,json=ticketL1" json:"ticket_l1,omitempty"`
	EncryptedTicketL2 []byte                 `protobuf:"bytes,10,opt,name=encrypted_ticket_l2,json=encryptedTicketL2,proto3" json:"encrypted_ticket_l2,omitempty"`
	BatchSig          *BatchSignature        `protobuf:"bytes,8,opt,name=batch_sig,json=batchSig" json:"batch_sig,omitempty"`
	BundleSignerCert  *Certificate           `protobuf:"bytes,11,opt,name=bundle_signer_cert,json=bundleSignerCert" json:"bundle_signer_cert,omitempty"`
	// This field contains connection information for the caches mentioned in the ticket requests.
	// (XXX: There's not any particularly great/specific reason why this couldn't be covered by the hash.)
	CacheInfo            []*CacheInfo `protobuf:"bytes,9,rep,name=cache_info,json=cacheInfo" json:"cache_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *TicketBundle) Reset()         { *m = TicketBundle{} }
func (m *TicketBundle) String() string { return proto.CompactTextString(m) }
func (*TicketBundle) ProtoMessage()    {}
func (*TicketBundle) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{5}
}
func (m *TicketBundle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TicketBundle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TicketBundle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TicketBundle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TicketBundle.Merge(dst, src)
}
func (m *TicketBundle) XXX_Size() int {
	return m.Size()
}
func (m *TicketBundle) XXX_DiscardUnknown() {
	xxx_messageInfo_TicketBundle.DiscardUnknown(m)
}

var xxx_messageInfo_TicketBundle proto.InternalMessageInfo

func (m *TicketBundle) GetRemainder() *TicketBundleRemainder {
	if m != nil {
		return m.Remainder
	}
	return nil
}

func (m *TicketBundle) GetTicketRequest() []*TicketRequest {
	if m != nil {
		return m.TicketRequest
	}
	return nil
}

func (m *TicketBundle) GetTicketL1() []*TicketL1 {
	if m != nil {
		return m.TicketL1
	}
	return nil
}

func (m *TicketBundle) GetEncryptedTicketL2() []byte {
	if m != nil {
		return m.EncryptedTicketL2
	}
	return nil
}

func (m *TicketBundle) GetBatchSig() *BatchSignature {
	if m != nil {
		return m.BatchSig
	}
	return nil
}

func (m *TicketBundle) GetBundleSignerCert() *Certificate {
	if m != nil {
		return m.BundleSignerCert
	}
	return nil
}

func (m *TicketBundle) GetCacheInfo() []*CacheInfo {
	if m != nil {
		return m.CacheInfo
	}
	return nil
}

// XXX: This needs a better name.
type TicketBundleRemainder struct {
	// XXX: Is having the request-sequence number as part of the input to the keyed PRF important?
	// TODO: Remove this in favor of the field in the ContentResponse envelope.
	RequestSequenceNo    uint64                `protobuf:"varint,2,opt,name=request_sequence_no,json=requestSequenceNo,proto3" json:"request_sequence_no,omitempty"`
	EscrowId             *EscrowID             `protobuf:"bytes,1,opt,name=escrow_id,json=escrowId" json:"escrow_id,omitempty"`
	ObjectId             uint64                `protobuf:"varint,3,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
	PuzzleInfo           *ColocationPuzzleInfo `protobuf:"bytes,7,opt,name=puzzle_info,json=puzzleInfo" json:"puzzle_info,omitempty"`
	ClientPublicKey      *PublicKey            `protobuf:"bytes,8,opt,name=client_public_key,json=clientPublicKey" json:"client_public_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *TicketBundleRemainder) Reset()         { *m = TicketBundleRemainder{} }
func (m *TicketBundleRemainder) String() string { return proto.CompactTextString(m) }
func (*TicketBundleRemainder) ProtoMessage()    {}
func (*TicketBundleRemainder) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{6}
}
func (m *TicketBundleRemainder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TicketBundleRemainder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TicketBundleRemainder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TicketBundleRemainder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TicketBundleRemainder.Merge(dst, src)
}
func (m *TicketBundleRemainder) XXX_Size() int {
	return m.Size()
}
func (m *TicketBundleRemainder) XXX_DiscardUnknown() {
	xxx_messageInfo_TicketBundleRemainder.DiscardUnknown(m)
}

var xxx_messageInfo_TicketBundleRemainder proto.InternalMessageInfo

func (m *TicketBundleRemainder) GetRequestSequenceNo() uint64 {
	if m != nil {
		return m.RequestSequenceNo
	}
	return 0
}

func (m *TicketBundleRemainder) GetEscrowId() *EscrowID {
	if m != nil {
		return m.EscrowId
	}
	return nil
}

func (m *TicketBundleRemainder) GetObjectId() uint64 {
	if m != nil {
		return m.ObjectId
	}
	return 0
}

func (m *TicketBundleRemainder) GetPuzzleInfo() *ColocationPuzzleInfo {
	if m != nil {
		return m.PuzzleInfo
	}
	return nil
}

func (m *TicketBundleRemainder) GetClientPublicKey() *PublicKey {
	if m != nil {
		return m.ClientPublicKey
	}
	return nil
}

type CacheInfo struct {
	Addr                 *NetworkAddress `protobuf:"bytes,1,opt,name=addr" json:"addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CacheInfo) Reset()         { *m = CacheInfo{} }
func (m *CacheInfo) String() string { return proto.CompactTextString(m) }
func (*CacheInfo) ProtoMessage()    {}
func (*CacheInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{7}
}
func (m *CacheInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CacheInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CacheInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheInfo.Merge(dst, src)
}
func (m *CacheInfo) XXX_Size() int {
	return m.Size()
}
func (m *CacheInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CacheInfo proto.InternalMessageInfo

func (m *CacheInfo) GetAddr() *NetworkAddress {
	if m != nil {
		return m.Addr
	}
	return nil
}

// XXX: Is this a good name if this message includes a port number?
type NetworkAddress struct {
	// XXX: Or, we could represent this as an AF_* constant and a []byte addr.
	Inetaddr             []byte   `protobuf:"bytes,1,opt,name=inetaddr,proto3" json:"inetaddr,omitempty"`
	Inet6Addr            []byte   `protobuf:"bytes,2,opt,name=inet6addr,proto3" json:"inet6addr,omitempty"`
	Port                 uint32   `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkAddress) Reset()         { *m = NetworkAddress{} }
func (m *NetworkAddress) String() string { return proto.CompactTextString(m) }
func (*NetworkAddress) ProtoMessage()    {}
func (*NetworkAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{8}
}
func (m *NetworkAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NetworkAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkAddress.Merge(dst, src)
}
func (m *NetworkAddress) XXX_Size() int {
	return m.Size()
}
func (m *NetworkAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkAddress.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkAddress proto.InternalMessageInfo

func (m *NetworkAddress) GetInetaddr() []byte {
	if m != nil {
		return m.Inetaddr
	}
	return nil
}

func (m *NetworkAddress) GetInet6Addr() []byte {
	if m != nil {
		return m.Inet6Addr
	}
	return nil
}

func (m *NetworkAddress) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type ColocationPuzzleInfo struct {
	Goal []byte `protobuf:"bytes,2,opt,name=goal,proto3" json:"goal,omitempty"`
	// THese fields come from the `colocationpuzzle.Parameters` struct.
	Rounds               uint32   `protobuf:"varint,1,opt,name=rounds,proto3" json:"rounds,omitempty"`
	StartOffset          uint64   `protobuf:"varint,3,opt,name=start_offset,json=startOffset,proto3" json:"start_offset,omitempty"`
	StartRange           uint64   `protobuf:"varint,4,opt,name=start_range,json=startRange,proto3" json:"start_range,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ColocationPuzzleInfo) Reset()         { *m = ColocationPuzzleInfo{} }
func (m *ColocationPuzzleInfo) String() string { return proto.CompactTextString(m) }
func (*ColocationPuzzleInfo) ProtoMessage()    {}
func (*ColocationPuzzleInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{9}
}
func (m *ColocationPuzzleInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColocationPuzzleInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColocationPuzzleInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ColocationPuzzleInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColocationPuzzleInfo.Merge(dst, src)
}
func (m *ColocationPuzzleInfo) XXX_Size() int {
	return m.Size()
}
func (m *ColocationPuzzleInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ColocationPuzzleInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ColocationPuzzleInfo proto.InternalMessageInfo

func (m *ColocationPuzzleInfo) GetGoal() []byte {
	if m != nil {
		return m.Goal
	}
	return nil
}

func (m *ColocationPuzzleInfo) GetRounds() uint32 {
	if m != nil {
		return m.Rounds
	}
	return 0
}

func (m *ColocationPuzzleInfo) GetStartOffset() uint64 {
	if m != nil {
		return m.StartOffset
	}
	return 0
}

func (m *ColocationPuzzleInfo) GetStartRange() uint64 {
	if m != nil {
		return m.StartRange
	}
	return 0
}

type BatchSignature struct {
	PathDirection        []bool     `protobuf:"varint,2,rep,packed,name=path_direction,json=pathDirection" json:"path_direction,omitempty"`
	PathDigest           [][]byte   `protobuf:"bytes,3,rep,name=path_digest,json=pathDigest" json:"path_digest,omitempty"`
	RootSignature        []byte     `protobuf:"bytes,4,opt,name=root_signature,json=rootSignature,proto3" json:"root_signature,omitempty"`
	SigningKey           *PublicKey `protobuf:"bytes,5,opt,name=signing_key,json=signingKey" json:"signing_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *BatchSignature) Reset()         { *m = BatchSignature{} }
func (m *BatchSignature) String() string { return proto.CompactTextString(m) }
func (*BatchSignature) ProtoMessage()    {}
func (*BatchSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{10}
}
func (m *BatchSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BatchSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSignature.Merge(dst, src)
}
func (m *BatchSignature) XXX_Size() int {
	return m.Size()
}
func (m *BatchSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSignature.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSignature proto.InternalMessageInfo

func (m *BatchSignature) GetPathDirection() []bool {
	if m != nil {
		return m.PathDirection
	}
	return nil
}

func (m *BatchSignature) GetPathDigest() [][]byte {
	if m != nil {
		return m.PathDigest
	}
	return nil
}

func (m *BatchSignature) GetRootSignature() []byte {
	if m != nil {
		return m.RootSignature
	}
	return nil
}

func (m *BatchSignature) GetSigningKey() *PublicKey {
	if m != nil {
		return m.SigningKey
	}
	return nil
}

type BlockKey struct {
	// TODO: Add an enum for key type.
	Key                  []byte   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockKey) Reset()         { *m = BlockKey{} }
func (m *BlockKey) String() string { return proto.CompactTextString(m) }
func (*BlockKey) ProtoMessage()    {}
func (*BlockKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{11}
}
func (m *BlockKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlockKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockKey.Merge(dst, src)
}
func (m *BlockKey) XXX_Size() int {
	return m.Size()
}
func (m *BlockKey) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockKey.DiscardUnknown(m)
}

var xxx_messageInfo_BlockKey proto.InternalMessageInfo

func (m *BlockKey) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

// This is what the client will present to the cache.  It's not individually signed, but it's covered by the batch
// signature.
type TicketRequest struct {
	BlockIdx             uint64     `protobuf:"varint,2,opt,name=block_idx,json=blockIdx,proto3" json:"block_idx,omitempty"`
	InnerKey             *BlockKey  `protobuf:"bytes,3,opt,name=inner_key,json=innerKey" json:"inner_key,omitempty"`
	BlockId              uint64     `protobuf:"varint,5,opt,name=block_id,json=blockId,proto3" json:"block_id,omitempty"`
	CachePublicKey       *PublicKey `protobuf:"bytes,4,opt,name=cache_public_key,json=cachePublicKey" json:"cache_public_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *TicketRequest) Reset()         { *m = TicketRequest{} }
func (m *TicketRequest) String() string { return proto.CompactTextString(m) }
func (*TicketRequest) ProtoMessage()    {}
func (*TicketRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{12}
}
func (m *TicketRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TicketRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TicketRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TicketRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TicketRequest.Merge(dst, src)
}
func (m *TicketRequest) XXX_Size() int {
	return m.Size()
}
func (m *TicketRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TicketRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TicketRequest proto.InternalMessageInfo

func (m *TicketRequest) GetBlockIdx() uint64 {
	if m != nil {
		return m.BlockIdx
	}
	return 0
}

func (m *TicketRequest) GetInnerKey() *BlockKey {
	if m != nil {
		return m.InnerKey
	}
	return nil
}

func (m *TicketRequest) GetBlockId() uint64 {
	if m != nil {
		return m.BlockId
	}
	return 0
}

func (m *TicketRequest) GetCachePublicKey() *PublicKey {
	if m != nil {
		return m.CachePublicKey
	}
	return nil
}

// XXX: I suspect that the ticket number may be the only thing here's that's actually important, since it could be used
// in proofs of double-spending (on the CP's behalf).
type TicketL1 struct {
	// PublicKey escrow_public_key = 1;
	TicketNo uint64 `protobuf:"varint,2,opt,name=ticket_no,json=ticketNo,proto3" json:"ticket_no,omitempty"`
	// XXX: This is *also* duplicated between TicketL1 and TicketRequest.
	CachePublicKey *PublicKey `protobuf:"bytes,3,opt,name=cache_public_key,json=cachePublicKey" json:"cache_public_key,omitempty"`
	// XXX: This is duplicated between this message and the TicketRequest, which could probably be avoided.  However,
	// the cache does need to be able to work out which block-index the L1 ticket corresponds to so that it can derive
	// the right outer key to give to the client.
	BlockIdx             uint64   `protobuf:"varint,4,opt,name=block_idx,json=blockIdx,proto3" json:"block_idx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TicketL1) Reset()         { *m = TicketL1{} }
func (m *TicketL1) String() string { return proto.CompactTextString(m) }
func (*TicketL1) ProtoMessage()    {}
func (*TicketL1) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{13}
}
func (m *TicketL1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TicketL1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TicketL1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TicketL1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TicketL1.Merge(dst, src)
}
func (m *TicketL1) XXX_Size() int {
	return m.Size()
}
func (m *TicketL1) XXX_DiscardUnknown() {
	xxx_messageInfo_TicketL1.DiscardUnknown(m)
}

var xxx_messageInfo_TicketL1 proto.InternalMessageInfo

func (m *TicketL1) GetTicketNo() uint64 {
	if m != nil {
		return m.TicketNo
	}
	return 0
}

func (m *TicketL1) GetCachePublicKey() *PublicKey {
	if m != nil {
		return m.CachePublicKey
	}
	return nil
}

func (m *TicketL1) GetBlockIdx() uint64 {
	if m != nil {
		return m.BlockIdx
	}
	return 0
}

// By the time the L2 ticket is decrypted by the client, all of the caches must have provided data and outer encryption
// keys to the client; these are the inputs to the colocation puzzle, whose output is used to decrypt the L2 ticket.
type TicketL2 struct {
	// XXX: It seems like it might not be too hard for a cache to guess the plaintext L2 ticket that corresponds to the
	// hash that it knows.  This would be harder if we didn't tell each cache the toher caches' public keys *and*
	// included all of those keys in the hashed ticket L2.  However, it still seems as though the group of hashes trying
	// to claim the ticket could find each other when they all show up to try to claim their win.
	Nonce []byte `protobuf:"bytes,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// The inner session keys are here in order to force the client to solve the colocation puzzle (which is required in
	// order to decrypt the L2 ticket).
	InnerSessionKey      []*BlockKey `protobuf:"bytes,3,rep,name=inner_session_key,json=innerSessionKey" json:"inner_session_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *TicketL2) Reset()         { *m = TicketL2{} }
func (m *TicketL2) String() string { return proto.CompactTextString(m) }
func (*TicketL2) ProtoMessage()    {}
func (*TicketL2) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{14}
}
func (m *TicketL2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TicketL2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TicketL2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TicketL2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TicketL2.Merge(dst, src)
}
func (m *TicketL2) XXX_Size() int {
	return m.Size()
}
func (m *TicketL2) XXX_DiscardUnknown() {
	xxx_messageInfo_TicketL2.DiscardUnknown(m)
}

var xxx_messageInfo_TicketL2 proto.InternalMessageInfo

func (m *TicketL2) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *TicketL2) GetInnerSessionKey() []*BlockKey {
	if m != nil {
		return m.InnerSessionKey
	}
	return nil
}

// Globally-unique identifier for an escrow, based on the position of the transaction that started the escrow.
type EscrowID struct {
	BlockIdx             uint64   `protobuf:"varint,1,opt,name=block_idx,json=blockIdx,proto3" json:"block_idx,omitempty"`
	TransactionIdx       uint32   `protobuf:"varint,2,opt,name=transaction_idx,json=transactionIdx,proto3" json:"transaction_idx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EscrowID) Reset()         { *m = EscrowID{} }
func (m *EscrowID) String() string { return proto.CompactTextString(m) }
func (*EscrowID) ProtoMessage()    {}
func (*EscrowID) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{15}
}
func (m *EscrowID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EscrowID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EscrowID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EscrowID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EscrowID.Merge(dst, src)
}
func (m *EscrowID) XXX_Size() int {
	return m.Size()
}
func (m *EscrowID) XXX_DiscardUnknown() {
	xxx_messageInfo_EscrowID.DiscardUnknown(m)
}

var xxx_messageInfo_EscrowID proto.InternalMessageInfo

func (m *EscrowID) GetBlockIdx() uint64 {
	if m != nil {
		return m.BlockIdx
	}
	return 0
}

func (m *EscrowID) GetTransactionIdx() uint32 {
	if m != nil {
		return m.TransactionIdx
	}
	return 0
}

type TicketL2Info struct {
	EncryptedTicketL2    []byte   `protobuf:"bytes,1,opt,name=encrypted_ticket_l2,json=encryptedTicketL2,proto3" json:"encrypted_ticket_l2,omitempty"`
	PuzzleSecret         []byte   `protobuf:"bytes,2,opt,name=puzzle_secret,json=puzzleSecret,proto3" json:"puzzle_secret,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TicketL2Info) Reset()         { *m = TicketL2Info{} }
func (m *TicketL2Info) String() string { return proto.CompactTextString(m) }
func (*TicketL2Info) ProtoMessage()    {}
func (*TicketL2Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{16}
}
func (m *TicketL2Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TicketL2Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TicketL2Info.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TicketL2Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TicketL2Info.Merge(dst, src)
}
func (m *TicketL2Info) XXX_Size() int {
	return m.Size()
}
func (m *TicketL2Info) XXX_DiscardUnknown() {
	xxx_messageInfo_TicketL2Info.DiscardUnknown(m)
}

var xxx_messageInfo_TicketL2Info proto.InternalMessageInfo

func (m *TicketL2Info) GetEncryptedTicketL2() []byte {
	if m != nil {
		return m.EncryptedTicketL2
	}
	return nil
}

func (m *TicketL2Info) GetPuzzleSecret() []byte {
	if m != nil {
		return m.PuzzleSecret
	}
	return nil
}

// Signed by escrow key; ensures that the key that produced the batch signature is authorized.
type Certificate struct {
	SubjectPublicKey     *PublicKey `protobuf:"bytes,1,opt,name=subject_public_key,json=subjectPublicKey" json:"subject_public_key,omitempty"`
	EscrowId             *EscrowID  `protobuf:"bytes,2,opt,name=escrow_id,json=escrowId" json:"escrow_id,omitempty"`
	Usage                string     `protobuf:"bytes,3,opt,name=usage,proto3" json:"usage,omitempty"`
	Signature            []byte     `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Certificate) Reset()         { *m = Certificate{} }
func (m *Certificate) String() string { return proto.CompactTextString(m) }
func (*Certificate) ProtoMessage()    {}
func (*Certificate) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{17}
}
func (m *Certificate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Certificate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Certificate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Certificate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Certificate.Merge(dst, src)
}
func (m *Certificate) XXX_Size() int {
	return m.Size()
}
func (m *Certificate) XXX_DiscardUnknown() {
	xxx_messageInfo_Certificate.DiscardUnknown(m)
}

var xxx_messageInfo_Certificate proto.InternalMessageInfo

func (m *Certificate) GetSubjectPublicKey() *PublicKey {
	if m != nil {
		return m.SubjectPublicKey
	}
	return nil
}

func (m *Certificate) GetEscrowId() *EscrowID {
	if m != nil {
		return m.EscrowId
	}
	return nil
}

func (m *Certificate) GetUsage() string {
	if m != nil {
		return m.Usage
	}
	return ""
}

func (m *Certificate) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// Containss enough data to let a cache recompute/verify the ticket-bundle digest.
type TicketBundleSubdigests struct {
	TicketRequestDigest     [][]byte `protobuf:"bytes,1,rep,name=ticket_request_digest,json=ticketRequestDigest" json:"ticket_request_digest,omitempty"`
	TicketL1Digest          [][]byte `protobuf:"bytes,2,rep,name=ticket_l1_digest,json=ticketL1Digest" json:"ticket_l1_digest,omitempty"`
	EncryptedTicketL2Digest []byte   `protobuf:"bytes,3,opt,name=encrypted_ticket_l2_digest,json=encryptedTicketL2Digest,proto3" json:"encrypted_ticket_l2_digest,omitempty"`
	RemainderDigest         []byte   `protobuf:"bytes,4,opt,name=remainder_digest,json=remainderDigest,proto3" json:"remainder_digest,omitempty"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *TicketBundleSubdigests) Reset()         { *m = TicketBundleSubdigests{} }
func (m *TicketBundleSubdigests) String() string { return proto.CompactTextString(m) }
func (*TicketBundleSubdigests) ProtoMessage()    {}
func (*TicketBundleSubdigests) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{18}
}
func (m *TicketBundleSubdigests) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TicketBundleSubdigests) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TicketBundleSubdigests.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TicketBundleSubdigests) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TicketBundleSubdigests.Merge(dst, src)
}
func (m *TicketBundleSubdigests) XXX_Size() int {
	return m.Size()
}
func (m *TicketBundleSubdigests) XXX_DiscardUnknown() {
	xxx_messageInfo_TicketBundleSubdigests.DiscardUnknown(m)
}

var xxx_messageInfo_TicketBundleSubdigests proto.InternalMessageInfo

func (m *TicketBundleSubdigests) GetTicketRequestDigest() [][]byte {
	if m != nil {
		return m.TicketRequestDigest
	}
	return nil
}

func (m *TicketBundleSubdigests) GetTicketL1Digest() [][]byte {
	if m != nil {
		return m.TicketL1Digest
	}
	return nil
}

func (m *TicketBundleSubdigests) GetEncryptedTicketL2Digest() []byte {
	if m != nil {
		return m.EncryptedTicketL2Digest
	}
	return nil
}

func (m *TicketBundleSubdigests) GetRemainderDigest() []byte {
	if m != nil {
		return m.RemainderDigest
	}
	return nil
}

// Client-to-provider
type ContentRequest struct {
	// TODO: This does not actually need to be repeated with each request, if we are using a connection-oriented
	// transport.
	ClientPublicKey *PublicKey `protobuf:"bytes,1,opt,name=client_public_key,json=clientPublicKey" json:"client_public_key,omitempty"`
	Path            string     `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// In bytes; the provider can map that to blocks however it pleases.  range_begin is inclusive and range_end is
	// exclusive.  A value of zero for range_end means "the end of the object".
	RangeBegin           uint64   `protobuf:"varint,5,opt,name=range_begin,json=rangeBegin,proto3" json:"range_begin,omitempty"`
	RangeEnd             uint64   `protobuf:"varint,6,opt,name=range_end,json=rangeEnd,proto3" json:"range_end,omitempty"`
	SequenceNo           uint64   `protobuf:"varint,4,opt,name=sequence_no,json=sequenceNo,proto3" json:"sequence_no,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ContentRequest) Reset()         { *m = ContentRequest{} }
func (m *ContentRequest) String() string { return proto.CompactTextString(m) }
func (*ContentRequest) ProtoMessage()    {}
func (*ContentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{19}
}
func (m *ContentRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContentRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContentRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ContentRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContentRequest.Merge(dst, src)
}
func (m *ContentRequest) XXX_Size() int {
	return m.Size()
}
func (m *ContentRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ContentRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ContentRequest proto.InternalMessageInfo

func (m *ContentRequest) GetClientPublicKey() *PublicKey {
	if m != nil {
		return m.ClientPublicKey
	}
	return nil
}

func (m *ContentRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *ContentRequest) GetRangeBegin() uint64 {
	if m != nil {
		return m.RangeBegin
	}
	return 0
}

func (m *ContentRequest) GetRangeEnd() uint64 {
	if m != nil {
		return m.RangeEnd
	}
	return 0
}

func (m *ContentRequest) GetSequenceNo() uint64 {
	if m != nil {
		return m.SequenceNo
	}
	return 0
}

// Response to a ContentRequest.
type ContentResponse struct {
	// Identifies the request that this message is a response to.
	RequestSequenceNo uint64 `protobuf:"varint,1,opt,name=request_sequence_no,json=requestSequenceNo,proto3" json:"request_sequence_no,omitempty"`
	// Exactly one of these fields may be present.
	Error                *Error        `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	Bundle               *TicketBundle `protobuf:"bytes,3,opt,name=bundle" json:"bundle,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ContentResponse) Reset()         { *m = ContentResponse{} }
func (m *ContentResponse) String() string { return proto.CompactTextString(m) }
func (*ContentResponse) ProtoMessage()    {}
func (*ContentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{20}
}
func (m *ContentResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContentResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ContentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContentResponse.Merge(dst, src)
}
func (m *ContentResponse) XXX_Size() int {
	return m.Size()
}
func (m *ContentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ContentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ContentResponse proto.InternalMessageInfo

func (m *ContentResponse) GetRequestSequenceNo() uint64 {
	if m != nil {
		return m.RequestSequenceNo
	}
	return 0
}

func (m *ContentResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ContentResponse) GetBundle() *TicketBundle {
	if m != nil {
		return m.Bundle
	}
	return nil
}

type ClientCacheRequest struct {
	SequenceNo      uint64                 `protobuf:"varint,8,opt,name=sequence_no,json=sequenceNo,proto3" json:"sequence_no,omitempty"`
	BundleRemainder *TicketBundleRemainder `protobuf:"bytes,1,opt,name=bundle_remainder,json=bundleRemainder" json:"bundle_remainder,omitempty"`
	// Types that are valid to be assigned to Ticket:
	//	*ClientCacheRequest_TicketRequest
	//	*ClientCacheRequest_TicketL1
	//	*ClientCacheRequest_TicketL2
	Ticket isClientCacheRequest_Ticket `protobuf_oneof:"ticket"`
	// Together, these fields allow the cache to verify that the request is authorized.
	TicketBundleSubdigests *TicketBundleSubdigests `protobuf:"bytes,2,opt,name=ticket_bundle_subdigests,json=ticketBundleSubdigests" json:"ticket_bundle_subdigests,omitempty"`
	BundleSig              *BatchSignature         `protobuf:"bytes,3,opt,name=bundle_sig,json=bundleSig" json:"bundle_sig,omitempty"`
	BundleSignerCert       *Certificate            `protobuf:"bytes,4,opt,name=bundle_signer_cert,json=bundleSignerCert" json:"bundle_signer_cert,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                `json:"-"`
	XXX_unrecognized       []byte                  `json:"-"`
	XXX_sizecache          int32                   `json:"-"`
}

func (m *ClientCacheRequest) Reset()         { *m = ClientCacheRequest{} }
func (m *ClientCacheRequest) String() string { return proto.CompactTextString(m) }
func (*ClientCacheRequest) ProtoMessage()    {}
func (*ClientCacheRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{21}
}
func (m *ClientCacheRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientCacheRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientCacheRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ClientCacheRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientCacheRequest.Merge(dst, src)
}
func (m *ClientCacheRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClientCacheRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientCacheRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClientCacheRequest proto.InternalMessageInfo

type isClientCacheRequest_Ticket interface {
	isClientCacheRequest_Ticket()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClientCacheRequest_TicketRequest struct {
	TicketRequest *TicketRequest `protobuf:"bytes,5,opt,name=ticket_request,json=ticketRequest,oneof"`
}
type ClientCacheRequest_TicketL1 struct {
	TicketL1 *TicketL1 `protobuf:"bytes,6,opt,name=ticket_l1,json=ticketL1,oneof"`
}
type ClientCacheRequest_TicketL2 struct {
	TicketL2 *TicketL2Info `protobuf:"bytes,7,opt,name=ticket_l2,json=ticketL2,oneof"`
}

func (*ClientCacheRequest_TicketRequest) isClientCacheRequest_Ticket() {}
func (*ClientCacheRequest_TicketL1) isClientCacheRequest_Ticket()      {}
func (*ClientCacheRequest_TicketL2) isClientCacheRequest_Ticket()      {}

func (m *ClientCacheRequest) GetTicket() isClientCacheRequest_Ticket {
	if m != nil {
		return m.Ticket
	}
	return nil
}

func (m *ClientCacheRequest) GetSequenceNo() uint64 {
	if m != nil {
		return m.SequenceNo
	}
	return 0
}

func (m *ClientCacheRequest) GetBundleRemainder() *TicketBundleRemainder {
	if m != nil {
		return m.BundleRemainder
	}
	return nil
}

func (m *ClientCacheRequest) GetTicketRequest() *TicketRequest {
	if x, ok := m.GetTicket().(*ClientCacheRequest_TicketRequest); ok {
		return x.TicketRequest
	}
	return nil
}

func (m *ClientCacheRequest) GetTicketL1() *TicketL1 {
	if x, ok := m.GetTicket().(*ClientCacheRequest_TicketL1); ok {
		return x.TicketL1
	}
	return nil
}

func (m *ClientCacheRequest) GetTicketL2() *TicketL2Info {
	if x, ok := m.GetTicket().(*ClientCacheRequest_TicketL2); ok {
		return x.TicketL2
	}
	return nil
}

func (m *ClientCacheRequest) GetTicketBundleSubdigests() *TicketBundleSubdigests {
	if m != nil {
		return m.TicketBundleSubdigests
	}
	return nil
}

func (m *ClientCacheRequest) GetBundleSig() *BatchSignature {
	if m != nil {
		return m.BundleSig
	}
	return nil
}

func (m *ClientCacheRequest) GetBundleSignerCert() *Certificate {
	if m != nil {
		return m.BundleSignerCert
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ClientCacheRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ClientCacheRequest_OneofMarshaler, _ClientCacheRequest_OneofUnmarshaler, _ClientCacheRequest_OneofSizer, []interface{}{
		(*ClientCacheRequest_TicketRequest)(nil),
		(*ClientCacheRequest_TicketL1)(nil),
		(*ClientCacheRequest_TicketL2)(nil),
	}
}

func _ClientCacheRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ClientCacheRequest)
	// ticket
	switch x := m.Ticket.(type) {
	case *ClientCacheRequest_TicketRequest:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TicketRequest); err != nil {
			return err
		}
	case *ClientCacheRequest_TicketL1:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TicketL1); err != nil {
			return err
		}
	case *ClientCacheRequest_TicketL2:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TicketL2); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ClientCacheRequest.Ticket has unexpected type %T", x)
	}
	return nil
}

func _ClientCacheRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ClientCacheRequest)
	switch tag {
	case 5: // ticket.ticket_request
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TicketRequest)
		err := b.DecodeMessage(msg)
		m.Ticket = &ClientCacheRequest_TicketRequest{msg}
		return true, err
	case 6: // ticket.ticket_l1
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TicketL1)
		err := b.DecodeMessage(msg)
		m.Ticket = &ClientCacheRequest_TicketL1{msg}
		return true, err
	case 7: // ticket.ticket_l2
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TicketL2Info)
		err := b.DecodeMessage(msg)
		m.Ticket = &ClientCacheRequest_TicketL2{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ClientCacheRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ClientCacheRequest)
	// ticket
	switch x := m.Ticket.(type) {
	case *ClientCacheRequest_TicketRequest:
		s := proto.Size(x.TicketRequest)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientCacheRequest_TicketL1:
		s := proto.Size(x.TicketL1)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientCacheRequest_TicketL2:
		s := proto.Size(x.TicketL2)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// XXX: Remove me!  This is not used over the wire; it's used only in the `cache` package.
type ClientCacheResponse struct {
	// Identifies the request that this message is a response to.
	RequestSequenceNo uint64 `protobuf:"varint,1,opt,name=request_sequence_no,json=requestSequenceNo,proto3" json:"request_sequence_no,omitempty"`
	// Types that are valid to be assigned to Msg:
	//	*ClientCacheResponse_Error
	//	*ClientCacheResponse_DataResponse
	//	*ClientCacheResponse_L1Response
	//	*ClientCacheResponse_L2Response
	Msg                  isClientCacheResponse_Msg `protobuf_oneof:"msg"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *ClientCacheResponse) Reset()         { *m = ClientCacheResponse{} }
func (m *ClientCacheResponse) String() string { return proto.CompactTextString(m) }
func (*ClientCacheResponse) ProtoMessage()    {}
func (*ClientCacheResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{22}
}
func (m *ClientCacheResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientCacheResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientCacheResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ClientCacheResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientCacheResponse.Merge(dst, src)
}
func (m *ClientCacheResponse) XXX_Size() int {
	return m.Size()
}
func (m *ClientCacheResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientCacheResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClientCacheResponse proto.InternalMessageInfo

type isClientCacheResponse_Msg interface {
	isClientCacheResponse_Msg()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClientCacheResponse_Error struct {
	Error *Error `protobuf:"bytes,2,opt,name=error,oneof"`
}
type ClientCacheResponse_DataResponse struct {
	DataResponse *ClientCacheResponseData `protobuf:"bytes,3,opt,name=data_response,json=dataResponse,oneof"`
}
type ClientCacheResponse_L1Response struct {
	L1Response *ClientCacheResponseL1 `protobuf:"bytes,4,opt,name=l1_response,json=l1Response,oneof"`
}
type ClientCacheResponse_L2Response struct {
	L2Response *ClientCacheResponseL2 `protobuf:"bytes,5,opt,name=l2_response,json=l2Response,oneof"`
}

func (*ClientCacheResponse_Error) isClientCacheResponse_Msg()        {}
func (*ClientCacheResponse_DataResponse) isClientCacheResponse_Msg() {}
func (*ClientCacheResponse_L1Response) isClientCacheResponse_Msg()   {}
func (*ClientCacheResponse_L2Response) isClientCacheResponse_Msg()   {}

func (m *ClientCacheResponse) GetMsg() isClientCacheResponse_Msg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *ClientCacheResponse) GetRequestSequenceNo() uint64 {
	if m != nil {
		return m.RequestSequenceNo
	}
	return 0
}

func (m *ClientCacheResponse) GetError() *Error {
	if x, ok := m.GetMsg().(*ClientCacheResponse_Error); ok {
		return x.Error
	}
	return nil
}

func (m *ClientCacheResponse) GetDataResponse() *ClientCacheResponseData {
	if x, ok := m.GetMsg().(*ClientCacheResponse_DataResponse); ok {
		return x.DataResponse
	}
	return nil
}

func (m *ClientCacheResponse) GetL1Response() *ClientCacheResponseL1 {
	if x, ok := m.GetMsg().(*ClientCacheResponse_L1Response); ok {
		return x.L1Response
	}
	return nil
}

func (m *ClientCacheResponse) GetL2Response() *ClientCacheResponseL2 {
	if x, ok := m.GetMsg().(*ClientCacheResponse_L2Response); ok {
		return x.L2Response
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ClientCacheResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ClientCacheResponse_OneofMarshaler, _ClientCacheResponse_OneofUnmarshaler, _ClientCacheResponse_OneofSizer, []interface{}{
		(*ClientCacheResponse_Error)(nil),
		(*ClientCacheResponse_DataResponse)(nil),
		(*ClientCacheResponse_L1Response)(nil),
		(*ClientCacheResponse_L2Response)(nil),
	}
}

func _ClientCacheResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ClientCacheResponse)
	// msg
	switch x := m.Msg.(type) {
	case *ClientCacheResponse_Error:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case *ClientCacheResponse_DataResponse:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DataResponse); err != nil {
			return err
		}
	case *ClientCacheResponse_L1Response:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L1Response); err != nil {
			return err
		}
	case *ClientCacheResponse_L2Response:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L2Response); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ClientCacheResponse.Msg has unexpected type %T", x)
	}
	return nil
}

func _ClientCacheResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ClientCacheResponse)
	switch tag {
	case 2: // msg.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Msg = &ClientCacheResponse_Error{msg}
		return true, err
	case 3: // msg.data_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientCacheResponseData)
		err := b.DecodeMessage(msg)
		m.Msg = &ClientCacheResponse_DataResponse{msg}
		return true, err
	case 4: // msg.l1_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientCacheResponseL1)
		err := b.DecodeMessage(msg)
		m.Msg = &ClientCacheResponse_L1Response{msg}
		return true, err
	case 5: // msg.l2_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientCacheResponseL2)
		err := b.DecodeMessage(msg)
		m.Msg = &ClientCacheResponse_L2Response{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ClientCacheResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ClientCacheResponse)
	// msg
	switch x := m.Msg.(type) {
	case *ClientCacheResponse_Error:
		s := proto.Size(x.Error)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientCacheResponse_DataResponse:
		s := proto.Size(x.DataResponse)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientCacheResponse_L1Response:
		s := proto.Size(x.L1Response)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientCacheResponse_L2Response:
		s := proto.Size(x.L2Response)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ClientCacheResponseData struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientCacheResponseData) Reset()         { *m = ClientCacheResponseData{} }
func (m *ClientCacheResponseData) String() string { return proto.CompactTextString(m) }
func (*ClientCacheResponseData) ProtoMessage()    {}
func (*ClientCacheResponseData) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{23}
}
func (m *ClientCacheResponseData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientCacheResponseData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientCacheResponseData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ClientCacheResponseData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientCacheResponseData.Merge(dst, src)
}
func (m *ClientCacheResponseData) XXX_Size() int {
	return m.Size()
}
func (m *ClientCacheResponseData) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientCacheResponseData.DiscardUnknown(m)
}

var xxx_messageInfo_ClientCacheResponseData proto.InternalMessageInfo

func (m *ClientCacheResponseData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type ClientCacheResponseL1 struct {
	// contains the outer key
	OuterKey             *BlockKey `protobuf:"bytes,1,opt,name=outer_key,json=outerKey" json:"outer_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ClientCacheResponseL1) Reset()         { *m = ClientCacheResponseL1{} }
func (m *ClientCacheResponseL1) String() string { return proto.CompactTextString(m) }
func (*ClientCacheResponseL1) ProtoMessage()    {}
func (*ClientCacheResponseL1) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{24}
}
func (m *ClientCacheResponseL1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientCacheResponseL1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientCacheResponseL1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ClientCacheResponseL1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientCacheResponseL1.Merge(dst, src)
}
func (m *ClientCacheResponseL1) XXX_Size() int {
	return m.Size()
}
func (m *ClientCacheResponseL1) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientCacheResponseL1.DiscardUnknown(m)
}

var xxx_messageInfo_ClientCacheResponseL1 proto.InternalMessageInfo

func (m *ClientCacheResponseL1) GetOuterKey() *BlockKey {
	if m != nil {
		return m.OuterKey
	}
	return nil
}

type ClientCacheResponseL2 struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientCacheResponseL2) Reset()         { *m = ClientCacheResponseL2{} }
func (m *ClientCacheResponseL2) String() string { return proto.CompactTextString(m) }
func (*ClientCacheResponseL2) ProtoMessage()    {}
func (*ClientCacheResponseL2) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{25}
}
func (m *ClientCacheResponseL2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientCacheResponseL2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientCacheResponseL2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ClientCacheResponseL2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientCacheResponseL2.Merge(dst, src)
}
func (m *ClientCacheResponseL2) XXX_Size() int {
	return m.Size()
}
func (m *ClientCacheResponseL2) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientCacheResponseL2.DiscardUnknown(m)
}

var xxx_messageInfo_ClientCacheResponseL2 proto.InternalMessageInfo

// XXX: See similarities to ContentRequest.
type CacheMissRequest struct {
	// In blocks.
	// XXX: This was formerly in bytes.  Was there a good reason for that?
	RangeBegin           uint64   `protobuf:"varint,2,opt,name=range_begin,json=rangeBegin,proto3" json:"range_begin,omitempty"`
	RangeEnd             uint64   `protobuf:"varint,3,opt,name=range_end,json=rangeEnd,proto3" json:"range_end,omitempty"`
	ObjectId             uint64   `protobuf:"varint,4,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CacheMissRequest) Reset()         { *m = CacheMissRequest{} }
func (m *CacheMissRequest) String() string { return proto.CompactTextString(m) }
func (*CacheMissRequest) ProtoMessage()    {}
func (*CacheMissRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{26}
}
func (m *CacheMissRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheMissRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CacheMissRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CacheMissRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheMissRequest.Merge(dst, src)
}
func (m *CacheMissRequest) XXX_Size() int {
	return m.Size()
}
func (m *CacheMissRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheMissRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CacheMissRequest proto.InternalMessageInfo

func (m *CacheMissRequest) GetRangeBegin() uint64 {
	if m != nil {
		return m.RangeBegin
	}
	return 0
}

func (m *CacheMissRequest) GetRangeEnd() uint64 {
	if m != nil {
		return m.RangeEnd
	}
	return 0
}

func (m *CacheMissRequest) GetObjectId() uint64 {
	if m != nil {
		return m.ObjectId
	}
	return 0
}

type CacheMissResponse struct {
	SlotIdx  []uint64        `protobuf:"varint,1,rep,packed,name=slot_idx,json=slotIdx" json:"slot_idx,omitempty"`
	Metadata *ObjectMetadata `protobuf:"bytes,2,opt,name=metadata" json:"metadata,omitempty"`
	// Types that are valid to be assigned to Source:
	//	*CacheMissResponse_Http
	Source               isCacheMissResponse_Source `protobuf_oneof:"source"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *CacheMissResponse) Reset()         { *m = CacheMissResponse{} }
func (m *CacheMissResponse) String() string { return proto.CompactTextString(m) }
func (*CacheMissResponse) ProtoMessage()    {}
func (*CacheMissResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{27}
}
func (m *CacheMissResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheMissResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CacheMissResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CacheMissResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheMissResponse.Merge(dst, src)
}
func (m *CacheMissResponse) XXX_Size() int {
	return m.Size()
}
func (m *CacheMissResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheMissResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CacheMissResponse proto.InternalMessageInfo

type isCacheMissResponse_Source interface {
	isCacheMissResponse_Source()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CacheMissResponse_Http struct {
	Http *BlockSourceHTTP `protobuf:"bytes,10,opt,name=http,oneof"`
}

func (*CacheMissResponse_Http) isCacheMissResponse_Source() {}

func (m *CacheMissResponse) GetSource() isCacheMissResponse_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *CacheMissResponse) GetSlotIdx() []uint64 {
	if m != nil {
		return m.SlotIdx
	}
	return nil
}

func (m *CacheMissResponse) GetMetadata() *ObjectMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CacheMissResponse) GetHttp() *BlockSourceHTTP {
	if x, ok := m.GetSource().(*CacheMissResponse_Http); ok {
		return x.Http
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CacheMissResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CacheMissResponse_OneofMarshaler, _CacheMissResponse_OneofUnmarshaler, _CacheMissResponse_OneofSizer, []interface{}{
		(*CacheMissResponse_Http)(nil),
	}
}

func _CacheMissResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CacheMissResponse)
	// source
	switch x := m.Source.(type) {
	case *CacheMissResponse_Http:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Http); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CacheMissResponse.Source has unexpected type %T", x)
	}
	return nil
}

func _CacheMissResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CacheMissResponse)
	switch tag {
	case 10: // source.http
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BlockSourceHTTP)
		err := b.DecodeMessage(msg)
		m.Source = &CacheMissResponse_Http{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CacheMissResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CacheMissResponse)
	// source
	switch x := m.Source.(type) {
	case *CacheMissResponse_Http:
		s := proto.Size(x.Http)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type BlockSourceHTTP struct {
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	RangeBegin           uint64   `protobuf:"varint,2,opt,name=range_begin,json=rangeBegin,proto3" json:"range_begin,omitempty"`
	RangeEnd             uint64   `protobuf:"varint,3,opt,name=range_end,json=rangeEnd,proto3" json:"range_end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockSourceHTTP) Reset()         { *m = BlockSourceHTTP{} }
func (m *BlockSourceHTTP) String() string { return proto.CompactTextString(m) }
func (*BlockSourceHTTP) ProtoMessage()    {}
func (*BlockSourceHTTP) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{28}
}
func (m *BlockSourceHTTP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockSourceHTTP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockSourceHTTP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlockSourceHTTP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockSourceHTTP.Merge(dst, src)
}
func (m *BlockSourceHTTP) XXX_Size() int {
	return m.Size()
}
func (m *BlockSourceHTTP) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockSourceHTTP.DiscardUnknown(m)
}

var xxx_messageInfo_BlockSourceHTTP proto.InternalMessageInfo

func (m *BlockSourceHTTP) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *BlockSourceHTTP) GetRangeBegin() uint64 {
	if m != nil {
		return m.RangeBegin
	}
	return 0
}

func (m *BlockSourceHTTP) GetRangeEnd() uint64 {
	if m != nil {
		return m.RangeEnd
	}
	return 0
}

type ObjectMetadata struct {
	ObjectSize uint64 `protobuf:"varint,1,opt,name=object_size,json=objectSize,proto3" json:"object_size,omitempty"`
	BlockSize  uint64 `protobuf:"varint,2,opt,name=block_size,json=blockSize,proto3" json:"block_size,omitempty"`
	// Passed through by publisher from HTTP upstream.
	Etag         []byte `protobuf:"bytes,4,opt,name=etag,proto3" json:"etag,omitempty"`
	LastModified string `protobuf:"bytes,5,opt,name=last_modified,json=lastModified,proto3" json:"last_modified,omitempty"`
	// Decided by publisher based on HTTP headers.
	CacheExpiration      string   `protobuf:"bytes,6,opt,name=cache_expiration,json=cacheExpiration,proto3" json:"cache_expiration,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectMetadata) Reset()         { *m = ObjectMetadata{} }
func (m *ObjectMetadata) String() string { return proto.CompactTextString(m) }
func (*ObjectMetadata) ProtoMessage()    {}
func (*ObjectMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_cachecash_7f0259ca00fc5947, []int{29}
}
func (m *ObjectMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ObjectMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectMetadata.Merge(dst, src)
}
func (m *ObjectMetadata) XXX_Size() int {
	return m.Size()
}
func (m *ObjectMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectMetadata proto.InternalMessageInfo

func (m *ObjectMetadata) GetObjectSize() uint64 {
	if m != nil {
		return m.ObjectSize
	}
	return 0
}

func (m *ObjectMetadata) GetBlockSize() uint64 {
	if m != nil {
		return m.BlockSize
	}
	return 0
}

func (m *ObjectMetadata) GetEtag() []byte {
	if m != nil {
		return m.Etag
	}
	return nil
}

func (m *ObjectMetadata) GetLastModified() string {
	if m != nil {
		return m.LastModified
	}
	return ""
}

func (m *ObjectMetadata) GetCacheExpiration() string {
	if m != nil {
		return m.CacheExpiration
	}
	return ""
}

func init() {
	proto.RegisterType((*Error)(nil), "ccmsg.Error")
	proto.RegisterType((*PublicKey)(nil), "ccmsg.PublicKey")
	proto.RegisterType((*Envelope)(nil), "ccmsg.Envelope")
	proto.RegisterType((*EscrowInfo)(nil), "ccmsg.EscrowInfo")
	proto.RegisterType((*Segment)(nil), "ccmsg.Segment")
	proto.RegisterType((*TicketBundle)(nil), "ccmsg.TicketBundle")
	proto.RegisterType((*TicketBundleRemainder)(nil), "ccmsg.TicketBundleRemainder")
	proto.RegisterType((*CacheInfo)(nil), "ccmsg.CacheInfo")
	proto.RegisterType((*NetworkAddress)(nil), "ccmsg.NetworkAddress")
	proto.RegisterType((*ColocationPuzzleInfo)(nil), "ccmsg.ColocationPuzzleInfo")
	proto.RegisterType((*BatchSignature)(nil), "ccmsg.BatchSignature")
	proto.RegisterType((*BlockKey)(nil), "ccmsg.BlockKey")
	proto.RegisterType((*TicketRequest)(nil), "ccmsg.TicketRequest")
	proto.RegisterType((*TicketL1)(nil), "ccmsg.TicketL1")
	proto.RegisterType((*TicketL2)(nil), "ccmsg.TicketL2")
	proto.RegisterType((*EscrowID)(nil), "ccmsg.EscrowID")
	proto.RegisterType((*TicketL2Info)(nil), "ccmsg.TicketL2Info")
	proto.RegisterType((*Certificate)(nil), "ccmsg.Certificate")
	proto.RegisterType((*TicketBundleSubdigests)(nil), "ccmsg.TicketBundleSubdigests")
	proto.RegisterType((*ContentRequest)(nil), "ccmsg.ContentRequest")
	proto.RegisterType((*ContentResponse)(nil), "ccmsg.ContentResponse")
	proto.RegisterType((*ClientCacheRequest)(nil), "ccmsg.ClientCacheRequest")
	proto.RegisterType((*ClientCacheResponse)(nil), "ccmsg.ClientCacheResponse")
	proto.RegisterType((*ClientCacheResponseData)(nil), "ccmsg.ClientCacheResponseData")
	proto.RegisterType((*ClientCacheResponseL1)(nil), "ccmsg.ClientCacheResponseL1")
	proto.RegisterType((*ClientCacheResponseL2)(nil), "ccmsg.ClientCacheResponseL2")
	proto.RegisterType((*CacheMissRequest)(nil), "ccmsg.CacheMissRequest")
	proto.RegisterType((*CacheMissResponse)(nil), "ccmsg.CacheMissResponse")
	proto.RegisterType((*BlockSourceHTTP)(nil), "ccmsg.BlockSourceHTTP")
	proto.RegisterType((*ObjectMetadata)(nil), "ccmsg.ObjectMetadata")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ClientProvider service

type ClientProviderClient interface {
	GetContent(ctx context.Context, in *ContentRequest, opts ...grpc.CallOption) (*ContentResponse, error)
}

type clientProviderClient struct {
	cc *grpc.ClientConn
}

func NewClientProviderClient(cc *grpc.ClientConn) ClientProviderClient {
	return &clientProviderClient{cc}
}

func (c *clientProviderClient) GetContent(ctx context.Context, in *ContentRequest, opts ...grpc.CallOption) (*ContentResponse, error) {
	out := new(ContentResponse)
	err := c.cc.Invoke(ctx, "/ccmsg.ClientProvider/GetContent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ClientProvider service

type ClientProviderServer interface {
	GetContent(context.Context, *ContentRequest) (*ContentResponse, error)
}

func RegisterClientProviderServer(s *grpc.Server, srv ClientProviderServer) {
	s.RegisterService(&_ClientProvider_serviceDesc, srv)
}

func _ClientProvider_GetContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientProviderServer).GetContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmsg.ClientProvider/GetContent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientProviderServer).GetContent(ctx, req.(*ContentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ClientProvider_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ccmsg.ClientProvider",
	HandlerType: (*ClientProviderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetContent",
			Handler:    _ClientProvider_GetContent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cachecash.proto",
}

// Client API for ClientCache service

type ClientCacheClient interface {
	GetBlock(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseData, error)
	ExchangeTicketL1(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseL1, error)
	ExchangeTicketL2(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseL2, error)
}

type clientCacheClient struct {
	cc *grpc.ClientConn
}

func NewClientCacheClient(cc *grpc.ClientConn) ClientCacheClient {
	return &clientCacheClient{cc}
}

func (c *clientCacheClient) GetBlock(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseData, error) {
	out := new(ClientCacheResponseData)
	err := c.cc.Invoke(ctx, "/ccmsg.ClientCache/GetBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientCacheClient) ExchangeTicketL1(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseL1, error) {
	out := new(ClientCacheResponseL1)
	err := c.cc.Invoke(ctx, "/ccmsg.ClientCache/ExchangeTicketL1", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientCacheClient) ExchangeTicketL2(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseL2, error) {
	out := new(ClientCacheResponseL2)
	err := c.cc.Invoke(ctx, "/ccmsg.ClientCache/ExchangeTicketL2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ClientCache service

type ClientCacheServer interface {
	GetBlock(context.Context, *ClientCacheRequest) (*ClientCacheResponseData, error)
	ExchangeTicketL1(context.Context, *ClientCacheRequest) (*ClientCacheResponseL1, error)
	ExchangeTicketL2(context.Context, *ClientCacheRequest) (*ClientCacheResponseL2, error)
}

func RegisterClientCacheServer(s *grpc.Server, srv ClientCacheServer) {
	s.RegisterService(&_ClientCache_serviceDesc, srv)
}

func _ClientCache_GetBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientCacheServer).GetBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmsg.ClientCache/GetBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientCacheServer).GetBlock(ctx, req.(*ClientCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClientCache_ExchangeTicketL1_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientCacheServer).ExchangeTicketL1(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmsg.ClientCache/ExchangeTicketL1",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientCacheServer).ExchangeTicketL1(ctx, req.(*ClientCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClientCache_ExchangeTicketL2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientCacheServer).ExchangeTicketL2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmsg.ClientCache/ExchangeTicketL2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientCacheServer).ExchangeTicketL2(ctx, req.(*ClientCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ClientCache_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ccmsg.ClientCache",
	HandlerType: (*ClientCacheServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBlock",
			Handler:    _ClientCache_GetBlock_Handler,
		},
		{
			MethodName: "ExchangeTicketL1",
			Handler:    _ClientCache_ExchangeTicketL1_Handler,
		},
		{
			MethodName: "ExchangeTicketL2",
			Handler:    _ClientCache_ExchangeTicketL2_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cachecash.proto",
}

// Client API for CacheProvider service

type CacheProviderClient interface {
	CacheMiss(ctx context.Context, in *CacheMissRequest, opts ...grpc.CallOption) (*CacheMissResponse, error)
}

type cacheProviderClient struct {
	cc *grpc.ClientConn
}

func NewCacheProviderClient(cc *grpc.ClientConn) CacheProviderClient {
	return &cacheProviderClient{cc}
}

func (c *cacheProviderClient) CacheMiss(ctx context.Context, in *CacheMissRequest, opts ...grpc.CallOption) (*CacheMissResponse, error) {
	out := new(CacheMissResponse)
	err := c.cc.Invoke(ctx, "/ccmsg.CacheProvider/CacheMiss", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CacheProvider service

type CacheProviderServer interface {
	CacheMiss(context.Context, *CacheMissRequest) (*CacheMissResponse, error)
}

func RegisterCacheProviderServer(s *grpc.Server, srv CacheProviderServer) {
	s.RegisterService(&_CacheProvider_serviceDesc, srv)
}

func _CacheProvider_CacheMiss_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CacheMissRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheProviderServer).CacheMiss(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmsg.CacheProvider/CacheMiss",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheProviderServer).CacheMiss(ctx, req.(*CacheMissRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CacheProvider_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ccmsg.CacheProvider",
	HandlerType: (*CacheProviderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CacheMiss",
			Handler:    _CacheProvider_CacheMiss_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cachecash.proto",
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PublicKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PublicKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.PublicKey)))
		i += copy(dAtA[i:], m.PublicKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Envelope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Envelope) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Version))
	}
	if m.Msg != nil {
		nn1, err := m.Msg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Envelope_ContentRequest) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ContentRequest != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.ContentRequest.Size()))
		n2, err := m.ContentRequest.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *EscrowInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EscrowInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PublicKey != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.PublicKey.Size()))
		n3, err := m.PublicKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.ProviderPublicKey != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.ProviderPublicKey.Size()))
		n4, err := m.ProviderPublicKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.DrawDelay != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.DrawDelay))
	}
	if m.ExpirationDelay != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.ExpirationDelay))
	}
	if m.StartBlock != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.StartBlock))
	}
	if len(m.TicketsPerBlock) > 0 {
		for _, msg := range m.TicketsPerBlock {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Id != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Id.Size()))
		n5, err := m.Id.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Segment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Segment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Length != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Length))
	}
	if m.Value != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TicketBundle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketBundle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Remainder != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Remainder.Size()))
		n6, err := m.Remainder.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.TicketRequest) > 0 {
		for _, msg := range m.TicketRequest {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TicketL1) > 0 {
		for _, msg := range m.TicketL1 {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.BatchSig != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BatchSig.Size()))
		n7, err := m.BatchSig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.CacheInfo) > 0 {
		for _, msg := range m.CacheInfo {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EncryptedTicketL2) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.EncryptedTicketL2)))
		i += copy(dAtA[i:], m.EncryptedTicketL2)
	}
	if m.BundleSignerCert != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BundleSignerCert.Size()))
		n8, err := m.BundleSignerCert.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TicketBundleRemainder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketBundleRemainder) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EscrowId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.EscrowId.Size()))
		n9, err := m.EscrowId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.RequestSequenceNo != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RequestSequenceNo))
	}
	if m.ObjectId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.ObjectId))
	}
	if m.PuzzleInfo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.PuzzleInfo.Size()))
		n10, err := m.PuzzleInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.ClientPublicKey != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.ClientPublicKey.Size()))
		n11, err := m.ClientPublicKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CacheInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Addr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Addr.Size()))
		n12, err := m.Addr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NetworkAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkAddress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Inetaddr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Inetaddr)))
		i += copy(dAtA[i:], m.Inetaddr)
	}
	if len(m.Inet6Addr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Inet6Addr)))
		i += copy(dAtA[i:], m.Inet6Addr)
	}
	if m.Port != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ColocationPuzzleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColocationPuzzleInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rounds != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Rounds))
	}
	if len(m.Goal) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Goal)))
		i += copy(dAtA[i:], m.Goal)
	}
	if m.StartOffset != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.StartOffset))
	}
	if m.StartRange != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.StartRange))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BatchSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSignature) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PathDirection) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.PathDirection)))
		for _, b := range m.PathDirection {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.PathDigest) > 0 {
		for _, b := range m.PathDigest {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.RootSignature) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.RootSignature)))
		i += copy(dAtA[i:], m.RootSignature)
	}
	if m.SigningKey != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.SigningKey.Size()))
		n13, err := m.SigningKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TicketRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BlockIdx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BlockIdx))
	}
	if m.InnerKey != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.InnerKey.Size()))
		n14, err := m.InnerKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.CachePublicKey != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.CachePublicKey.Size()))
		n15, err := m.CachePublicKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.BlockId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BlockId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TicketL1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketL1) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TicketNo != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.TicketNo))
	}
	if m.CachePublicKey != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.CachePublicKey.Size()))
		n16, err := m.CachePublicKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.BlockIdx != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BlockIdx))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TicketL2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketL2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nonce) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Nonce)))
		i += copy(dAtA[i:], m.Nonce)
	}
	if len(m.InnerSessionKey) > 0 {
		for _, msg := range m.InnerSessionKey {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EscrowID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EscrowID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BlockIdx != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BlockIdx))
	}
	if m.TransactionIdx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.TransactionIdx))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TicketL2Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketL2Info) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EncryptedTicketL2) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.EncryptedTicketL2)))
		i += copy(dAtA[i:], m.EncryptedTicketL2)
	}
	if len(m.PuzzleSecret) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.PuzzleSecret)))
		i += copy(dAtA[i:], m.PuzzleSecret)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Certificate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Certificate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SubjectPublicKey != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.SubjectPublicKey.Size()))
		n17, err := m.SubjectPublicKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.EscrowId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.EscrowId.Size()))
		n18, err := m.EscrowId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if len(m.Usage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Usage)))
		i += copy(dAtA[i:], m.Usage)
	}
	if len(m.Signature) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TicketBundleSubdigests) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketBundleSubdigests) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TicketRequestDigest) > 0 {
		for _, b := range m.TicketRequestDigest {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.TicketL1Digest) > 0 {
		for _, b := range m.TicketL1Digest {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.EncryptedTicketL2Digest) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.EncryptedTicketL2Digest)))
		i += copy(dAtA[i:], m.EncryptedTicketL2Digest)
	}
	if len(m.RemainderDigest) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.RemainderDigest)))
		i += copy(dAtA[i:], m.RemainderDigest)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ContentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContentRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClientPublicKey != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.ClientPublicKey.Size()))
		n19, err := m.ClientPublicKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.SequenceNo != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.SequenceNo))
	}
	if m.RangeBegin != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RangeBegin))
	}
	if m.RangeEnd != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RangeEnd))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ContentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContentResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestSequenceNo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RequestSequenceNo))
	}
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Error.Size()))
		n20, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Bundle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Bundle.Size()))
		n21, err := m.Bundle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClientCacheRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCacheRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BundleRemainder != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BundleRemainder.Size()))
		n22, err := m.BundleRemainder.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.TicketBundleSubdigests != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.TicketBundleSubdigests.Size()))
		n23, err := m.TicketBundleSubdigests.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.BundleSig != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BundleSig.Size()))
		n24, err := m.BundleSig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.BundleSignerCert != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BundleSignerCert.Size()))
		n25, err := m.BundleSignerCert.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Ticket != nil {
		nn26, err := m.Ticket.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn26
	}
	if m.SequenceNo != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.SequenceNo))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClientCacheRequest_TicketRequest) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TicketRequest != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.TicketRequest.Size()))
		n27, err := m.TicketRequest.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}
func (m *ClientCacheRequest_TicketL1) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TicketL1 != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.TicketL1.Size()))
		n28, err := m.TicketL1.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}
func (m *ClientCacheRequest_TicketL2) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TicketL2 != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.TicketL2.Size()))
		n29, err := m.TicketL2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}
func (m *ClientCacheResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCacheResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestSequenceNo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RequestSequenceNo))
	}
	if m.Msg != nil {
		nn30, err := m.Msg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn30
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClientCacheResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Error.Size()))
		n31, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}
func (m *ClientCacheResponse_DataResponse) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DataResponse != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.DataResponse.Size()))
		n32, err := m.DataResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}
func (m *ClientCacheResponse_L1Response) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.L1Response != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.L1Response.Size()))
		n33, err := m.L1Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}
func (m *ClientCacheResponse_L2Response) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.L2Response != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.L2Response.Size()))
		n34, err := m.L2Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}
func (m *ClientCacheResponseData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCacheResponseData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClientCacheResponseL1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCacheResponseL1) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OuterKey != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.OuterKey.Size()))
		n35, err := m.OuterKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClientCacheResponseL2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCacheResponseL2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CacheMissRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheMissRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RangeBegin != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RangeBegin))
	}
	if m.RangeEnd != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RangeEnd))
	}
	if m.ObjectId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.ObjectId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CacheMissResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheMissResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SlotIdx) > 0 {
		dAtA37 := make([]byte, len(m.SlotIdx)*10)
		var j36 int
		for _, num := range m.SlotIdx {
			for num >= 1<<7 {
				dAtA37[j36] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j36++
			}
			dAtA37[j36] = uint8(num)
			j36++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(j36))
		i += copy(dAtA[i:], dAtA37[:j36])
	}
	if m.Metadata != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Metadata.Size()))
		n38, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.Source != nil {
		nn39, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn39
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CacheMissResponse_Http) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Http != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Http.Size()))
		n40, err := m.Http.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}
func (m *BlockSourceHTTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockSourceHTTP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.RangeBegin != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RangeBegin))
	}
	if m.RangeEnd != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RangeEnd))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ObjectMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjectSize != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.ObjectSize))
	}
	if m.BlockSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BlockSize))
	}
	if len(m.Etag) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Etag)))
		i += copy(dAtA[i:], m.Etag)
	}
	if len(m.LastModified) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.LastModified)))
		i += copy(dAtA[i:], m.LastModified)
	}
	if len(m.CacheExpiration) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.CacheExpiration)))
		i += copy(dAtA[i:], m.CacheExpiration)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintCachecash(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Error) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovCachecash(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PublicKey) Size() (n int) {
	var l int
	_ = l
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Envelope) Size() (n int) {
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovCachecash(uint64(m.Version))
	}
	if m.Msg != nil {
		n += m.Msg.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Envelope_ContentRequest) Size() (n int) {
	var l int
	_ = l
	if m.ContentRequest != nil {
		l = m.ContentRequest.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *EscrowInfo) Size() (n int) {
	var l int
	_ = l
	if m.PublicKey != nil {
		l = m.PublicKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.ProviderPublicKey != nil {
		l = m.ProviderPublicKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.DrawDelay != 0 {
		n += 1 + sovCachecash(uint64(m.DrawDelay))
	}
	if m.ExpirationDelay != 0 {
		n += 1 + sovCachecash(uint64(m.ExpirationDelay))
	}
	if m.StartBlock != 0 {
		n += 1 + sovCachecash(uint64(m.StartBlock))
	}
	if len(m.TicketsPerBlock) > 0 {
		for _, e := range m.TicketsPerBlock {
			l = e.Size()
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Segment) Size() (n int) {
	var l int
	_ = l
	if m.Length != 0 {
		n += 1 + sovCachecash(uint64(m.Length))
	}
	if m.Value != 0 {
		n += 1 + sovCachecash(uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TicketBundle) Size() (n int) {
	var l int
	_ = l
	if m.Remainder != nil {
		l = m.Remainder.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if len(m.TicketRequest) > 0 {
		for _, e := range m.TicketRequest {
			l = e.Size()
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	if len(m.TicketL1) > 0 {
		for _, e := range m.TicketL1 {
			l = e.Size()
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	if m.BatchSig != nil {
		l = m.BatchSig.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if len(m.CacheInfo) > 0 {
		for _, e := range m.CacheInfo {
			l = e.Size()
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	l = len(m.EncryptedTicketL2)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.BundleSignerCert != nil {
		l = m.BundleSignerCert.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TicketBundleRemainder) Size() (n int) {
	var l int
	_ = l
	if m.EscrowId != nil {
		l = m.EscrowId.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.RequestSequenceNo != 0 {
		n += 1 + sovCachecash(uint64(m.RequestSequenceNo))
	}
	if m.ObjectId != 0 {
		n += 1 + sovCachecash(uint64(m.ObjectId))
	}
	if m.PuzzleInfo != nil {
		l = m.PuzzleInfo.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.ClientPublicKey != nil {
		l = m.ClientPublicKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CacheInfo) Size() (n int) {
	var l int
	_ = l
	if m.Addr != nil {
		l = m.Addr.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkAddress) Size() (n int) {
	var l int
	_ = l
	l = len(m.Inetaddr)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.Inet6Addr)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovCachecash(uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColocationPuzzleInfo) Size() (n int) {
	var l int
	_ = l
	if m.Rounds != 0 {
		n += 1 + sovCachecash(uint64(m.Rounds))
	}
	l = len(m.Goal)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.StartOffset != 0 {
		n += 1 + sovCachecash(uint64(m.StartOffset))
	}
	if m.StartRange != 0 {
		n += 1 + sovCachecash(uint64(m.StartRange))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BatchSignature) Size() (n int) {
	var l int
	_ = l
	if len(m.PathDirection) > 0 {
		n += 1 + sovCachecash(uint64(len(m.PathDirection))) + len(m.PathDirection)*1
	}
	if len(m.PathDigest) > 0 {
		for _, b := range m.PathDigest {
			l = len(b)
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	l = len(m.RootSignature)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.SigningKey != nil {
		l = m.SigningKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockKey) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TicketRequest) Size() (n int) {
	var l int
	_ = l
	if m.BlockIdx != 0 {
		n += 1 + sovCachecash(uint64(m.BlockIdx))
	}
	if m.InnerKey != nil {
		l = m.InnerKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.CachePublicKey != nil {
		l = m.CachePublicKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.BlockId != 0 {
		n += 1 + sovCachecash(uint64(m.BlockId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TicketL1) Size() (n int) {
	var l int
	_ = l
	if m.TicketNo != 0 {
		n += 1 + sovCachecash(uint64(m.TicketNo))
	}
	if m.CachePublicKey != nil {
		l = m.CachePublicKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.BlockIdx != 0 {
		n += 1 + sovCachecash(uint64(m.BlockIdx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TicketL2) Size() (n int) {
	var l int
	_ = l
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if len(m.InnerSessionKey) > 0 {
		for _, e := range m.InnerSessionKey {
			l = e.Size()
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EscrowID) Size() (n int) {
	var l int
	_ = l
	if m.BlockIdx != 0 {
		n += 1 + sovCachecash(uint64(m.BlockIdx))
	}
	if m.TransactionIdx != 0 {
		n += 1 + sovCachecash(uint64(m.TransactionIdx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TicketL2Info) Size() (n int) {
	var l int
	_ = l
	l = len(m.EncryptedTicketL2)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.PuzzleSecret)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Certificate) Size() (n int) {
	var l int
	_ = l
	if m.SubjectPublicKey != nil {
		l = m.SubjectPublicKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.EscrowId != nil {
		l = m.EscrowId.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.Usage)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TicketBundleSubdigests) Size() (n int) {
	var l int
	_ = l
	if len(m.TicketRequestDigest) > 0 {
		for _, b := range m.TicketRequestDigest {
			l = len(b)
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	if len(m.TicketL1Digest) > 0 {
		for _, b := range m.TicketL1Digest {
			l = len(b)
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	l = len(m.EncryptedTicketL2Digest)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.RemainderDigest)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContentRequest) Size() (n int) {
	var l int
	_ = l
	if m.ClientPublicKey != nil {
		l = m.ClientPublicKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.SequenceNo != 0 {
		n += 1 + sovCachecash(uint64(m.SequenceNo))
	}
	if m.RangeBegin != 0 {
		n += 1 + sovCachecash(uint64(m.RangeBegin))
	}
	if m.RangeEnd != 0 {
		n += 1 + sovCachecash(uint64(m.RangeEnd))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContentResponse) Size() (n int) {
	var l int
	_ = l
	if m.RequestSequenceNo != 0 {
		n += 1 + sovCachecash(uint64(m.RequestSequenceNo))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.Bundle != nil {
		l = m.Bundle.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientCacheRequest) Size() (n int) {
	var l int
	_ = l
	if m.BundleRemainder != nil {
		l = m.BundleRemainder.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.TicketBundleSubdigests != nil {
		l = m.TicketBundleSubdigests.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.BundleSig != nil {
		l = m.BundleSig.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.BundleSignerCert != nil {
		l = m.BundleSignerCert.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.Ticket != nil {
		n += m.Ticket.Size()
	}
	if m.SequenceNo != 0 {
		n += 1 + sovCachecash(uint64(m.SequenceNo))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientCacheRequest_TicketRequest) Size() (n int) {
	var l int
	_ = l
	if m.TicketRequest != nil {
		l = m.TicketRequest.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *ClientCacheRequest_TicketL1) Size() (n int) {
	var l int
	_ = l
	if m.TicketL1 != nil {
		l = m.TicketL1.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *ClientCacheRequest_TicketL2) Size() (n int) {
	var l int
	_ = l
	if m.TicketL2 != nil {
		l = m.TicketL2.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *ClientCacheResponse) Size() (n int) {
	var l int
	_ = l
	if m.RequestSequenceNo != 0 {
		n += 1 + sovCachecash(uint64(m.RequestSequenceNo))
	}
	if m.Msg != nil {
		n += m.Msg.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientCacheResponse_Error) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *ClientCacheResponse_DataResponse) Size() (n int) {
	var l int
	_ = l
	if m.DataResponse != nil {
		l = m.DataResponse.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *ClientCacheResponse_L1Response) Size() (n int) {
	var l int
	_ = l
	if m.L1Response != nil {
		l = m.L1Response.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *ClientCacheResponse_L2Response) Size() (n int) {
	var l int
	_ = l
	if m.L2Response != nil {
		l = m.L2Response.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *ClientCacheResponseData) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientCacheResponseL1) Size() (n int) {
	var l int
	_ = l
	if m.OuterKey != nil {
		l = m.OuterKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientCacheResponseL2) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CacheMissRequest) Size() (n int) {
	var l int
	_ = l
	if m.RangeBegin != 0 {
		n += 1 + sovCachecash(uint64(m.RangeBegin))
	}
	if m.RangeEnd != 0 {
		n += 1 + sovCachecash(uint64(m.RangeEnd))
	}
	if m.ObjectId != 0 {
		n += 1 + sovCachecash(uint64(m.ObjectId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CacheMissResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.SlotIdx) > 0 {
		l = 0
		for _, e := range m.SlotIdx {
			l += sovCachecash(uint64(e))
		}
		n += 1 + sovCachecash(uint64(l)) + l
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.Source != nil {
		n += m.Source.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CacheMissResponse_Http) Size() (n int) {
	var l int
	_ = l
	if m.Http != nil {
		l = m.Http.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *BlockSourceHTTP) Size() (n int) {
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.RangeBegin != 0 {
		n += 1 + sovCachecash(uint64(m.RangeBegin))
	}
	if m.RangeEnd != 0 {
		n += 1 + sovCachecash(uint64(m.RangeEnd))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectMetadata) Size() (n int) {
	var l int
	_ = l
	if m.ObjectSize != 0 {
		n += 1 + sovCachecash(uint64(m.ObjectSize))
	}
	if m.BlockSize != 0 {
		n += 1 + sovCachecash(uint64(m.BlockSize))
	}
	l = len(m.Etag)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.LastModified)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.CacheExpiration)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCachecash(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCachecash(x uint64) (n int) {
	return sovCachecash(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Envelope) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Envelope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Envelope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ContentRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &Envelope_ContentRequest{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EscrowInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EscrowInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EscrowInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublicKey == nil {
				m.PublicKey = &PublicKey{}
			}
			if err := m.PublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProviderPublicKey == nil {
				m.ProviderPublicKey = &PublicKey{}
			}
			if err := m.ProviderPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrawDelay", wireType)
			}
			m.DrawDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DrawDelay |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationDelay", wireType)
			}
			m.ExpirationDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationDelay |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBlock", wireType)
			}
			m.StartBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartBlock |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketsPerBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketsPerBlock = append(m.TicketsPerBlock, &Segment{})
			if err := m.TicketsPerBlock[len(m.TicketsPerBlock)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &EscrowID{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Segment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Segment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Segment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketBundle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketBundle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketBundle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remainder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Remainder == nil {
				m.Remainder = &TicketBundleRemainder{}
			}
			if err := m.Remainder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketRequest = append(m.TicketRequest, &TicketRequest{})
			if err := m.TicketRequest[len(m.TicketRequest)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketL1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketL1 = append(m.TicketL1, &TicketL1{})
			if err := m.TicketL1[len(m.TicketL1)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchSig == nil {
				m.BatchSig = &BatchSignature{}
			}
			if err := m.BatchSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheInfo = append(m.CacheInfo, &CacheInfo{})
			if err := m.CacheInfo[len(m.CacheInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedTicketL2", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedTicketL2 = append(m.EncryptedTicketL2[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedTicketL2 == nil {
				m.EncryptedTicketL2 = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleSignerCert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BundleSignerCert == nil {
				m.BundleSignerCert = &Certificate{}
			}
			if err := m.BundleSignerCert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketBundleRemainder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketBundleRemainder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketBundleRemainder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EscrowId == nil {
				m.EscrowId = &EscrowID{}
			}
			if err := m.EscrowId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestSequenceNo", wireType)
			}
			m.RequestSequenceNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestSequenceNo |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			m.ObjectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PuzzleInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PuzzleInfo == nil {
				m.PuzzleInfo = &ColocationPuzzleInfo{}
			}
			if err := m.PuzzleInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientPublicKey == nil {
				m.ClientPublicKey = &PublicKey{}
			}
			if err := m.ClientPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Addr == nil {
				m.Addr = &NetworkAddress{}
			}
			if err := m.Addr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inetaddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inetaddr = append(m.Inetaddr[:0], dAtA[iNdEx:postIndex]...)
			if m.Inetaddr == nil {
				m.Inetaddr = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inet6Addr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inet6Addr = append(m.Inet6Addr[:0], dAtA[iNdEx:postIndex]...)
			if m.Inet6Addr == nil {
				m.Inet6Addr = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColocationPuzzleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColocationPuzzleInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColocationPuzzleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rounds", wireType)
			}
			m.Rounds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rounds |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Goal = append(m.Goal[:0], dAtA[iNdEx:postIndex]...)
			if m.Goal == nil {
				m.Goal = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartOffset", wireType)
			}
			m.StartOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartOffset |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartRange", wireType)
			}
			m.StartRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartRange |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCachecash
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PathDirection = append(m.PathDirection, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCachecash
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCachecash
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCachecash
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PathDirection = append(m.PathDirection, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PathDirection", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathDigest = append(m.PathDigest, make([]byte, postIndex-iNdEx))
			copy(m.PathDigest[len(m.PathDigest)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootSignature = append(m.RootSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.RootSignature == nil {
				m.RootSignature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SigningKey == nil {
				m.SigningKey = &PublicKey{}
			}
			if err := m.SigningKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockIdx", wireType)
			}
			m.BlockIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockIdx |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InnerKey == nil {
				m.InnerKey = &BlockKey{}
			}
			if err := m.InnerKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachePublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CachePublicKey == nil {
				m.CachePublicKey = &PublicKey{}
			}
			if err := m.CachePublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockId", wireType)
			}
			m.BlockId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketL1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketL1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketL1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketNo", wireType)
			}
			m.TicketNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TicketNo |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachePublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CachePublicKey == nil {
				m.CachePublicKey = &PublicKey{}
			}
			if err := m.CachePublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockIdx", wireType)
			}
			m.BlockIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockIdx |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketL2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketL2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketL2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = append(m.Nonce[:0], dAtA[iNdEx:postIndex]...)
			if m.Nonce == nil {
				m.Nonce = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerSessionKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InnerSessionKey = append(m.InnerSessionKey, &BlockKey{})
			if err := m.InnerSessionKey[len(m.InnerSessionKey)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EscrowID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EscrowID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EscrowID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockIdx", wireType)
			}
			m.BlockIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockIdx |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionIdx", wireType)
			}
			m.TransactionIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketL2Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketL2Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketL2Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedTicketL2", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedTicketL2 = append(m.EncryptedTicketL2[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedTicketL2 == nil {
				m.EncryptedTicketL2 = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PuzzleSecret", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PuzzleSecret = append(m.PuzzleSecret[:0], dAtA[iNdEx:postIndex]...)
			if m.PuzzleSecret == nil {
				m.PuzzleSecret = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Certificate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Certificate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Certificate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubjectPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubjectPublicKey == nil {
				m.SubjectPublicKey = &PublicKey{}
			}
			if err := m.SubjectPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EscrowId == nil {
				m.EscrowId = &EscrowID{}
			}
			if err := m.EscrowId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Usage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketBundleSubdigests) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketBundleSubdigests: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketBundleSubdigests: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketRequestDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketRequestDigest = append(m.TicketRequestDigest, make([]byte, postIndex-iNdEx))
			copy(m.TicketRequestDigest[len(m.TicketRequestDigest)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketL1Digest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketL1Digest = append(m.TicketL1Digest, make([]byte, postIndex-iNdEx))
			copy(m.TicketL1Digest[len(m.TicketL1Digest)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedTicketL2Digest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedTicketL2Digest = append(m.EncryptedTicketL2Digest[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedTicketL2Digest == nil {
				m.EncryptedTicketL2Digest = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainderDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemainderDigest = append(m.RemainderDigest[:0], dAtA[iNdEx:postIndex]...)
			if m.RemainderDigest == nil {
				m.RemainderDigest = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientPublicKey == nil {
				m.ClientPublicKey = &PublicKey{}
			}
			if err := m.ClientPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNo", wireType)
			}
			m.SequenceNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNo |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeBegin", wireType)
			}
			m.RangeBegin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeBegin |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeEnd", wireType)
			}
			m.RangeEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeEnd |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestSequenceNo", wireType)
			}
			m.RequestSequenceNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestSequenceNo |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bundle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bundle == nil {
				m.Bundle = &TicketBundle{}
			}
			if err := m.Bundle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientCacheRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCacheRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCacheRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleRemainder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BundleRemainder == nil {
				m.BundleRemainder = &TicketBundleRemainder{}
			}
			if err := m.BundleRemainder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketBundleSubdigests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TicketBundleSubdigests == nil {
				m.TicketBundleSubdigests = &TicketBundleSubdigests{}
			}
			if err := m.TicketBundleSubdigests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleSig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BundleSig == nil {
				m.BundleSig = &BatchSignature{}
			}
			if err := m.BundleSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleSignerCert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BundleSignerCert == nil {
				m.BundleSignerCert = &Certificate{}
			}
			if err := m.BundleSignerCert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TicketRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ticket = &ClientCacheRequest_TicketRequest{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketL1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TicketL1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ticket = &ClientCacheRequest_TicketL1{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketL2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TicketL2Info{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ticket = &ClientCacheRequest_TicketL2{v}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNo", wireType)
			}
			m.SequenceNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNo |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientCacheResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCacheResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCacheResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestSequenceNo", wireType)
			}
			m.RequestSequenceNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestSequenceNo |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &ClientCacheResponse_Error{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClientCacheResponseData{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &ClientCacheResponse_DataResponse{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClientCacheResponseL1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &ClientCacheResponse_L1Response{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClientCacheResponseL2{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &ClientCacheResponse_L2Response{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientCacheResponseData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCacheResponseData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCacheResponseData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientCacheResponseL1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCacheResponseL1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCacheResponseL1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OuterKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OuterKey == nil {
				m.OuterKey = &BlockKey{}
			}
			if err := m.OuterKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientCacheResponseL2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCacheResponseL2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCacheResponseL2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheMissRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheMissRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheMissRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeBegin", wireType)
			}
			m.RangeBegin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeBegin |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeEnd", wireType)
			}
			m.RangeEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeEnd |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			m.ObjectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheMissResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheMissResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheMissResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCachecash
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SlotIdx = append(m.SlotIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCachecash
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCachecash
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCachecash
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SlotIdx = append(m.SlotIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotIdx", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &ObjectMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockSourceHTTP{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Source = &CacheMissResponse_Http{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockSourceHTTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockSourceHTTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockSourceHTTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeBegin", wireType)
			}
			m.RangeBegin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeBegin |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeEnd", wireType)
			}
			m.RangeEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeEnd |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectSize", wireType)
			}
			m.ObjectSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockSize", wireType)
			}
			m.BlockSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etag", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Etag = append(m.Etag[:0], dAtA[iNdEx:postIndex]...)
			if m.Etag == nil {
				m.Etag = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModified", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastModified = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheExpiration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheExpiration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCachecash(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCachecash
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCachecash
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCachecash(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCachecash = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCachecash   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("cachecash.proto", fileDescriptor_cachecash_7f0259ca00fc5947) }

var fileDescriptor_cachecash_7f0259ca00fc5947 = []byte{
	// 1868 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0xcd, 0x73, 0xdc, 0x4a,
	0x11, 0x5f, 0xed, 0x87, 0xad, 0xed, 0xfd, 0xf4, 0x38, 0x71, 0x36, 0x79, 0x89, 0x63, 0x04, 0x14,
	0x0e, 0x3c, 0x4c, 0x59, 0xc0, 0xa3, 0x2a, 0x79, 0x0f, 0x82, 0x13, 0x57, 0x9c, 0xe2, 0x25, 0x31,
	0xda, 0x54, 0x71, 0x02, 0x95, 0x56, 0x1a, 0xaf, 0x45, 0x64, 0x69, 0x19, 0xcd, 0xe6, 0xeb, 0xc4,
	0x89, 0x13, 0xc5, 0x81, 0x13, 0xfc, 0x15, 0x14, 0x14, 0x37, 0x4e, 0x9c, 0xe0, 0xc8, 0x5f, 0x40,
	0x51, 0xe1, 0x5f, 0xe0, 0xc8, 0x81, 0xea, 0x9e, 0x91, 0xb4, 0x5a, 0x6b, 0x1d, 0x93, 0x77, 0xda,
	0x99, 0x9e, 0x56, 0x4f, 0xab, 0x3f, 0x7e, 0xfd, 0x5b, 0xc1, 0xc0, 0xf7, 0xfc, 0x53, 0xee, 0x7b,
	0xe9, 0xe9, 0xde, 0x4c, 0x24, 0x32, 0x61, 0x2d, 0xdf, 0x3f, 0x4b, 0xa7, 0xd6, 0x77, 0xa1, 0x75,
	0x28, 0x44, 0x22, 0x18, 0x83, 0xa6, 0x9f, 0x04, 0x7c, 0x64, 0xec, 0x18, 0xbb, 0x4d, 0x87, 0xd6,
	0x6c, 0x04, 0xeb, 0x67, 0x3c, 0x4d, 0xbd, 0x29, 0x1f, 0xd5, 0x77, 0x8c, 0xdd, 0xb6, 0x93, 0x6d,
	0xad, 0xaf, 0x43, 0xfb, 0x78, 0x3e, 0x89, 0x42, 0xff, 0x47, 0xfc, 0x0d, 0xbb, 0x05, 0x30, 0xa3,
	0x8d, 0xfb, 0x82, 0xbf, 0x21, 0x03, 0x5d, 0xa7, 0x3d, 0xcb, 0x8e, 0xad, 0x33, 0x30, 0x0f, 0xe3,
	0x97, 0x3c, 0x4a, 0x66, 0x64, 0xf1, 0x25, 0x17, 0x69, 0x98, 0xc4, 0xa4, 0xd7, 0x73, 0xb2, 0x2d,
	0xbb, 0x0f, 0x03, 0x3f, 0x89, 0x25, 0x8f, 0xa5, 0x2b, 0xf8, 0x2f, 0xe6, 0x3c, 0x95, 0x74, 0x67,
	0xc7, 0xbe, 0xba, 0x47, 0x9e, 0xee, 0x3d, 0x50, 0xa7, 0x8e, 0x3a, 0x3c, 0xaa, 0x39, 0x7d, 0xbf,
	0x24, 0x39, 0x68, 0x41, 0x03, 0xdf, 0xe8, 0x6f, 0x75, 0x80, 0xc3, 0xd4, 0x17, 0xc9, 0xab, 0xc7,
	0xf1, 0x49, 0xc2, 0xbe, 0x75, 0xce, 0xb9, 0x8e, 0x3d, 0xd4, 0x26, 0xf3, 0x57, 0x58, 0x70, 0x97,
	0xdd, 0x87, 0xcd, 0x99, 0x48, 0x5e, 0x86, 0x01, 0x17, 0xee, 0xc2, 0x93, 0xf5, 0x15, 0x4f, 0x6e,
	0x64, 0xca, 0xa5, 0x78, 0x04, 0xc2, 0x7b, 0xe5, 0x06, 0x3c, 0xf2, 0xde, 0x8c, 0x1a, 0x14, 0xd0,
	0x36, 0x4a, 0x1e, 0xa2, 0x80, 0xdd, 0x81, 0x21, 0x7f, 0x3d, 0x0b, 0x85, 0x27, 0xc3, 0x24, 0xd6,
	0x4a, 0x4d, 0x52, 0x1a, 0x14, 0x72, 0xa5, 0x7a, 0x1b, 0x3a, 0xa9, 0xf4, 0x84, 0x74, 0x27, 0x51,
	0xe2, 0xbf, 0x18, 0xb5, 0x48, 0x0b, 0x48, 0x74, 0x80, 0x12, 0x76, 0x17, 0x36, 0x64, 0xe8, 0xbf,
	0xe0, 0x32, 0x75, 0x67, 0x5c, 0x68, 0xb5, 0xb5, 0x9d, 0xc6, 0x6e, 0xc7, 0xee, 0x6b, 0x57, 0xc7,
	0x7c, 0x7a, 0x86, 0x51, 0x1a, 0x68, 0xc5, 0x63, 0x2e, 0xd4, 0xb3, 0xb7, 0xa1, 0x1e, 0x06, 0xa3,
	0x75, 0x7a, 0xaf, 0x81, 0x56, 0xd6, 0x81, 0x7b, 0xe8, 0xd4, 0xc3, 0xc0, 0xfa, 0x1e, 0xac, 0xeb,
	0x87, 0xd9, 0x16, 0xac, 0x45, 0x3c, 0x9e, 0xca, 0x53, 0x5d, 0x1f, 0x7a, 0xc7, 0xae, 0x40, 0xeb,
	0xa5, 0x17, 0xcd, 0x55, 0x7d, 0x34, 0x1d, 0xb5, 0xb1, 0x7e, 0xdd, 0x80, 0xee, 0x73, 0xba, 0xed,
	0x60, 0x1e, 0x07, 0x11, 0x67, 0x77, 0xa1, 0x2d, 0xf8, 0x99, 0x17, 0xc6, 0x01, 0x17, 0x3a, 0x07,
	0x37, 0xf5, 0x8d, 0x8b, 0x7a, 0x4e, 0xa6, 0xe3, 0x14, 0xea, 0xec, 0x1e, 0xf4, 0x95, 0xe7, 0x79,
	0x5d, 0xb4, 0xe8, 0xfd, 0xae, 0x94, 0x0c, 0xe8, 0x22, 0x70, 0x7a, 0x72, 0x71, 0xcb, 0x3e, 0x86,
	0xb6, 0x7e, 0x38, 0xda, 0xd7, 0x71, 0x19, 0x94, 0x9e, 0xfb, 0x7c, 0xdf, 0x31, 0xa5, 0x5e, 0x31,
	0x1b, 0xda, 0x13, 0x4f, 0xfa, 0xa7, 0x6e, 0x1a, 0x4e, 0x47, 0x66, 0xa9, 0xfa, 0x0e, 0x50, 0x3e,
	0x0e, 0xa7, 0xb1, 0x27, 0xe7, 0x82, 0x3b, 0xe6, 0x44, 0xef, 0xb1, 0xbe, 0xa8, 0xb5, 0xdc, 0x30,
	0x3e, 0x49, 0x46, 0x6d, 0xba, 0x22, 0xab, 0x92, 0x07, 0x78, 0x80, 0x55, 0xe8, 0xb4, 0xfd, 0x6c,
	0xc9, 0xf6, 0x60, 0x93, 0xc7, 0xbe, 0x78, 0x33, 0x93, 0x3c, 0x70, 0x33, 0xe7, 0xec, 0x11, 0x50,
	0xdb, 0x6c, 0xe4, 0x47, 0xda, 0x3d, 0x9b, 0xdd, 0x07, 0x36, 0xa1, 0xe8, 0xa0, 0x57, 0x31, 0x17,
	0xae, 0xcf, 0x85, 0x1c, 0x75, 0xc8, 0x3b, 0x96, 0x5d, 0xc4, 0x85, 0x0c, 0x4f, 0x42, 0xdf, 0x93,
	0xdc, 0x19, 0x2a, 0xed, 0x31, 0x29, 0xe3, 0x81, 0xf5, 0x9b, 0x3a, 0x5c, 0xad, 0x0c, 0x33, 0x86,
	0x87, 0x53, 0xc6, 0xdd, 0x30, 0xd0, 0x79, 0x39, 0x57, 0x09, 0xa6, 0xd2, 0x78, 0x1c, 0xa0, 0xe7,
	0x3a, 0x05, 0x6e, 0x8a, 0xbf, 0xb1, 0xcf, 0xdd, 0x38, 0xd1, 0xa9, 0xdf, 0xd0, 0x47, 0x63, 0x7d,
	0xf2, 0x34, 0x61, 0x1f, 0x41, 0x3b, 0x99, 0xfc, 0x9c, 0xfb, 0x12, 0xad, 0xab, 0x36, 0x30, 0x95,
	0xe0, 0x71, 0xc0, 0x3e, 0x85, 0xce, 0x6c, 0xfe, 0xf6, 0x6d, 0xa4, 0x03, 0xa7, 0xca, 0xf0, 0xa3,
	0xbc, 0xd7, 0xa3, 0xc4, 0xa7, 0x3e, 0x38, 0x26, 0x1d, 0x8a, 0x21, 0xcc, 0xf2, 0x35, 0xfb, 0x14,
	0x36, 0xfc, 0x28, 0x44, 0xb0, 0x58, 0x68, 0x51, 0x73, 0x45, 0x8b, 0x0e, 0x94, 0x6a, 0x2e, 0xb0,
	0x3e, 0x81, 0x76, 0x9e, 0x1a, 0x76, 0x07, 0x9a, 0x5e, 0x10, 0x64, 0x65, 0x99, 0xe5, 0xfb, 0x29,
	0x97, 0xaf, 0x12, 0xf1, 0xe2, 0x87, 0x41, 0x20, 0x78, 0x9a, 0x3a, 0xa4, 0x62, 0xfd, 0x0c, 0xfa,
	0x65, 0x39, 0xbb, 0x01, 0x66, 0x18, 0x73, 0x99, 0x1b, 0xe8, 0x3a, 0xf9, 0x9e, 0xdd, 0x84, 0x36,
	0xae, 0x3f, 0xa1, 0xc3, 0xba, 0x42, 0xc5, 0x5c, 0x80, 0x78, 0x3b, 0x4b, 0x84, 0xa4, 0xb8, 0xf4,
	0x1c, 0x5a, 0x5b, 0xbf, 0x32, 0xe0, 0x4a, 0xd5, 0xab, 0x63, 0xfb, 0x89, 0x64, 0x1e, 0x07, 0xa9,
	0x46, 0x4d, 0xbd, 0x43, 0x23, 0xd3, 0xc4, 0x8b, 0xb4, 0x75, 0x5a, 0xb3, 0x2f, 0x41, 0x57, 0x61,
	0x46, 0x72, 0x72, 0x92, 0x72, 0xa9, 0x03, 0xaf, 0x70, 0xe4, 0x19, 0x89, 0x0a, 0x58, 0x11, 0x5e,
	0x3c, 0xe5, 0x1a, 0x7c, 0x14, 0xac, 0x38, 0x28, 0xb1, 0xfe, 0x64, 0x40, 0xbf, 0x5c, 0xf1, 0xec,
	0xab, 0xd0, 0x9f, 0x79, 0xf2, 0xd4, 0x0d, 0x42, 0xc1, 0x7d, 0x74, 0x6f, 0x54, 0xdf, 0x69, 0xec,
	0x9a, 0x4e, 0x0f, 0xa5, 0x0f, 0x33, 0x21, 0x9a, 0xd6, 0x6a, 0x53, 0x6c, 0xd5, 0xc6, 0x4e, 0x63,
	0xb7, 0xeb, 0x80, 0xd2, 0x41, 0x09, 0xda, 0x11, 0x49, 0x22, 0xa9, 0x98, 0xc9, 0x32, 0x5d, 0xdf,
	0x75, 0x7a, 0x28, 0x2d, 0xae, 0xdb, 0x87, 0x0e, 0x6a, 0x84, 0xf1, 0x94, 0x52, 0xdb, 0x5a, 0x91,
	0x5a, 0xd0, 0x4a, 0x98, 0xd5, 0x9b, 0x60, 0x12, 0xb0, 0x21, 0x04, 0x0f, 0xa1, 0x51, 0xcc, 0x22,
	0x5c, 0x5a, 0x7f, 0x34, 0xa0, 0x57, 0x82, 0x0a, 0x2c, 0x4f, 0xc2, 0x4b, 0x37, 0x0c, 0x5e, 0xeb,
	0x22, 0x36, 0x49, 0xf0, 0x38, 0x78, 0x8d, 0x9d, 0x11, 0xc6, 0xd8, 0x6d, 0x68, 0xa6, 0x51, 0xea,
	0x8c, 0xec, 0x12, 0x4c, 0x75, 0xcc, 0x05, 0x5e, 0x77, 0x17, 0x86, 0x0a, 0x04, 0x16, 0xaa, 0xb1,
	0xb9, 0xc2, 0xe5, 0x3e, 0x69, 0x16, 0xd3, 0xe2, 0x3a, 0x98, 0x99, 0x1b, 0x1a, 0xe0, 0xd7, 0xb5,
	0x17, 0xd6, 0x2f, 0x0d, 0x30, 0x33, 0x98, 0x42, 0x77, 0x35, 0x5a, 0xe4, 0x3d, 0xa7, 0x91, 0xeb,
	0x69, 0x52, 0xe9, 0x40, 0xe3, 0x92, 0x0e, 0x94, 0xe2, 0xd0, 0x2c, 0xc7, 0xc1, 0xfa, 0x69, 0xee,
	0x81, 0x8d, 0x60, 0x1f, 0x27, 0xb1, 0xcf, 0x75, 0xb9, 0xa9, 0x0d, 0xbb, 0x07, 0x1b, 0x2a, 0x52,
	0x29, 0x4f, 0x71, 0x92, 0xeb, 0xbb, 0x1b, 0x55, 0x11, 0x1b, 0x90, 0xe6, 0x58, 0x29, 0x62, 0xce,
	0x8e, 0xc1, 0xcc, 0x80, 0xa6, 0xec, 0x87, 0xb1, 0x94, 0x8f, 0xaf, 0xc1, 0x40, 0x0a, 0x2f, 0x4e,
	0x3d, 0x2a, 0xb3, 0x3c, 0x65, 0x3d, 0xa7, 0xbf, 0x20, 0x46, 0x87, 0xfd, 0x6c, 0xf4, 0x7c, 0x6e,
	0x5f, 0x04, 0xb7, 0xc6, 0x2a, 0xb8, 0xfd, 0x32, 0xf4, 0x34, 0x2e, 0xa5, 0xdc, 0x17, 0x5c, 0xea,
	0x97, 0xed, 0x2a, 0xe1, 0x98, 0x64, 0xd6, 0x1f, 0x0c, 0xe8, 0x2c, 0x60, 0x2e, 0xfb, 0x3e, 0xb0,
	0x74, 0xae, 0xa0, 0xee, 0x12, 0x64, 0x63, 0xa8, 0x75, 0x8b, 0x14, 0x94, 0x70, 0xb8, 0xfe, 0x3e,
	0x1c, 0xbe, 0x02, 0xad, 0x39, 0x91, 0xb2, 0x06, 0x91, 0x32, 0xb5, 0x41, 0xb8, 0x59, 0xee, 0xa9,
	0x42, 0x60, 0xfd, 0xd3, 0x80, 0xad, 0xc5, 0x19, 0x30, 0x9e, 0x4f, 0x54, 0x8b, 0xa6, 0xcc, 0x86,
	0xab, 0xe5, 0x01, 0x9b, 0x35, 0xaf, 0x41, 0xcd, 0xbb, 0x59, 0x9a, 0xa8, 0xba, 0x8b, 0x77, 0x61,
	0x98, 0xcf, 0xd5, 0x4c, 0xbd, 0x4e, 0xea, 0xfd, 0x6c, 0x9a, 0x6a, 0xcd, 0x7b, 0x70, 0xa3, 0x22,
	0xfe, 0x05, 0x3e, 0xa0, 0x9f, 0xd7, 0xce, 0xa5, 0x41, 0x3f, 0x7c, 0x07, 0x86, 0x39, 0x11, 0xc8,
	0x1e, 0x51, 0xaf, 0x36, 0xc8, 0xe5, 0x4a, 0xd5, 0xfa, 0xab, 0x01, 0xfd, 0x32, 0x45, 0xac, 0x1e,
	0x12, 0xc6, 0x25, 0x87, 0x04, 0x01, 0xb4, 0x27, 0x4f, 0x35, 0xf3, 0xa5, 0x35, 0x01, 0xe7, 0xc2,
	0xe4, 0xcb, 0x80, 0xb3, 0x18, 0x79, 0xb7, 0xa1, 0x43, 0x98, 0xea, 0x4e, 0xf8, 0x34, 0x8c, 0x33,
	0xc2, 0x46, 0xa2, 0x03, 0x94, 0x60, 0x91, 0x2b, 0x05, 0x1e, 0x07, 0xa3, 0x35, 0x55, 0xe4, 0x24,
	0x38, 0x8c, 0x03, 0xeb, 0xb7, 0x06, 0x0c, 0xf2, 0x77, 0x48, 0x67, 0x49, 0x9c, 0xf2, 0x55, 0x43,
	0xd7, 0x58, 0x35, 0x74, 0x2d, 0x68, 0x71, 0x24, 0xf4, 0xba, 0x8c, 0xba, 0x59, 0x19, 0xa1, 0xcc,
	0x51, 0x47, 0xec, 0x1b, 0xb0, 0xa6, 0x48, 0x82, 0xc6, 0x88, 0xcd, 0x2a, 0x2e, 0xa6, 0x55, 0xac,
	0xff, 0x36, 0x80, 0x3d, 0xa0, 0xd8, 0xd0, 0xcc, 0xcc, 0x82, 0xfb, 0x08, 0x34, 0xd1, 0x70, 0xff,
	0x3f, 0x66, 0x37, 0x98, 0x2c, 0x71, 0x90, 0x9f, 0xc0, 0x48, 0x97, 0x45, 0x46, 0x73, 0xf2, 0xd2,
	0xd4, 0xef, 0x70, 0xab, 0xc2, 0x60, 0x51, 0xbf, 0xce, 0x96, 0xac, 0xae, 0xeb, 0xef, 0x00, 0x14,
	0xc4, 0x49, 0xbf, 0xe9, 0x0a, 0x3a, 0xd7, 0xce, 0x39, 0xd3, 0x0a, 0xba, 0xd5, 0xbc, 0x3c, 0xdd,
	0x62, 0x9f, 0x55, 0x10, 0x56, 0x63, 0x15, 0x61, 0x3d, 0xaa, 0x2d, 0x53, 0xd6, 0xbd, 0x32, 0x65,
	0x35, 0x2a, 0x28, 0xeb, 0x51, 0xad, 0x4c, 0x5a, 0x0b, 0x58, 0x5b, 0xaf, 0xc8, 0xa7, 0x02, 0xc2,
	0x85, 0x67, 0xec, 0xe5, 0x3a, 0x36, 0x97, 0xeb, 0xf8, 0xc0, 0x84, 0x35, 0xa5, 0x6c, 0xfd, 0xa5,
	0x0e, 0x9b, 0xa5, 0xf4, 0x7f, 0x60, 0x5d, 0x7e, 0xe5, 0x82, 0xba, 0x3c, 0xaa, 0x65, 0x95, 0x79,
	0x08, 0xbd, 0xc0, 0x93, 0x9e, 0x2b, 0xf4, 0x35, 0x3a, 0x6d, 0xdb, 0x59, 0xe0, 0xcf, 0x3b, 0xf2,
	0xd0, 0x93, 0xde, 0x51, 0xcd, 0xe9, 0xe2, 0x63, 0xb9, 0x73, 0x3f, 0x80, 0x4e, 0xb4, 0x5f, 0x18,
	0x69, 0x96, 0xea, 0xb2, 0xc2, 0x08, 0x85, 0x14, 0xa2, 0xfd, 0x92, 0x01, 0xbb, 0x30, 0xd0, 0x7a,
	0xaf, 0x01, 0x9b, 0x0c, 0xd8, 0xd9, 0x3e, 0xfb, 0x33, 0xfa, 0x4d, 0xb8, 0xb6, 0xc2, 0x67, 0xc4,
	0x17, 0xf4, 0x59, 0x4f, 0x22, 0x5a, 0x5b, 0x87, 0x70, 0xb5, 0xd2, 0x3b, 0x1c, 0x10, 0xc9, 0x5c,
	0x6a, 0x3a, 0x62, 0xac, 0xa0, 0x23, 0xa4, 0x81, 0x53, 0xf5, 0x5a, 0xb5, 0x19, 0xdb, 0x3a, 0x83,
	0x21, 0x89, 0x9e, 0x84, 0x69, 0x9a, 0xd5, 0xdb, 0x12, 0x64, 0xd5, 0x2f, 0x86, 0xac, 0x46, 0x19,
	0xb2, 0xca, 0x1c, 0xbf, 0x59, 0xe6, 0xf8, 0xd6, 0xef, 0x0d, 0xd8, 0x58, 0xb8, 0x4f, 0xc7, 0xf6,
	0x3a, 0x98, 0x69, 0x94, 0x48, 0x3d, 0xe6, 0x1b, 0x48, 0x78, 0x70, 0x8f, 0x53, 0x7e, 0x1f, 0xcc,
	0x33, 0x64, 0xcf, 0x18, 0x97, 0xf2, 0xbf, 0xff, 0x67, 0x64, 0xf3, 0x89, 0x3e, 0x74, 0x72, 0x35,
	0xf6, 0x31, 0x34, 0x4f, 0xa5, 0x9c, 0xd1, 0xff, 0xa7, 0x8e, 0xbd, 0xb5, 0x18, 0x94, 0x71, 0x32,
	0x17, 0x3e, 0x3f, 0x7a, 0xfe, 0xfc, 0xf8, 0xa8, 0xe6, 0x90, 0x16, 0xd6, 0x75, 0x4a, 0x52, 0xcb,
	0x83, 0xc1, 0x92, 0x12, 0x92, 0xc6, 0xb9, 0x88, 0x28, 0xbc, 0x6d, 0x07, 0x97, 0x5f, 0x2c, 0x36,
	0xd6, 0x9f, 0x0d, 0xe8, 0x97, 0xfd, 0x46, 0x83, 0x3a, 0x5c, 0x69, 0xf8, 0x36, 0xfb, 0xd8, 0x02,
	0x4a, 0x34, 0x0e, 0xdf, 0x72, 0x76, 0x0b, 0x40, 0x91, 0x20, 0x3a, 0x57, 0x17, 0x2a, 0x5a, 0x44,
	0xc7, 0x0c, 0x9a, 0x5c, 0x7a, 0x53, 0x3d, 0x04, 0x69, 0x8d, 0x8c, 0x25, 0xf2, 0x52, 0xe9, 0x9e,
	0x25, 0x41, 0x78, 0x12, 0x72, 0xc5, 0x22, 0xdb, 0x4e, 0x17, 0x85, 0x4f, 0xb4, 0x0c, 0x27, 0xa9,
	0x22, 0x88, 0xc5, 0x27, 0x06, 0x02, 0x97, 0xb6, 0xa3, 0xbe, 0x0c, 0x1d, 0xe6, 0x62, 0xfb, 0x19,
	0xf4, 0x55, 0xf5, 0x1c, 0xeb, 0x2f, 0x1b, 0xec, 0x33, 0x80, 0x47, 0x5c, 0xea, 0xc9, 0xc4, 0xaa,
	0x3f, 0xc8, 0xdc, 0xd8, 0x5a, 0x16, 0xab, 0x74, 0x5b, 0x35, 0xfb, 0x3f, 0xc8, 0x96, 0x8a, 0x7a,
	0x64, 0x8f, 0xc0, 0x7c, 0xc4, 0xf5, 0x07, 0x8c, 0xeb, 0x55, 0x3d, 0xa5, 0x0c, 0xbe, 0xa7, 0xe9,
	0xad, 0x1a, 0x7b, 0x02, 0xc3, 0xc3, 0xd7, 0xfe, 0x29, 0xc6, 0x3b, 0xa7, 0xc9, 0x17, 0x18, 0xbc,
	0x10, 0x00, 0x2a, 0xcd, 0xd9, 0x1f, 0x6a, 0xce, 0xb6, 0x6a, 0xf6, 0x8f, 0xa1, 0x47, 0xc2, 0x3c,
	0x8c, 0xf7, 0xf5, 0xdf, 0x4e, 0xec, 0x06, 0x76, 0x6d, 0xf1, 0x1b, 0xc1, 0x42, 0x3f, 0xde, 0x18,
	0x9d, 0x3f, 0xc8, 0x22, 0x79, 0x30, 0xfc, 0xfb, 0xbb, 0x6d, 0xe3, 0x1f, 0xef, 0xb6, 0x8d, 0x7f,
	0xbd, 0xdb, 0x36, 0x7e, 0xf7, 0xef, 0xed, 0xda, 0x64, 0x8d, 0xbe, 0xe6, 0x7d, 0xfb, 0x7f, 0x01,
	0x00, 0x00, 0xff, 0xff, 0x4a, 0x01, 0xd0, 0x9e, 0xe0, 0x13, 0x00, 0x00,
}
