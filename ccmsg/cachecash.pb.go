// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cachecash.proto

/*
	Package ccmsg is a generated protocol buffer package.

	It is generated from these files:
		cachecash.proto

	It has these top-level messages:
		Error
		PublicKey
		EscrowInfo
		Segment
		TicketBundle
		TicketBundleRemainder
		CacheInfo
		NetworkAddress
		ColocationPuzzleInfo
		BatchSignature
		BlockKey
		TicketRequest
		TicketL1
		TicketL2
		EscrowID
		TicketL2Info
		Certificate
		TicketBundleSubdigests
		ContentRequest
		ContentResponse
		ClientCacheRequest
		ClientCacheResponse
		ClientCacheResponseData
		ClientCacheResponseL1
		ClientCacheResponseL2
		CacheMissRequest
		CacheMissResponse
		BlockSourceHTTP
		ObjectMetadata
*/
package ccmsg

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Error struct {
	Code    uint64 `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *Error) Reset()                    { *m = Error{} }
func (m *Error) String() string            { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{0} }

func (m *Error) GetCode() uint64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type PublicKey struct {
	// TODO: Add an enum for key type.
	PublicKey []byte `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
}

func (m *PublicKey) Reset()                    { *m = PublicKey{} }
func (m *PublicKey) String() string            { return proto.CompactTextString(m) }
func (*PublicKey) ProtoMessage()               {}
func (*PublicKey) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{1} }

func (m *PublicKey) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

type EscrowInfo struct {
	PublicKey         *PublicKey `protobuf:"bytes,1,opt,name=public_key,json=publicKey" json:"public_key,omitempty"`
	ProviderPublicKey *PublicKey `protobuf:"bytes,2,opt,name=provider_public_key,json=providerPublicKey" json:"provider_public_key,omitempty"`
	DrawDelay         uint64     `protobuf:"varint,3,opt,name=draw_delay,json=drawDelay,proto3" json:"draw_delay,omitempty"`
	ExpirationDelay   uint64     `protobuf:"varint,4,opt,name=expiration_delay,json=expirationDelay,proto3" json:"expiration_delay,omitempty"`
	StartBlock        uint64     `protobuf:"varint,5,opt,name=start_block,json=startBlock,proto3" json:"start_block,omitempty"`
	TicketsPerBlock   []*Segment `protobuf:"bytes,6,rep,name=tickets_per_block,json=ticketsPerBlock" json:"tickets_per_block,omitempty"`
	// If we are using block/transaction-index based IDs, then this field must not be part of what is actually committed
	// to the blockchain.
	Id *EscrowID `protobuf:"bytes,7,opt,name=id" json:"id,omitempty"`
}

func (m *EscrowInfo) Reset()                    { *m = EscrowInfo{} }
func (m *EscrowInfo) String() string            { return proto.CompactTextString(m) }
func (*EscrowInfo) ProtoMessage()               {}
func (*EscrowInfo) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{2} }

func (m *EscrowInfo) GetPublicKey() *PublicKey {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *EscrowInfo) GetProviderPublicKey() *PublicKey {
	if m != nil {
		return m.ProviderPublicKey
	}
	return nil
}

func (m *EscrowInfo) GetDrawDelay() uint64 {
	if m != nil {
		return m.DrawDelay
	}
	return 0
}

func (m *EscrowInfo) GetExpirationDelay() uint64 {
	if m != nil {
		return m.ExpirationDelay
	}
	return 0
}

func (m *EscrowInfo) GetStartBlock() uint64 {
	if m != nil {
		return m.StartBlock
	}
	return 0
}

func (m *EscrowInfo) GetTicketsPerBlock() []*Segment {
	if m != nil {
		return m.TicketsPerBlock
	}
	return nil
}

func (m *EscrowInfo) GetId() *EscrowID {
	if m != nil {
		return m.Id
	}
	return nil
}

type Segment struct {
	Length uint64 `protobuf:"varint,1,opt,name=length,proto3" json:"length,omitempty"`
	Value  uint64 `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Segment) Reset()                    { *m = Segment{} }
func (m *Segment) String() string            { return proto.CompactTextString(m) }
func (*Segment) ProtoMessage()               {}
func (*Segment) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{3} }

func (m *Segment) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *Segment) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type TicketBundle struct {
	Remainder         *TicketBundleRemainder `protobuf:"bytes,1,opt,name=remainder" json:"remainder,omitempty"`
	TicketRequest     []*TicketRequest       `protobuf:"bytes,5,rep,name=ticket_request,json=ticketRequest" json:"ticket_request,omitempty"`
	TicketL1          []*TicketL1            `protobuf:"bytes,6,rep,name=ticket_l1,json=ticketL1" json:"ticket_l1,omitempty"`
	EncryptedTicketL2 []byte                 `protobuf:"bytes,10,opt,name=encrypted_ticket_l2,json=encryptedTicketL2,proto3" json:"encrypted_ticket_l2,omitempty"`
	BatchSig          *BatchSignature        `protobuf:"bytes,8,opt,name=batch_sig,json=batchSig" json:"batch_sig,omitempty"`
	BundleSignerCert  *Certificate           `protobuf:"bytes,11,opt,name=bundle_signer_cert,json=bundleSignerCert" json:"bundle_signer_cert,omitempty"`
	// This field contains connection information for the caches mentioned in the ticket requests.
	// (XXX: There's not any particularly great/specific reason why this couldn't be covered by the hash.)
	CacheInfo []*CacheInfo    `protobuf:"bytes,9,rep,name=cache_info,json=cacheInfo" json:"cache_info,omitempty"`
	Metadata  *ObjectMetadata `protobuf:"bytes,12,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *TicketBundle) Reset()                    { *m = TicketBundle{} }
func (m *TicketBundle) String() string            { return proto.CompactTextString(m) }
func (*TicketBundle) ProtoMessage()               {}
func (*TicketBundle) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{4} }

func (m *TicketBundle) GetRemainder() *TicketBundleRemainder {
	if m != nil {
		return m.Remainder
	}
	return nil
}

func (m *TicketBundle) GetTicketRequest() []*TicketRequest {
	if m != nil {
		return m.TicketRequest
	}
	return nil
}

func (m *TicketBundle) GetTicketL1() []*TicketL1 {
	if m != nil {
		return m.TicketL1
	}
	return nil
}

func (m *TicketBundle) GetEncryptedTicketL2() []byte {
	if m != nil {
		return m.EncryptedTicketL2
	}
	return nil
}

func (m *TicketBundle) GetBatchSig() *BatchSignature {
	if m != nil {
		return m.BatchSig
	}
	return nil
}

func (m *TicketBundle) GetBundleSignerCert() *Certificate {
	if m != nil {
		return m.BundleSignerCert
	}
	return nil
}

func (m *TicketBundle) GetCacheInfo() []*CacheInfo {
	if m != nil {
		return m.CacheInfo
	}
	return nil
}

func (m *TicketBundle) GetMetadata() *ObjectMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// XXX: This needs a better name.
type TicketBundleRemainder struct {
	// XXX: Is having the request-sequence number as part of the input to the keyed PRF important?
	// TODO: Remove this in favor of the field in the ContentResponse envelope.
	RequestSequenceNo uint64                `protobuf:"varint,2,opt,name=request_sequence_no,json=requestSequenceNo,proto3" json:"request_sequence_no,omitempty"`
	EscrowId          *EscrowID             `protobuf:"bytes,1,opt,name=escrow_id,json=escrowId" json:"escrow_id,omitempty"`
	ObjectId          uint64                `protobuf:"varint,3,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
	PuzzleInfo        *ColocationPuzzleInfo `protobuf:"bytes,7,opt,name=puzzle_info,json=puzzleInfo" json:"puzzle_info,omitempty"`
	ClientPublicKey   *PublicKey            `protobuf:"bytes,8,opt,name=client_public_key,json=clientPublicKey" json:"client_public_key,omitempty"`
}

func (m *TicketBundleRemainder) Reset()                    { *m = TicketBundleRemainder{} }
func (m *TicketBundleRemainder) String() string            { return proto.CompactTextString(m) }
func (*TicketBundleRemainder) ProtoMessage()               {}
func (*TicketBundleRemainder) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{5} }

func (m *TicketBundleRemainder) GetRequestSequenceNo() uint64 {
	if m != nil {
		return m.RequestSequenceNo
	}
	return 0
}

func (m *TicketBundleRemainder) GetEscrowId() *EscrowID {
	if m != nil {
		return m.EscrowId
	}
	return nil
}

func (m *TicketBundleRemainder) GetObjectId() uint64 {
	if m != nil {
		return m.ObjectId
	}
	return 0
}

func (m *TicketBundleRemainder) GetPuzzleInfo() *ColocationPuzzleInfo {
	if m != nil {
		return m.PuzzleInfo
	}
	return nil
}

func (m *TicketBundleRemainder) GetClientPublicKey() *PublicKey {
	if m != nil {
		return m.ClientPublicKey
	}
	return nil
}

type CacheInfo struct {
	Addr *NetworkAddress `protobuf:"bytes,1,opt,name=addr" json:"addr,omitempty"`
}

func (m *CacheInfo) Reset()                    { *m = CacheInfo{} }
func (m *CacheInfo) String() string            { return proto.CompactTextString(m) }
func (*CacheInfo) ProtoMessage()               {}
func (*CacheInfo) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{6} }

func (m *CacheInfo) GetAddr() *NetworkAddress {
	if m != nil {
		return m.Addr
	}
	return nil
}

// XXX: Is this a good name if this message includes a port number?
type NetworkAddress struct {
	// XXX: Or, we could represent this as an AF_* constant and a []byte addr.
	Inetaddr  []byte `protobuf:"bytes,1,opt,name=inetaddr,proto3" json:"inetaddr,omitempty"`
	Inet6Addr []byte `protobuf:"bytes,2,opt,name=inet6addr,proto3" json:"inet6addr,omitempty"`
	Port      uint32 `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *NetworkAddress) Reset()                    { *m = NetworkAddress{} }
func (m *NetworkAddress) String() string            { return proto.CompactTextString(m) }
func (*NetworkAddress) ProtoMessage()               {}
func (*NetworkAddress) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{7} }

func (m *NetworkAddress) GetInetaddr() []byte {
	if m != nil {
		return m.Inetaddr
	}
	return nil
}

func (m *NetworkAddress) GetInet6Addr() []byte {
	if m != nil {
		return m.Inet6Addr
	}
	return nil
}

func (m *NetworkAddress) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type ColocationPuzzleInfo struct {
	Goal []byte `protobuf:"bytes,2,opt,name=goal,proto3" json:"goal,omitempty"`
	// THese fields come from the `colocationpuzzle.Parameters` struct.
	Rounds      uint32 `protobuf:"varint,1,opt,name=rounds,proto3" json:"rounds,omitempty"`
	StartOffset uint64 `protobuf:"varint,3,opt,name=start_offset,json=startOffset,proto3" json:"start_offset,omitempty"`
	StartRange  uint64 `protobuf:"varint,4,opt,name=start_range,json=startRange,proto3" json:"start_range,omitempty"`
}

func (m *ColocationPuzzleInfo) Reset()                    { *m = ColocationPuzzleInfo{} }
func (m *ColocationPuzzleInfo) String() string            { return proto.CompactTextString(m) }
func (*ColocationPuzzleInfo) ProtoMessage()               {}
func (*ColocationPuzzleInfo) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{8} }

func (m *ColocationPuzzleInfo) GetGoal() []byte {
	if m != nil {
		return m.Goal
	}
	return nil
}

func (m *ColocationPuzzleInfo) GetRounds() uint32 {
	if m != nil {
		return m.Rounds
	}
	return 0
}

func (m *ColocationPuzzleInfo) GetStartOffset() uint64 {
	if m != nil {
		return m.StartOffset
	}
	return 0
}

func (m *ColocationPuzzleInfo) GetStartRange() uint64 {
	if m != nil {
		return m.StartRange
	}
	return 0
}

type BatchSignature struct {
	PathDirection []bool     `protobuf:"varint,2,rep,packed,name=path_direction,json=pathDirection" json:"path_direction,omitempty"`
	PathDigest    [][]byte   `protobuf:"bytes,3,rep,name=path_digest,json=pathDigest" json:"path_digest,omitempty"`
	RootSignature []byte     `protobuf:"bytes,4,opt,name=root_signature,json=rootSignature,proto3" json:"root_signature,omitempty"`
	SigningKey    *PublicKey `protobuf:"bytes,5,opt,name=signing_key,json=signingKey" json:"signing_key,omitempty"`
}

func (m *BatchSignature) Reset()                    { *m = BatchSignature{} }
func (m *BatchSignature) String() string            { return proto.CompactTextString(m) }
func (*BatchSignature) ProtoMessage()               {}
func (*BatchSignature) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{9} }

func (m *BatchSignature) GetPathDirection() []bool {
	if m != nil {
		return m.PathDirection
	}
	return nil
}

func (m *BatchSignature) GetPathDigest() [][]byte {
	if m != nil {
		return m.PathDigest
	}
	return nil
}

func (m *BatchSignature) GetRootSignature() []byte {
	if m != nil {
		return m.RootSignature
	}
	return nil
}

func (m *BatchSignature) GetSigningKey() *PublicKey {
	if m != nil {
		return m.SigningKey
	}
	return nil
}

type BlockKey struct {
	// TODO: Add an enum for key type.
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *BlockKey) Reset()                    { *m = BlockKey{} }
func (m *BlockKey) String() string            { return proto.CompactTextString(m) }
func (*BlockKey) ProtoMessage()               {}
func (*BlockKey) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{10} }

func (m *BlockKey) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

// This is what the client will present to the cache.  It's not individually signed, but it's covered by the batch
// signature.
type TicketRequest struct {
	BlockIdx       uint64     `protobuf:"varint,2,opt,name=block_idx,json=blockIdx,proto3" json:"block_idx,omitempty"`
	InnerKey       *BlockKey  `protobuf:"bytes,3,opt,name=inner_key,json=innerKey" json:"inner_key,omitempty"`
	BlockId        []byte     `protobuf:"bytes,5,opt,name=block_id,json=blockId,proto3" json:"block_id,omitempty"`
	CachePublicKey *PublicKey `protobuf:"bytes,4,opt,name=cache_public_key,json=cachePublicKey" json:"cache_public_key,omitempty"`
}

func (m *TicketRequest) Reset()                    { *m = TicketRequest{} }
func (m *TicketRequest) String() string            { return proto.CompactTextString(m) }
func (*TicketRequest) ProtoMessage()               {}
func (*TicketRequest) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{11} }

func (m *TicketRequest) GetBlockIdx() uint64 {
	if m != nil {
		return m.BlockIdx
	}
	return 0
}

func (m *TicketRequest) GetInnerKey() *BlockKey {
	if m != nil {
		return m.InnerKey
	}
	return nil
}

func (m *TicketRequest) GetBlockId() []byte {
	if m != nil {
		return m.BlockId
	}
	return nil
}

func (m *TicketRequest) GetCachePublicKey() *PublicKey {
	if m != nil {
		return m.CachePublicKey
	}
	return nil
}

// XXX: I suspect that the ticket number may be the only thing here's that's actually important, since it could be used
// in proofs of double-spending (on the CP's behalf).
type TicketL1 struct {
	// PublicKey escrow_public_key = 1;
	TicketNo uint64 `protobuf:"varint,2,opt,name=ticket_no,json=ticketNo,proto3" json:"ticket_no,omitempty"`
	// XXX: This is *also* duplicated between TicketL1 and TicketRequest.
	CachePublicKey *PublicKey `protobuf:"bytes,3,opt,name=cache_public_key,json=cachePublicKey" json:"cache_public_key,omitempty"`
	// XXX: This is duplicated between this message and the TicketRequest, which could probably be avoided.  However,
	// the cache does need to be able to work out which block-index the L1 ticket corresponds to so that it can derive
	// the right outer key to give to the client.
	BlockIdx uint64 `protobuf:"varint,4,opt,name=block_idx,json=blockIdx,proto3" json:"block_idx,omitempty"`
}

func (m *TicketL1) Reset()                    { *m = TicketL1{} }
func (m *TicketL1) String() string            { return proto.CompactTextString(m) }
func (*TicketL1) ProtoMessage()               {}
func (*TicketL1) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{12} }

func (m *TicketL1) GetTicketNo() uint64 {
	if m != nil {
		return m.TicketNo
	}
	return 0
}

func (m *TicketL1) GetCachePublicKey() *PublicKey {
	if m != nil {
		return m.CachePublicKey
	}
	return nil
}

func (m *TicketL1) GetBlockIdx() uint64 {
	if m != nil {
		return m.BlockIdx
	}
	return 0
}

// By the time the L2 ticket is decrypted by the client, all of the caches must have provided data and outer encryption
// keys to the client; these are the inputs to the colocation puzzle, whose output is used to decrypt the L2 ticket.
type TicketL2 struct {
	// XXX: It seems like it might not be too hard for a cache to guess the plaintext L2 ticket that corresponds to the
	// hash that it knows.  This would be harder if we didn't tell each cache the toher caches' public keys *and*
	// included all of those keys in the hashed ticket L2.  However, it still seems as though the group of hashes trying
	// to claim the ticket could find each other when they all show up to try to claim their win.
	Nonce []byte `protobuf:"bytes,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// The inner session keys are here in order to force the client to solve the colocation puzzle (which is required in
	// order to decrypt the L2 ticket).
	InnerSessionKey []*BlockKey `protobuf:"bytes,3,rep,name=inner_session_key,json=innerSessionKey" json:"inner_session_key,omitempty"`
}

func (m *TicketL2) Reset()                    { *m = TicketL2{} }
func (m *TicketL2) String() string            { return proto.CompactTextString(m) }
func (*TicketL2) ProtoMessage()               {}
func (*TicketL2) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{13} }

func (m *TicketL2) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *TicketL2) GetInnerSessionKey() []*BlockKey {
	if m != nil {
		return m.InnerSessionKey
	}
	return nil
}

// Globally-unique identifier for an escrow, based on the position of the transaction that started the escrow.
type EscrowID struct {
	BlockIdx       uint64 `protobuf:"varint,1,opt,name=block_idx,json=blockIdx,proto3" json:"block_idx,omitempty"`
	TransactionIdx uint32 `protobuf:"varint,2,opt,name=transaction_idx,json=transactionIdx,proto3" json:"transaction_idx,omitempty"`
}

func (m *EscrowID) Reset()                    { *m = EscrowID{} }
func (m *EscrowID) String() string            { return proto.CompactTextString(m) }
func (*EscrowID) ProtoMessage()               {}
func (*EscrowID) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{14} }

func (m *EscrowID) GetBlockIdx() uint64 {
	if m != nil {
		return m.BlockIdx
	}
	return 0
}

func (m *EscrowID) GetTransactionIdx() uint32 {
	if m != nil {
		return m.TransactionIdx
	}
	return 0
}

type TicketL2Info struct {
	EncryptedTicketL2 []byte `protobuf:"bytes,1,opt,name=encrypted_ticket_l2,json=encryptedTicketL2,proto3" json:"encrypted_ticket_l2,omitempty"`
	PuzzleSecret      []byte `protobuf:"bytes,2,opt,name=puzzle_secret,json=puzzleSecret,proto3" json:"puzzle_secret,omitempty"`
}

func (m *TicketL2Info) Reset()                    { *m = TicketL2Info{} }
func (m *TicketL2Info) String() string            { return proto.CompactTextString(m) }
func (*TicketL2Info) ProtoMessage()               {}
func (*TicketL2Info) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{15} }

func (m *TicketL2Info) GetEncryptedTicketL2() []byte {
	if m != nil {
		return m.EncryptedTicketL2
	}
	return nil
}

func (m *TicketL2Info) GetPuzzleSecret() []byte {
	if m != nil {
		return m.PuzzleSecret
	}
	return nil
}

// Signed by escrow key; ensures that the key that produced the batch signature is authorized.
type Certificate struct {
	SubjectPublicKey *PublicKey `protobuf:"bytes,1,opt,name=subject_public_key,json=subjectPublicKey" json:"subject_public_key,omitempty"`
	EscrowId         *EscrowID  `protobuf:"bytes,2,opt,name=escrow_id,json=escrowId" json:"escrow_id,omitempty"`
	Usage            string     `protobuf:"bytes,3,opt,name=usage,proto3" json:"usage,omitempty"`
	Signature        []byte     `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *Certificate) Reset()                    { *m = Certificate{} }
func (m *Certificate) String() string            { return proto.CompactTextString(m) }
func (*Certificate) ProtoMessage()               {}
func (*Certificate) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{16} }

func (m *Certificate) GetSubjectPublicKey() *PublicKey {
	if m != nil {
		return m.SubjectPublicKey
	}
	return nil
}

func (m *Certificate) GetEscrowId() *EscrowID {
	if m != nil {
		return m.EscrowId
	}
	return nil
}

func (m *Certificate) GetUsage() string {
	if m != nil {
		return m.Usage
	}
	return ""
}

func (m *Certificate) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// Containss enough data to let a cache recompute/verify the ticket-bundle digest.
type TicketBundleSubdigests struct {
	TicketRequestDigest     [][]byte `protobuf:"bytes,1,rep,name=ticket_request_digest,json=ticketRequestDigest" json:"ticket_request_digest,omitempty"`
	TicketL1Digest          [][]byte `protobuf:"bytes,2,rep,name=ticket_l1_digest,json=ticketL1Digest" json:"ticket_l1_digest,omitempty"`
	EncryptedTicketL2Digest []byte   `protobuf:"bytes,3,opt,name=encrypted_ticket_l2_digest,json=encryptedTicketL2Digest,proto3" json:"encrypted_ticket_l2_digest,omitempty"`
	RemainderDigest         []byte   `protobuf:"bytes,4,opt,name=remainder_digest,json=remainderDigest,proto3" json:"remainder_digest,omitempty"`
}

func (m *TicketBundleSubdigests) Reset()                    { *m = TicketBundleSubdigests{} }
func (m *TicketBundleSubdigests) String() string            { return proto.CompactTextString(m) }
func (*TicketBundleSubdigests) ProtoMessage()               {}
func (*TicketBundleSubdigests) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{17} }

func (m *TicketBundleSubdigests) GetTicketRequestDigest() [][]byte {
	if m != nil {
		return m.TicketRequestDigest
	}
	return nil
}

func (m *TicketBundleSubdigests) GetTicketL1Digest() [][]byte {
	if m != nil {
		return m.TicketL1Digest
	}
	return nil
}

func (m *TicketBundleSubdigests) GetEncryptedTicketL2Digest() []byte {
	if m != nil {
		return m.EncryptedTicketL2Digest
	}
	return nil
}

func (m *TicketBundleSubdigests) GetRemainderDigest() []byte {
	if m != nil {
		return m.RemainderDigest
	}
	return nil
}

// Client-to-provider
type ContentRequest struct {
	// TODO: This does not actually need to be repeated with each request, if we are using a connection-oriented
	// transport.
	ClientPublicKey *PublicKey `protobuf:"bytes,1,opt,name=client_public_key,json=clientPublicKey" json:"client_public_key,omitempty"`
	Path            string     `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// In bytes; the provider can map that to blocks however it pleases.  range_begin is inclusive and range_end is
	// exclusive.  A value of zero for range_end means "the end of the object".
	RangeBegin uint64 `protobuf:"varint,5,opt,name=range_begin,json=rangeBegin,proto3" json:"range_begin,omitempty"`
	RangeEnd   uint64 `protobuf:"varint,6,opt,name=range_end,json=rangeEnd,proto3" json:"range_end,omitempty"`
	SequenceNo uint64 `protobuf:"varint,4,opt,name=sequence_no,json=sequenceNo,proto3" json:"sequence_no,omitempty"`
}

func (m *ContentRequest) Reset()                    { *m = ContentRequest{} }
func (m *ContentRequest) String() string            { return proto.CompactTextString(m) }
func (*ContentRequest) ProtoMessage()               {}
func (*ContentRequest) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{18} }

func (m *ContentRequest) GetClientPublicKey() *PublicKey {
	if m != nil {
		return m.ClientPublicKey
	}
	return nil
}

func (m *ContentRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *ContentRequest) GetRangeBegin() uint64 {
	if m != nil {
		return m.RangeBegin
	}
	return 0
}

func (m *ContentRequest) GetRangeEnd() uint64 {
	if m != nil {
		return m.RangeEnd
	}
	return 0
}

func (m *ContentRequest) GetSequenceNo() uint64 {
	if m != nil {
		return m.SequenceNo
	}
	return 0
}

// Response to a ContentRequest.
type ContentResponse struct {
	// Identifies the request that this message is a response to.
	RequestSequenceNo uint64 `protobuf:"varint,1,opt,name=request_sequence_no,json=requestSequenceNo,proto3" json:"request_sequence_no,omitempty"`
	// Exactly one of these fields may be present.
	Error  *Error        `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	Bundle *TicketBundle `protobuf:"bytes,3,opt,name=bundle" json:"bundle,omitempty"`
}

func (m *ContentResponse) Reset()                    { *m = ContentResponse{} }
func (m *ContentResponse) String() string            { return proto.CompactTextString(m) }
func (*ContentResponse) ProtoMessage()               {}
func (*ContentResponse) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{19} }

func (m *ContentResponse) GetRequestSequenceNo() uint64 {
	if m != nil {
		return m.RequestSequenceNo
	}
	return 0
}

func (m *ContentResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ContentResponse) GetBundle() *TicketBundle {
	if m != nil {
		return m.Bundle
	}
	return nil
}

type ClientCacheRequest struct {
	SequenceNo      uint64                 `protobuf:"varint,8,opt,name=sequence_no,json=sequenceNo,proto3" json:"sequence_no,omitempty"`
	BundleRemainder *TicketBundleRemainder `protobuf:"bytes,1,opt,name=bundle_remainder,json=bundleRemainder" json:"bundle_remainder,omitempty"`
	// Types that are valid to be assigned to Ticket:
	//	*ClientCacheRequest_TicketRequest
	//	*ClientCacheRequest_TicketL1
	//	*ClientCacheRequest_TicketL2
	Ticket isClientCacheRequest_Ticket `protobuf_oneof:"ticket"`
	// Together, these fields allow the cache to verify that the request is authorized.
	TicketBundleSubdigests *TicketBundleSubdigests `protobuf:"bytes,2,opt,name=ticket_bundle_subdigests,json=ticketBundleSubdigests" json:"ticket_bundle_subdigests,omitempty"`
	BundleSig              *BatchSignature         `protobuf:"bytes,3,opt,name=bundle_sig,json=bundleSig" json:"bundle_sig,omitempty"`
	BundleSignerCert       *Certificate            `protobuf:"bytes,4,opt,name=bundle_signer_cert,json=bundleSignerCert" json:"bundle_signer_cert,omitempty"`
}

func (m *ClientCacheRequest) Reset()                    { *m = ClientCacheRequest{} }
func (m *ClientCacheRequest) String() string            { return proto.CompactTextString(m) }
func (*ClientCacheRequest) ProtoMessage()               {}
func (*ClientCacheRequest) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{20} }

type isClientCacheRequest_Ticket interface {
	isClientCacheRequest_Ticket()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClientCacheRequest_TicketRequest struct {
	TicketRequest *TicketRequest `protobuf:"bytes,5,opt,name=ticket_request,json=ticketRequest,oneof"`
}
type ClientCacheRequest_TicketL1 struct {
	TicketL1 *TicketL1 `protobuf:"bytes,6,opt,name=ticket_l1,json=ticketL1,oneof"`
}
type ClientCacheRequest_TicketL2 struct {
	TicketL2 *TicketL2Info `protobuf:"bytes,7,opt,name=ticket_l2,json=ticketL2,oneof"`
}

func (*ClientCacheRequest_TicketRequest) isClientCacheRequest_Ticket() {}
func (*ClientCacheRequest_TicketL1) isClientCacheRequest_Ticket()      {}
func (*ClientCacheRequest_TicketL2) isClientCacheRequest_Ticket()      {}

func (m *ClientCacheRequest) GetTicket() isClientCacheRequest_Ticket {
	if m != nil {
		return m.Ticket
	}
	return nil
}

func (m *ClientCacheRequest) GetSequenceNo() uint64 {
	if m != nil {
		return m.SequenceNo
	}
	return 0
}

func (m *ClientCacheRequest) GetBundleRemainder() *TicketBundleRemainder {
	if m != nil {
		return m.BundleRemainder
	}
	return nil
}

func (m *ClientCacheRequest) GetTicketRequest() *TicketRequest {
	if x, ok := m.GetTicket().(*ClientCacheRequest_TicketRequest); ok {
		return x.TicketRequest
	}
	return nil
}

func (m *ClientCacheRequest) GetTicketL1() *TicketL1 {
	if x, ok := m.GetTicket().(*ClientCacheRequest_TicketL1); ok {
		return x.TicketL1
	}
	return nil
}

func (m *ClientCacheRequest) GetTicketL2() *TicketL2Info {
	if x, ok := m.GetTicket().(*ClientCacheRequest_TicketL2); ok {
		return x.TicketL2
	}
	return nil
}

func (m *ClientCacheRequest) GetTicketBundleSubdigests() *TicketBundleSubdigests {
	if m != nil {
		return m.TicketBundleSubdigests
	}
	return nil
}

func (m *ClientCacheRequest) GetBundleSig() *BatchSignature {
	if m != nil {
		return m.BundleSig
	}
	return nil
}

func (m *ClientCacheRequest) GetBundleSignerCert() *Certificate {
	if m != nil {
		return m.BundleSignerCert
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ClientCacheRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ClientCacheRequest_OneofMarshaler, _ClientCacheRequest_OneofUnmarshaler, _ClientCacheRequest_OneofSizer, []interface{}{
		(*ClientCacheRequest_TicketRequest)(nil),
		(*ClientCacheRequest_TicketL1)(nil),
		(*ClientCacheRequest_TicketL2)(nil),
	}
}

func _ClientCacheRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ClientCacheRequest)
	// ticket
	switch x := m.Ticket.(type) {
	case *ClientCacheRequest_TicketRequest:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TicketRequest); err != nil {
			return err
		}
	case *ClientCacheRequest_TicketL1:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TicketL1); err != nil {
			return err
		}
	case *ClientCacheRequest_TicketL2:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TicketL2); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ClientCacheRequest.Ticket has unexpected type %T", x)
	}
	return nil
}

func _ClientCacheRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ClientCacheRequest)
	switch tag {
	case 5: // ticket.ticket_request
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TicketRequest)
		err := b.DecodeMessage(msg)
		m.Ticket = &ClientCacheRequest_TicketRequest{msg}
		return true, err
	case 6: // ticket.ticket_l1
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TicketL1)
		err := b.DecodeMessage(msg)
		m.Ticket = &ClientCacheRequest_TicketL1{msg}
		return true, err
	case 7: // ticket.ticket_l2
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TicketL2Info)
		err := b.DecodeMessage(msg)
		m.Ticket = &ClientCacheRequest_TicketL2{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ClientCacheRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ClientCacheRequest)
	// ticket
	switch x := m.Ticket.(type) {
	case *ClientCacheRequest_TicketRequest:
		s := proto.Size(x.TicketRequest)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientCacheRequest_TicketL1:
		s := proto.Size(x.TicketL1)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientCacheRequest_TicketL2:
		s := proto.Size(x.TicketL2)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// XXX: Remove me!  This is not used over the wire; it's used only in the `cache` package.
type ClientCacheResponse struct {
	// Identifies the request that this message is a response to.
	RequestSequenceNo uint64 `protobuf:"varint,1,opt,name=request_sequence_no,json=requestSequenceNo,proto3" json:"request_sequence_no,omitempty"`
	// Types that are valid to be assigned to Msg:
	//	*ClientCacheResponse_Error
	//	*ClientCacheResponse_DataResponse
	//	*ClientCacheResponse_L1Response
	//	*ClientCacheResponse_L2Response
	Msg isClientCacheResponse_Msg `protobuf_oneof:"msg"`
}

func (m *ClientCacheResponse) Reset()                    { *m = ClientCacheResponse{} }
func (m *ClientCacheResponse) String() string            { return proto.CompactTextString(m) }
func (*ClientCacheResponse) ProtoMessage()               {}
func (*ClientCacheResponse) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{21} }

type isClientCacheResponse_Msg interface {
	isClientCacheResponse_Msg()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClientCacheResponse_Error struct {
	Error *Error `protobuf:"bytes,2,opt,name=error,oneof"`
}
type ClientCacheResponse_DataResponse struct {
	DataResponse *ClientCacheResponseData `protobuf:"bytes,3,opt,name=data_response,json=dataResponse,oneof"`
}
type ClientCacheResponse_L1Response struct {
	L1Response *ClientCacheResponseL1 `protobuf:"bytes,4,opt,name=l1_response,json=l1Response,oneof"`
}
type ClientCacheResponse_L2Response struct {
	L2Response *ClientCacheResponseL2 `protobuf:"bytes,5,opt,name=l2_response,json=l2Response,oneof"`
}

func (*ClientCacheResponse_Error) isClientCacheResponse_Msg()        {}
func (*ClientCacheResponse_DataResponse) isClientCacheResponse_Msg() {}
func (*ClientCacheResponse_L1Response) isClientCacheResponse_Msg()   {}
func (*ClientCacheResponse_L2Response) isClientCacheResponse_Msg()   {}

func (m *ClientCacheResponse) GetMsg() isClientCacheResponse_Msg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *ClientCacheResponse) GetRequestSequenceNo() uint64 {
	if m != nil {
		return m.RequestSequenceNo
	}
	return 0
}

func (m *ClientCacheResponse) GetError() *Error {
	if x, ok := m.GetMsg().(*ClientCacheResponse_Error); ok {
		return x.Error
	}
	return nil
}

func (m *ClientCacheResponse) GetDataResponse() *ClientCacheResponseData {
	if x, ok := m.GetMsg().(*ClientCacheResponse_DataResponse); ok {
		return x.DataResponse
	}
	return nil
}

func (m *ClientCacheResponse) GetL1Response() *ClientCacheResponseL1 {
	if x, ok := m.GetMsg().(*ClientCacheResponse_L1Response); ok {
		return x.L1Response
	}
	return nil
}

func (m *ClientCacheResponse) GetL2Response() *ClientCacheResponseL2 {
	if x, ok := m.GetMsg().(*ClientCacheResponse_L2Response); ok {
		return x.L2Response
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ClientCacheResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ClientCacheResponse_OneofMarshaler, _ClientCacheResponse_OneofUnmarshaler, _ClientCacheResponse_OneofSizer, []interface{}{
		(*ClientCacheResponse_Error)(nil),
		(*ClientCacheResponse_DataResponse)(nil),
		(*ClientCacheResponse_L1Response)(nil),
		(*ClientCacheResponse_L2Response)(nil),
	}
}

func _ClientCacheResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ClientCacheResponse)
	// msg
	switch x := m.Msg.(type) {
	case *ClientCacheResponse_Error:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case *ClientCacheResponse_DataResponse:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DataResponse); err != nil {
			return err
		}
	case *ClientCacheResponse_L1Response:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L1Response); err != nil {
			return err
		}
	case *ClientCacheResponse_L2Response:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L2Response); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ClientCacheResponse.Msg has unexpected type %T", x)
	}
	return nil
}

func _ClientCacheResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ClientCacheResponse)
	switch tag {
	case 2: // msg.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Msg = &ClientCacheResponse_Error{msg}
		return true, err
	case 3: // msg.data_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientCacheResponseData)
		err := b.DecodeMessage(msg)
		m.Msg = &ClientCacheResponse_DataResponse{msg}
		return true, err
	case 4: // msg.l1_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientCacheResponseL1)
		err := b.DecodeMessage(msg)
		m.Msg = &ClientCacheResponse_L1Response{msg}
		return true, err
	case 5: // msg.l2_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientCacheResponseL2)
		err := b.DecodeMessage(msg)
		m.Msg = &ClientCacheResponse_L2Response{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ClientCacheResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ClientCacheResponse)
	// msg
	switch x := m.Msg.(type) {
	case *ClientCacheResponse_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientCacheResponse_DataResponse:
		s := proto.Size(x.DataResponse)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientCacheResponse_L1Response:
		s := proto.Size(x.L1Response)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientCacheResponse_L2Response:
		s := proto.Size(x.L2Response)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ClientCacheResponseData struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *ClientCacheResponseData) Reset()         { *m = ClientCacheResponseData{} }
func (m *ClientCacheResponseData) String() string { return proto.CompactTextString(m) }
func (*ClientCacheResponseData) ProtoMessage()    {}
func (*ClientCacheResponseData) Descriptor() ([]byte, []int) {
	return fileDescriptorCachecash, []int{22}
}

func (m *ClientCacheResponseData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type ClientCacheResponseL1 struct {
	// contains the outer key
	OuterKey *BlockKey `protobuf:"bytes,1,opt,name=outer_key,json=outerKey" json:"outer_key,omitempty"`
}

func (m *ClientCacheResponseL1) Reset()                    { *m = ClientCacheResponseL1{} }
func (m *ClientCacheResponseL1) String() string            { return proto.CompactTextString(m) }
func (*ClientCacheResponseL1) ProtoMessage()               {}
func (*ClientCacheResponseL1) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{23} }

func (m *ClientCacheResponseL1) GetOuterKey() *BlockKey {
	if m != nil {
		return m.OuterKey
	}
	return nil
}

type ClientCacheResponseL2 struct {
}

func (m *ClientCacheResponseL2) Reset()                    { *m = ClientCacheResponseL2{} }
func (m *ClientCacheResponseL2) String() string            { return proto.CompactTextString(m) }
func (*ClientCacheResponseL2) ProtoMessage()               {}
func (*ClientCacheResponseL2) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{24} }

// XXX: See similarities to ContentRequest.
type CacheMissRequest struct {
	// In blocks.
	// XXX: This was formerly in bytes.  Was there a good reason for that?
	RangeBegin uint64 `protobuf:"varint,2,opt,name=range_begin,json=rangeBegin,proto3" json:"range_begin,omitempty"`
	RangeEnd   uint64 `protobuf:"varint,3,opt,name=range_end,json=rangeEnd,proto3" json:"range_end,omitempty"`
	ObjectId   uint64 `protobuf:"varint,4,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
}

func (m *CacheMissRequest) Reset()                    { *m = CacheMissRequest{} }
func (m *CacheMissRequest) String() string            { return proto.CompactTextString(m) }
func (*CacheMissRequest) ProtoMessage()               {}
func (*CacheMissRequest) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{25} }

func (m *CacheMissRequest) GetRangeBegin() uint64 {
	if m != nil {
		return m.RangeBegin
	}
	return 0
}

func (m *CacheMissRequest) GetRangeEnd() uint64 {
	if m != nil {
		return m.RangeEnd
	}
	return 0
}

func (m *CacheMissRequest) GetObjectId() uint64 {
	if m != nil {
		return m.ObjectId
	}
	return 0
}

type CacheMissResponse struct {
	SlotIdx  []uint64        `protobuf:"varint,1,rep,packed,name=slot_idx,json=slotIdx" json:"slot_idx,omitempty"`
	BlockId  [][]byte        `protobuf:"bytes,3,rep,name=block_id,json=blockId" json:"block_id,omitempty"`
	Metadata *ObjectMetadata `protobuf:"bytes,2,opt,name=metadata" json:"metadata,omitempty"`
	// Types that are valid to be assigned to Source:
	//	*CacheMissResponse_Http
	Source isCacheMissResponse_Source `protobuf_oneof:"source"`
}

func (m *CacheMissResponse) Reset()                    { *m = CacheMissResponse{} }
func (m *CacheMissResponse) String() string            { return proto.CompactTextString(m) }
func (*CacheMissResponse) ProtoMessage()               {}
func (*CacheMissResponse) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{26} }

type isCacheMissResponse_Source interface {
	isCacheMissResponse_Source()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CacheMissResponse_Http struct {
	Http *BlockSourceHTTP `protobuf:"bytes,10,opt,name=http,oneof"`
}

func (*CacheMissResponse_Http) isCacheMissResponse_Source() {}

func (m *CacheMissResponse) GetSource() isCacheMissResponse_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *CacheMissResponse) GetSlotIdx() []uint64 {
	if m != nil {
		return m.SlotIdx
	}
	return nil
}

func (m *CacheMissResponse) GetBlockId() [][]byte {
	if m != nil {
		return m.BlockId
	}
	return nil
}

func (m *CacheMissResponse) GetMetadata() *ObjectMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CacheMissResponse) GetHttp() *BlockSourceHTTP {
	if x, ok := m.GetSource().(*CacheMissResponse_Http); ok {
		return x.Http
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CacheMissResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CacheMissResponse_OneofMarshaler, _CacheMissResponse_OneofUnmarshaler, _CacheMissResponse_OneofSizer, []interface{}{
		(*CacheMissResponse_Http)(nil),
	}
}

func _CacheMissResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CacheMissResponse)
	// source
	switch x := m.Source.(type) {
	case *CacheMissResponse_Http:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Http); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CacheMissResponse.Source has unexpected type %T", x)
	}
	return nil
}

func _CacheMissResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CacheMissResponse)
	switch tag {
	case 10: // source.http
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BlockSourceHTTP)
		err := b.DecodeMessage(msg)
		m.Source = &CacheMissResponse_Http{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CacheMissResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CacheMissResponse)
	// source
	switch x := m.Source.(type) {
	case *CacheMissResponse_Http:
		s := proto.Size(x.Http)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type BlockSourceHTTP struct {
	Url        string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	RangeBegin uint64 `protobuf:"varint,2,opt,name=range_begin,json=rangeBegin,proto3" json:"range_begin,omitempty"`
	RangeEnd   uint64 `protobuf:"varint,3,opt,name=range_end,json=rangeEnd,proto3" json:"range_end,omitempty"`
}

func (m *BlockSourceHTTP) Reset()                    { *m = BlockSourceHTTP{} }
func (m *BlockSourceHTTP) String() string            { return proto.CompactTextString(m) }
func (*BlockSourceHTTP) ProtoMessage()               {}
func (*BlockSourceHTTP) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{27} }

func (m *BlockSourceHTTP) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *BlockSourceHTTP) GetRangeBegin() uint64 {
	if m != nil {
		return m.RangeBegin
	}
	return 0
}

func (m *BlockSourceHTTP) GetRangeEnd() uint64 {
	if m != nil {
		return m.RangeEnd
	}
	return 0
}

type ObjectMetadata struct {
	ObjectSize uint64 `protobuf:"varint,1,opt,name=object_size,json=objectSize,proto3" json:"object_size,omitempty"`
	BlockSize  uint64 `protobuf:"varint,2,opt,name=block_size,json=blockSize,proto3" json:"block_size,omitempty"`
	// Passed through by publisher from HTTP upstream.
	Etag         []byte `protobuf:"bytes,4,opt,name=etag,proto3" json:"etag,omitempty"`
	LastModified string `protobuf:"bytes,5,opt,name=last_modified,json=lastModified,proto3" json:"last_modified,omitempty"`
	// Decided by publisher based on HTTP headers.
	CacheExpiration string `protobuf:"bytes,6,opt,name=cache_expiration,json=cacheExpiration,proto3" json:"cache_expiration,omitempty"`
}

func (m *ObjectMetadata) Reset()                    { *m = ObjectMetadata{} }
func (m *ObjectMetadata) String() string            { return proto.CompactTextString(m) }
func (*ObjectMetadata) ProtoMessage()               {}
func (*ObjectMetadata) Descriptor() ([]byte, []int) { return fileDescriptorCachecash, []int{28} }

func (m *ObjectMetadata) GetObjectSize() uint64 {
	if m != nil {
		return m.ObjectSize
	}
	return 0
}

func (m *ObjectMetadata) GetBlockSize() uint64 {
	if m != nil {
		return m.BlockSize
	}
	return 0
}

func (m *ObjectMetadata) GetEtag() []byte {
	if m != nil {
		return m.Etag
	}
	return nil
}

func (m *ObjectMetadata) GetLastModified() string {
	if m != nil {
		return m.LastModified
	}
	return ""
}

func (m *ObjectMetadata) GetCacheExpiration() string {
	if m != nil {
		return m.CacheExpiration
	}
	return ""
}

func init() {
	proto.RegisterType((*Error)(nil), "ccmsg.Error")
	proto.RegisterType((*PublicKey)(nil), "ccmsg.PublicKey")
	proto.RegisterType((*EscrowInfo)(nil), "ccmsg.EscrowInfo")
	proto.RegisterType((*Segment)(nil), "ccmsg.Segment")
	proto.RegisterType((*TicketBundle)(nil), "ccmsg.TicketBundle")
	proto.RegisterType((*TicketBundleRemainder)(nil), "ccmsg.TicketBundleRemainder")
	proto.RegisterType((*CacheInfo)(nil), "ccmsg.CacheInfo")
	proto.RegisterType((*NetworkAddress)(nil), "ccmsg.NetworkAddress")
	proto.RegisterType((*ColocationPuzzleInfo)(nil), "ccmsg.ColocationPuzzleInfo")
	proto.RegisterType((*BatchSignature)(nil), "ccmsg.BatchSignature")
	proto.RegisterType((*BlockKey)(nil), "ccmsg.BlockKey")
	proto.RegisterType((*TicketRequest)(nil), "ccmsg.TicketRequest")
	proto.RegisterType((*TicketL1)(nil), "ccmsg.TicketL1")
	proto.RegisterType((*TicketL2)(nil), "ccmsg.TicketL2")
	proto.RegisterType((*EscrowID)(nil), "ccmsg.EscrowID")
	proto.RegisterType((*TicketL2Info)(nil), "ccmsg.TicketL2Info")
	proto.RegisterType((*Certificate)(nil), "ccmsg.Certificate")
	proto.RegisterType((*TicketBundleSubdigests)(nil), "ccmsg.TicketBundleSubdigests")
	proto.RegisterType((*ContentRequest)(nil), "ccmsg.ContentRequest")
	proto.RegisterType((*ContentResponse)(nil), "ccmsg.ContentResponse")
	proto.RegisterType((*ClientCacheRequest)(nil), "ccmsg.ClientCacheRequest")
	proto.RegisterType((*ClientCacheResponse)(nil), "ccmsg.ClientCacheResponse")
	proto.RegisterType((*ClientCacheResponseData)(nil), "ccmsg.ClientCacheResponseData")
	proto.RegisterType((*ClientCacheResponseL1)(nil), "ccmsg.ClientCacheResponseL1")
	proto.RegisterType((*ClientCacheResponseL2)(nil), "ccmsg.ClientCacheResponseL2")
	proto.RegisterType((*CacheMissRequest)(nil), "ccmsg.CacheMissRequest")
	proto.RegisterType((*CacheMissResponse)(nil), "ccmsg.CacheMissResponse")
	proto.RegisterType((*BlockSourceHTTP)(nil), "ccmsg.BlockSourceHTTP")
	proto.RegisterType((*ObjectMetadata)(nil), "ccmsg.ObjectMetadata")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ClientProvider service

type ClientProviderClient interface {
	GetContent(ctx context.Context, in *ContentRequest, opts ...grpc.CallOption) (*ContentResponse, error)
}

type clientProviderClient struct {
	cc *grpc.ClientConn
}

func NewClientProviderClient(cc *grpc.ClientConn) ClientProviderClient {
	return &clientProviderClient{cc}
}

func (c *clientProviderClient) GetContent(ctx context.Context, in *ContentRequest, opts ...grpc.CallOption) (*ContentResponse, error) {
	out := new(ContentResponse)
	err := grpc.Invoke(ctx, "/ccmsg.ClientProvider/GetContent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ClientProvider service

type ClientProviderServer interface {
	GetContent(context.Context, *ContentRequest) (*ContentResponse, error)
}

func RegisterClientProviderServer(s *grpc.Server, srv ClientProviderServer) {
	s.RegisterService(&_ClientProvider_serviceDesc, srv)
}

func _ClientProvider_GetContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientProviderServer).GetContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmsg.ClientProvider/GetContent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientProviderServer).GetContent(ctx, req.(*ContentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ClientProvider_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ccmsg.ClientProvider",
	HandlerType: (*ClientProviderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetContent",
			Handler:    _ClientProvider_GetContent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cachecash.proto",
}

// Client API for ClientCache service

type ClientCacheClient interface {
	GetBlock(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseData, error)
	ExchangeTicketL1(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseL1, error)
	ExchangeTicketL2(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseL2, error)
}

type clientCacheClient struct {
	cc *grpc.ClientConn
}

func NewClientCacheClient(cc *grpc.ClientConn) ClientCacheClient {
	return &clientCacheClient{cc}
}

func (c *clientCacheClient) GetBlock(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseData, error) {
	out := new(ClientCacheResponseData)
	err := grpc.Invoke(ctx, "/ccmsg.ClientCache/GetBlock", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientCacheClient) ExchangeTicketL1(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseL1, error) {
	out := new(ClientCacheResponseL1)
	err := grpc.Invoke(ctx, "/ccmsg.ClientCache/ExchangeTicketL1", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientCacheClient) ExchangeTicketL2(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseL2, error) {
	out := new(ClientCacheResponseL2)
	err := grpc.Invoke(ctx, "/ccmsg.ClientCache/ExchangeTicketL2", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ClientCache service

type ClientCacheServer interface {
	GetBlock(context.Context, *ClientCacheRequest) (*ClientCacheResponseData, error)
	ExchangeTicketL1(context.Context, *ClientCacheRequest) (*ClientCacheResponseL1, error)
	ExchangeTicketL2(context.Context, *ClientCacheRequest) (*ClientCacheResponseL2, error)
}

func RegisterClientCacheServer(s *grpc.Server, srv ClientCacheServer) {
	s.RegisterService(&_ClientCache_serviceDesc, srv)
}

func _ClientCache_GetBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientCacheServer).GetBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmsg.ClientCache/GetBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientCacheServer).GetBlock(ctx, req.(*ClientCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClientCache_ExchangeTicketL1_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientCacheServer).ExchangeTicketL1(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmsg.ClientCache/ExchangeTicketL1",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientCacheServer).ExchangeTicketL1(ctx, req.(*ClientCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClientCache_ExchangeTicketL2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientCacheServer).ExchangeTicketL2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmsg.ClientCache/ExchangeTicketL2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientCacheServer).ExchangeTicketL2(ctx, req.(*ClientCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ClientCache_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ccmsg.ClientCache",
	HandlerType: (*ClientCacheServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBlock",
			Handler:    _ClientCache_GetBlock_Handler,
		},
		{
			MethodName: "ExchangeTicketL1",
			Handler:    _ClientCache_ExchangeTicketL1_Handler,
		},
		{
			MethodName: "ExchangeTicketL2",
			Handler:    _ClientCache_ExchangeTicketL2_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cachecash.proto",
}

// Client API for CacheProvider service

type CacheProviderClient interface {
	CacheMiss(ctx context.Context, in *CacheMissRequest, opts ...grpc.CallOption) (*CacheMissResponse, error)
}

type cacheProviderClient struct {
	cc *grpc.ClientConn
}

func NewCacheProviderClient(cc *grpc.ClientConn) CacheProviderClient {
	return &cacheProviderClient{cc}
}

func (c *cacheProviderClient) CacheMiss(ctx context.Context, in *CacheMissRequest, opts ...grpc.CallOption) (*CacheMissResponse, error) {
	out := new(CacheMissResponse)
	err := grpc.Invoke(ctx, "/ccmsg.CacheProvider/CacheMiss", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CacheProvider service

type CacheProviderServer interface {
	CacheMiss(context.Context, *CacheMissRequest) (*CacheMissResponse, error)
}

func RegisterCacheProviderServer(s *grpc.Server, srv CacheProviderServer) {
	s.RegisterService(&_CacheProvider_serviceDesc, srv)
}

func _CacheProvider_CacheMiss_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CacheMissRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheProviderServer).CacheMiss(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmsg.CacheProvider/CacheMiss",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheProviderServer).CacheMiss(ctx, req.(*CacheMissRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CacheProvider_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ccmsg.CacheProvider",
	HandlerType: (*CacheProviderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CacheMiss",
			Handler:    _CacheProvider_CacheMiss_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cachecash.proto",
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *PublicKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PublicKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.PublicKey)))
		i += copy(dAtA[i:], m.PublicKey)
	}
	return i, nil
}

func (m *EscrowInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EscrowInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PublicKey != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.PublicKey.Size()))
		n1, err := m.PublicKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.ProviderPublicKey != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.ProviderPublicKey.Size()))
		n2, err := m.ProviderPublicKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.DrawDelay != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.DrawDelay))
	}
	if m.ExpirationDelay != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.ExpirationDelay))
	}
	if m.StartBlock != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.StartBlock))
	}
	if len(m.TicketsPerBlock) > 0 {
		for _, msg := range m.TicketsPerBlock {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Id != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Id.Size()))
		n3, err := m.Id.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *Segment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Segment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Length != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Length))
	}
	if m.Value != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Value))
	}
	return i, nil
}

func (m *TicketBundle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketBundle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Remainder != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Remainder.Size()))
		n4, err := m.Remainder.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.TicketRequest) > 0 {
		for _, msg := range m.TicketRequest {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TicketL1) > 0 {
		for _, msg := range m.TicketL1 {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.BatchSig != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BatchSig.Size()))
		n5, err := m.BatchSig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.CacheInfo) > 0 {
		for _, msg := range m.CacheInfo {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EncryptedTicketL2) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.EncryptedTicketL2)))
		i += copy(dAtA[i:], m.EncryptedTicketL2)
	}
	if m.BundleSignerCert != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BundleSignerCert.Size()))
		n6, err := m.BundleSignerCert.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Metadata != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Metadata.Size()))
		n7, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *TicketBundleRemainder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketBundleRemainder) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EscrowId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.EscrowId.Size()))
		n8, err := m.EscrowId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.RequestSequenceNo != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RequestSequenceNo))
	}
	if m.ObjectId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.ObjectId))
	}
	if m.PuzzleInfo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.PuzzleInfo.Size()))
		n9, err := m.PuzzleInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.ClientPublicKey != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.ClientPublicKey.Size()))
		n10, err := m.ClientPublicKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *CacheInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Addr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Addr.Size()))
		n11, err := m.Addr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *NetworkAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkAddress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Inetaddr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Inetaddr)))
		i += copy(dAtA[i:], m.Inetaddr)
	}
	if len(m.Inet6Addr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Inet6Addr)))
		i += copy(dAtA[i:], m.Inet6Addr)
	}
	if m.Port != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Port))
	}
	return i, nil
}

func (m *ColocationPuzzleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColocationPuzzleInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rounds != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Rounds))
	}
	if len(m.Goal) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Goal)))
		i += copy(dAtA[i:], m.Goal)
	}
	if m.StartOffset != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.StartOffset))
	}
	if m.StartRange != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.StartRange))
	}
	return i, nil
}

func (m *BatchSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSignature) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PathDirection) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.PathDirection)))
		for _, b := range m.PathDirection {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.PathDigest) > 0 {
		for _, b := range m.PathDigest {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.RootSignature) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.RootSignature)))
		i += copy(dAtA[i:], m.RootSignature)
	}
	if m.SigningKey != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.SigningKey.Size()))
		n12, err := m.SigningKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *BlockKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}

func (m *TicketRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BlockIdx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BlockIdx))
	}
	if m.InnerKey != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.InnerKey.Size()))
		n13, err := m.InnerKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.CachePublicKey != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.CachePublicKey.Size()))
		n14, err := m.CachePublicKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.BlockId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.BlockId)))
		i += copy(dAtA[i:], m.BlockId)
	}
	return i, nil
}

func (m *TicketL1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketL1) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TicketNo != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.TicketNo))
	}
	if m.CachePublicKey != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.CachePublicKey.Size()))
		n15, err := m.CachePublicKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.BlockIdx != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BlockIdx))
	}
	return i, nil
}

func (m *TicketL2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketL2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nonce) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Nonce)))
		i += copy(dAtA[i:], m.Nonce)
	}
	if len(m.InnerSessionKey) > 0 {
		for _, msg := range m.InnerSessionKey {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EscrowID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EscrowID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BlockIdx != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BlockIdx))
	}
	if m.TransactionIdx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.TransactionIdx))
	}
	return i, nil
}

func (m *TicketL2Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketL2Info) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EncryptedTicketL2) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.EncryptedTicketL2)))
		i += copy(dAtA[i:], m.EncryptedTicketL2)
	}
	if len(m.PuzzleSecret) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.PuzzleSecret)))
		i += copy(dAtA[i:], m.PuzzleSecret)
	}
	return i, nil
}

func (m *Certificate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Certificate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SubjectPublicKey != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.SubjectPublicKey.Size()))
		n16, err := m.SubjectPublicKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.EscrowId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.EscrowId.Size()))
		n17, err := m.EscrowId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.Usage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Usage)))
		i += copy(dAtA[i:], m.Usage)
	}
	if len(m.Signature) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	return i, nil
}

func (m *TicketBundleSubdigests) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketBundleSubdigests) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TicketRequestDigest) > 0 {
		for _, b := range m.TicketRequestDigest {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.TicketL1Digest) > 0 {
		for _, b := range m.TicketL1Digest {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.EncryptedTicketL2Digest) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.EncryptedTicketL2Digest)))
		i += copy(dAtA[i:], m.EncryptedTicketL2Digest)
	}
	if len(m.RemainderDigest) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.RemainderDigest)))
		i += copy(dAtA[i:], m.RemainderDigest)
	}
	return i, nil
}

func (m *ContentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContentRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClientPublicKey != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.ClientPublicKey.Size()))
		n18, err := m.ClientPublicKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.SequenceNo != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.SequenceNo))
	}
	if m.RangeBegin != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RangeBegin))
	}
	if m.RangeEnd != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RangeEnd))
	}
	return i, nil
}

func (m *ContentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContentResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestSequenceNo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RequestSequenceNo))
	}
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Error.Size()))
		n19, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.Bundle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Bundle.Size()))
		n20, err := m.Bundle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *ClientCacheRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCacheRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BundleRemainder != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BundleRemainder.Size()))
		n21, err := m.BundleRemainder.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.TicketBundleSubdigests != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.TicketBundleSubdigests.Size()))
		n22, err := m.TicketBundleSubdigests.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.BundleSig != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BundleSig.Size()))
		n23, err := m.BundleSig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.BundleSignerCert != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BundleSignerCert.Size()))
		n24, err := m.BundleSignerCert.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Ticket != nil {
		nn25, err := m.Ticket.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn25
	}
	if m.SequenceNo != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.SequenceNo))
	}
	return i, nil
}

func (m *ClientCacheRequest_TicketRequest) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TicketRequest != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.TicketRequest.Size()))
		n26, err := m.TicketRequest.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *ClientCacheRequest_TicketL1) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TicketL1 != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.TicketL1.Size()))
		n27, err := m.TicketL1.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}
func (m *ClientCacheRequest_TicketL2) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TicketL2 != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.TicketL2.Size()))
		n28, err := m.TicketL2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}
func (m *ClientCacheResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCacheResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestSequenceNo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RequestSequenceNo))
	}
	if m.Msg != nil {
		nn29, err := m.Msg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn29
	}
	return i, nil
}

func (m *ClientCacheResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Error.Size()))
		n30, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}
func (m *ClientCacheResponse_DataResponse) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DataResponse != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.DataResponse.Size()))
		n31, err := m.DataResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}
func (m *ClientCacheResponse_L1Response) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.L1Response != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.L1Response.Size()))
		n32, err := m.L1Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}
func (m *ClientCacheResponse_L2Response) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.L2Response != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.L2Response.Size()))
		n33, err := m.L2Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}
func (m *ClientCacheResponseData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCacheResponseData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *ClientCacheResponseL1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCacheResponseL1) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OuterKey != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.OuterKey.Size()))
		n34, err := m.OuterKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}

func (m *ClientCacheResponseL2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCacheResponseL2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CacheMissRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheMissRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RangeBegin != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RangeBegin))
	}
	if m.RangeEnd != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RangeEnd))
	}
	if m.ObjectId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.ObjectId))
	}
	return i, nil
}

func (m *CacheMissResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheMissResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SlotIdx) > 0 {
		dAtA36 := make([]byte, len(m.SlotIdx)*10)
		var j35 int
		for _, num := range m.SlotIdx {
			for num >= 1<<7 {
				dAtA36[j35] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j35++
			}
			dAtA36[j35] = uint8(num)
			j35++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(j35))
		i += copy(dAtA[i:], dAtA36[:j35])
	}
	if m.Metadata != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Metadata.Size()))
		n37, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if len(m.BlockId) > 0 {
		for _, b := range m.BlockId {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.Source != nil {
		nn38, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn38
	}
	return i, nil
}

func (m *CacheMissResponse_Http) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Http != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Http.Size()))
		n39, err := m.Http.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}
func (m *BlockSourceHTTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockSourceHTTP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.RangeBegin != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RangeBegin))
	}
	if m.RangeEnd != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RangeEnd))
	}
	return i, nil
}

func (m *ObjectMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjectSize != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.ObjectSize))
	}
	if m.BlockSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BlockSize))
	}
	if len(m.Etag) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Etag)))
		i += copy(dAtA[i:], m.Etag)
	}
	if len(m.LastModified) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.LastModified)))
		i += copy(dAtA[i:], m.LastModified)
	}
	if len(m.CacheExpiration) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.CacheExpiration)))
		i += copy(dAtA[i:], m.CacheExpiration)
	}
	return i, nil
}

func encodeVarintCachecash(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Error) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovCachecash(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}

func (m *PublicKey) Size() (n int) {
	var l int
	_ = l
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}

func (m *EscrowInfo) Size() (n int) {
	var l int
	_ = l
	if m.PublicKey != nil {
		l = m.PublicKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.ProviderPublicKey != nil {
		l = m.ProviderPublicKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.DrawDelay != 0 {
		n += 1 + sovCachecash(uint64(m.DrawDelay))
	}
	if m.ExpirationDelay != 0 {
		n += 1 + sovCachecash(uint64(m.ExpirationDelay))
	}
	if m.StartBlock != 0 {
		n += 1 + sovCachecash(uint64(m.StartBlock))
	}
	if len(m.TicketsPerBlock) > 0 {
		for _, e := range m.TicketsPerBlock {
			l = e.Size()
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}

func (m *Segment) Size() (n int) {
	var l int
	_ = l
	if m.Length != 0 {
		n += 1 + sovCachecash(uint64(m.Length))
	}
	if m.Value != 0 {
		n += 1 + sovCachecash(uint64(m.Value))
	}
	return n
}

func (m *TicketBundle) Size() (n int) {
	var l int
	_ = l
	if m.Remainder != nil {
		l = m.Remainder.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if len(m.TicketRequest) > 0 {
		for _, e := range m.TicketRequest {
			l = e.Size()
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	if len(m.TicketL1) > 0 {
		for _, e := range m.TicketL1 {
			l = e.Size()
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	if m.BatchSig != nil {
		l = m.BatchSig.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if len(m.CacheInfo) > 0 {
		for _, e := range m.CacheInfo {
			l = e.Size()
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	l = len(m.EncryptedTicketL2)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.BundleSignerCert != nil {
		l = m.BundleSignerCert.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}

func (m *TicketBundleRemainder) Size() (n int) {
	var l int
	_ = l
	if m.EscrowId != nil {
		l = m.EscrowId.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.RequestSequenceNo != 0 {
		n += 1 + sovCachecash(uint64(m.RequestSequenceNo))
	}
	if m.ObjectId != 0 {
		n += 1 + sovCachecash(uint64(m.ObjectId))
	}
	if m.PuzzleInfo != nil {
		l = m.PuzzleInfo.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.ClientPublicKey != nil {
		l = m.ClientPublicKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}

func (m *CacheInfo) Size() (n int) {
	var l int
	_ = l
	if m.Addr != nil {
		l = m.Addr.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}

func (m *NetworkAddress) Size() (n int) {
	var l int
	_ = l
	l = len(m.Inetaddr)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.Inet6Addr)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovCachecash(uint64(m.Port))
	}
	return n
}

func (m *ColocationPuzzleInfo) Size() (n int) {
	var l int
	_ = l
	if m.Rounds != 0 {
		n += 1 + sovCachecash(uint64(m.Rounds))
	}
	l = len(m.Goal)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.StartOffset != 0 {
		n += 1 + sovCachecash(uint64(m.StartOffset))
	}
	if m.StartRange != 0 {
		n += 1 + sovCachecash(uint64(m.StartRange))
	}
	return n
}

func (m *BatchSignature) Size() (n int) {
	var l int
	_ = l
	if len(m.PathDirection) > 0 {
		n += 1 + sovCachecash(uint64(len(m.PathDirection))) + len(m.PathDirection)*1
	}
	if len(m.PathDigest) > 0 {
		for _, b := range m.PathDigest {
			l = len(b)
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	l = len(m.RootSignature)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.SigningKey != nil {
		l = m.SigningKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}

func (m *BlockKey) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}

func (m *TicketRequest) Size() (n int) {
	var l int
	_ = l
	if m.BlockIdx != 0 {
		n += 1 + sovCachecash(uint64(m.BlockIdx))
	}
	if m.InnerKey != nil {
		l = m.InnerKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.CachePublicKey != nil {
		l = m.CachePublicKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.BlockId)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}

func (m *TicketL1) Size() (n int) {
	var l int
	_ = l
	if m.TicketNo != 0 {
		n += 1 + sovCachecash(uint64(m.TicketNo))
	}
	if m.CachePublicKey != nil {
		l = m.CachePublicKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.BlockIdx != 0 {
		n += 1 + sovCachecash(uint64(m.BlockIdx))
	}
	return n
}

func (m *TicketL2) Size() (n int) {
	var l int
	_ = l
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if len(m.InnerSessionKey) > 0 {
		for _, e := range m.InnerSessionKey {
			l = e.Size()
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	return n
}

func (m *EscrowID) Size() (n int) {
	var l int
	_ = l
	if m.BlockIdx != 0 {
		n += 1 + sovCachecash(uint64(m.BlockIdx))
	}
	if m.TransactionIdx != 0 {
		n += 1 + sovCachecash(uint64(m.TransactionIdx))
	}
	return n
}

func (m *TicketL2Info) Size() (n int) {
	var l int
	_ = l
	l = len(m.EncryptedTicketL2)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.PuzzleSecret)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}

func (m *Certificate) Size() (n int) {
	var l int
	_ = l
	if m.SubjectPublicKey != nil {
		l = m.SubjectPublicKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.EscrowId != nil {
		l = m.EscrowId.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.Usage)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}

func (m *TicketBundleSubdigests) Size() (n int) {
	var l int
	_ = l
	if len(m.TicketRequestDigest) > 0 {
		for _, b := range m.TicketRequestDigest {
			l = len(b)
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	if len(m.TicketL1Digest) > 0 {
		for _, b := range m.TicketL1Digest {
			l = len(b)
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	l = len(m.EncryptedTicketL2Digest)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.RemainderDigest)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}

func (m *ContentRequest) Size() (n int) {
	var l int
	_ = l
	if m.ClientPublicKey != nil {
		l = m.ClientPublicKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.SequenceNo != 0 {
		n += 1 + sovCachecash(uint64(m.SequenceNo))
	}
	if m.RangeBegin != 0 {
		n += 1 + sovCachecash(uint64(m.RangeBegin))
	}
	if m.RangeEnd != 0 {
		n += 1 + sovCachecash(uint64(m.RangeEnd))
	}
	return n
}

func (m *ContentResponse) Size() (n int) {
	var l int
	_ = l
	if m.RequestSequenceNo != 0 {
		n += 1 + sovCachecash(uint64(m.RequestSequenceNo))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.Bundle != nil {
		l = m.Bundle.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}

func (m *ClientCacheRequest) Size() (n int) {
	var l int
	_ = l
	if m.BundleRemainder != nil {
		l = m.BundleRemainder.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.TicketBundleSubdigests != nil {
		l = m.TicketBundleSubdigests.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.BundleSig != nil {
		l = m.BundleSig.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.BundleSignerCert != nil {
		l = m.BundleSignerCert.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.Ticket != nil {
		n += m.Ticket.Size()
	}
	if m.SequenceNo != 0 {
		n += 1 + sovCachecash(uint64(m.SequenceNo))
	}
	return n
}

func (m *ClientCacheRequest_TicketRequest) Size() (n int) {
	var l int
	_ = l
	if m.TicketRequest != nil {
		l = m.TicketRequest.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *ClientCacheRequest_TicketL1) Size() (n int) {
	var l int
	_ = l
	if m.TicketL1 != nil {
		l = m.TicketL1.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *ClientCacheRequest_TicketL2) Size() (n int) {
	var l int
	_ = l
	if m.TicketL2 != nil {
		l = m.TicketL2.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *ClientCacheResponse) Size() (n int) {
	var l int
	_ = l
	if m.RequestSequenceNo != 0 {
		n += 1 + sovCachecash(uint64(m.RequestSequenceNo))
	}
	if m.Msg != nil {
		n += m.Msg.Size()
	}
	return n
}

func (m *ClientCacheResponse_Error) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *ClientCacheResponse_DataResponse) Size() (n int) {
	var l int
	_ = l
	if m.DataResponse != nil {
		l = m.DataResponse.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *ClientCacheResponse_L1Response) Size() (n int) {
	var l int
	_ = l
	if m.L1Response != nil {
		l = m.L1Response.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *ClientCacheResponse_L2Response) Size() (n int) {
	var l int
	_ = l
	if m.L2Response != nil {
		l = m.L2Response.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *ClientCacheResponseData) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}

func (m *ClientCacheResponseL1) Size() (n int) {
	var l int
	_ = l
	if m.OuterKey != nil {
		l = m.OuterKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}

func (m *ClientCacheResponseL2) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CacheMissRequest) Size() (n int) {
	var l int
	_ = l
	if m.RangeBegin != 0 {
		n += 1 + sovCachecash(uint64(m.RangeBegin))
	}
	if m.RangeEnd != 0 {
		n += 1 + sovCachecash(uint64(m.RangeEnd))
	}
	if m.ObjectId != 0 {
		n += 1 + sovCachecash(uint64(m.ObjectId))
	}
	return n
}

func (m *CacheMissResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.SlotIdx) > 0 {
		l = 0
		for _, e := range m.SlotIdx {
			l += sovCachecash(uint64(e))
		}
		n += 1 + sovCachecash(uint64(l)) + l
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if len(m.BlockId) > 0 {
		for _, b := range m.BlockId {
			l = len(b)
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	if m.Source != nil {
		n += m.Source.Size()
	}
	return n
}

func (m *CacheMissResponse_Http) Size() (n int) {
	var l int
	_ = l
	if m.Http != nil {
		l = m.Http.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *BlockSourceHTTP) Size() (n int) {
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.RangeBegin != 0 {
		n += 1 + sovCachecash(uint64(m.RangeBegin))
	}
	if m.RangeEnd != 0 {
		n += 1 + sovCachecash(uint64(m.RangeEnd))
	}
	return n
}

func (m *ObjectMetadata) Size() (n int) {
	var l int
	_ = l
	if m.ObjectSize != 0 {
		n += 1 + sovCachecash(uint64(m.ObjectSize))
	}
	if m.BlockSize != 0 {
		n += 1 + sovCachecash(uint64(m.BlockSize))
	}
	l = len(m.Etag)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.LastModified)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.CacheExpiration)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}

func sovCachecash(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCachecash(x uint64) (n int) {
	return sovCachecash(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EscrowInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EscrowInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EscrowInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublicKey == nil {
				m.PublicKey = &PublicKey{}
			}
			if err := m.PublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProviderPublicKey == nil {
				m.ProviderPublicKey = &PublicKey{}
			}
			if err := m.ProviderPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrawDelay", wireType)
			}
			m.DrawDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DrawDelay |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationDelay", wireType)
			}
			m.ExpirationDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationDelay |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBlock", wireType)
			}
			m.StartBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartBlock |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketsPerBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketsPerBlock = append(m.TicketsPerBlock, &Segment{})
			if err := m.TicketsPerBlock[len(m.TicketsPerBlock)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &EscrowID{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Segment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Segment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Segment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketBundle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketBundle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketBundle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remainder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Remainder == nil {
				m.Remainder = &TicketBundleRemainder{}
			}
			if err := m.Remainder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketRequest = append(m.TicketRequest, &TicketRequest{})
			if err := m.TicketRequest[len(m.TicketRequest)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketL1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketL1 = append(m.TicketL1, &TicketL1{})
			if err := m.TicketL1[len(m.TicketL1)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchSig == nil {
				m.BatchSig = &BatchSignature{}
			}
			if err := m.BatchSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheInfo = append(m.CacheInfo, &CacheInfo{})
			if err := m.CacheInfo[len(m.CacheInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedTicketL2", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedTicketL2 = append(m.EncryptedTicketL2[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedTicketL2 == nil {
				m.EncryptedTicketL2 = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleSignerCert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BundleSignerCert == nil {
				m.BundleSignerCert = &Certificate{}
			}
			if err := m.BundleSignerCert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &ObjectMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketBundleRemainder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketBundleRemainder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketBundleRemainder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EscrowId == nil {
				m.EscrowId = &EscrowID{}
			}
			if err := m.EscrowId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestSequenceNo", wireType)
			}
			m.RequestSequenceNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestSequenceNo |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			m.ObjectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PuzzleInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PuzzleInfo == nil {
				m.PuzzleInfo = &ColocationPuzzleInfo{}
			}
			if err := m.PuzzleInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientPublicKey == nil {
				m.ClientPublicKey = &PublicKey{}
			}
			if err := m.ClientPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Addr == nil {
				m.Addr = &NetworkAddress{}
			}
			if err := m.Addr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inetaddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inetaddr = append(m.Inetaddr[:0], dAtA[iNdEx:postIndex]...)
			if m.Inetaddr == nil {
				m.Inetaddr = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inet6Addr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inet6Addr = append(m.Inet6Addr[:0], dAtA[iNdEx:postIndex]...)
			if m.Inet6Addr == nil {
				m.Inet6Addr = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColocationPuzzleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColocationPuzzleInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColocationPuzzleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rounds", wireType)
			}
			m.Rounds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rounds |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Goal = append(m.Goal[:0], dAtA[iNdEx:postIndex]...)
			if m.Goal == nil {
				m.Goal = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartOffset", wireType)
			}
			m.StartOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartOffset |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartRange", wireType)
			}
			m.StartRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartRange |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCachecash
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PathDirection = append(m.PathDirection, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCachecash
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCachecash
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCachecash
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PathDirection = append(m.PathDirection, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PathDirection", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathDigest = append(m.PathDigest, make([]byte, postIndex-iNdEx))
			copy(m.PathDigest[len(m.PathDigest)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootSignature = append(m.RootSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.RootSignature == nil {
				m.RootSignature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SigningKey == nil {
				m.SigningKey = &PublicKey{}
			}
			if err := m.SigningKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockIdx", wireType)
			}
			m.BlockIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockIdx |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InnerKey == nil {
				m.InnerKey = &BlockKey{}
			}
			if err := m.InnerKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachePublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CachePublicKey == nil {
				m.CachePublicKey = &PublicKey{}
			}
			if err := m.CachePublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockId = append(m.BlockId[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockId == nil {
				m.BlockId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketL1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketL1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketL1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketNo", wireType)
			}
			m.TicketNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TicketNo |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachePublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CachePublicKey == nil {
				m.CachePublicKey = &PublicKey{}
			}
			if err := m.CachePublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockIdx", wireType)
			}
			m.BlockIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockIdx |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketL2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketL2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketL2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = append(m.Nonce[:0], dAtA[iNdEx:postIndex]...)
			if m.Nonce == nil {
				m.Nonce = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerSessionKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InnerSessionKey = append(m.InnerSessionKey, &BlockKey{})
			if err := m.InnerSessionKey[len(m.InnerSessionKey)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EscrowID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EscrowID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EscrowID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockIdx", wireType)
			}
			m.BlockIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockIdx |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionIdx", wireType)
			}
			m.TransactionIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketL2Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketL2Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketL2Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedTicketL2", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedTicketL2 = append(m.EncryptedTicketL2[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedTicketL2 == nil {
				m.EncryptedTicketL2 = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PuzzleSecret", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PuzzleSecret = append(m.PuzzleSecret[:0], dAtA[iNdEx:postIndex]...)
			if m.PuzzleSecret == nil {
				m.PuzzleSecret = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Certificate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Certificate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Certificate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubjectPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubjectPublicKey == nil {
				m.SubjectPublicKey = &PublicKey{}
			}
			if err := m.SubjectPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EscrowId == nil {
				m.EscrowId = &EscrowID{}
			}
			if err := m.EscrowId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Usage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketBundleSubdigests) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketBundleSubdigests: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketBundleSubdigests: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketRequestDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketRequestDigest = append(m.TicketRequestDigest, make([]byte, postIndex-iNdEx))
			copy(m.TicketRequestDigest[len(m.TicketRequestDigest)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketL1Digest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketL1Digest = append(m.TicketL1Digest, make([]byte, postIndex-iNdEx))
			copy(m.TicketL1Digest[len(m.TicketL1Digest)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedTicketL2Digest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedTicketL2Digest = append(m.EncryptedTicketL2Digest[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedTicketL2Digest == nil {
				m.EncryptedTicketL2Digest = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainderDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemainderDigest = append(m.RemainderDigest[:0], dAtA[iNdEx:postIndex]...)
			if m.RemainderDigest == nil {
				m.RemainderDigest = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientPublicKey == nil {
				m.ClientPublicKey = &PublicKey{}
			}
			if err := m.ClientPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNo", wireType)
			}
			m.SequenceNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNo |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeBegin", wireType)
			}
			m.RangeBegin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeBegin |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeEnd", wireType)
			}
			m.RangeEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeEnd |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestSequenceNo", wireType)
			}
			m.RequestSequenceNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestSequenceNo |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bundle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bundle == nil {
				m.Bundle = &TicketBundle{}
			}
			if err := m.Bundle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientCacheRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCacheRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCacheRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleRemainder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BundleRemainder == nil {
				m.BundleRemainder = &TicketBundleRemainder{}
			}
			if err := m.BundleRemainder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketBundleSubdigests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TicketBundleSubdigests == nil {
				m.TicketBundleSubdigests = &TicketBundleSubdigests{}
			}
			if err := m.TicketBundleSubdigests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleSig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BundleSig == nil {
				m.BundleSig = &BatchSignature{}
			}
			if err := m.BundleSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleSignerCert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BundleSignerCert == nil {
				m.BundleSignerCert = &Certificate{}
			}
			if err := m.BundleSignerCert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TicketRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ticket = &ClientCacheRequest_TicketRequest{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketL1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TicketL1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ticket = &ClientCacheRequest_TicketL1{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketL2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TicketL2Info{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ticket = &ClientCacheRequest_TicketL2{v}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNo", wireType)
			}
			m.SequenceNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNo |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientCacheResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCacheResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCacheResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestSequenceNo", wireType)
			}
			m.RequestSequenceNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestSequenceNo |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &ClientCacheResponse_Error{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClientCacheResponseData{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &ClientCacheResponse_DataResponse{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClientCacheResponseL1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &ClientCacheResponse_L1Response{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClientCacheResponseL2{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &ClientCacheResponse_L2Response{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientCacheResponseData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCacheResponseData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCacheResponseData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientCacheResponseL1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCacheResponseL1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCacheResponseL1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OuterKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OuterKey == nil {
				m.OuterKey = &BlockKey{}
			}
			if err := m.OuterKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientCacheResponseL2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCacheResponseL2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCacheResponseL2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheMissRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheMissRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheMissRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeBegin", wireType)
			}
			m.RangeBegin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeBegin |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeEnd", wireType)
			}
			m.RangeEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeEnd |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			m.ObjectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheMissResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheMissResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheMissResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCachecash
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SlotIdx = append(m.SlotIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCachecash
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCachecash
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCachecash
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SlotIdx = append(m.SlotIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotIdx", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &ObjectMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockId = append(m.BlockId, make([]byte, postIndex-iNdEx))
			copy(m.BlockId[len(m.BlockId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockSourceHTTP{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Source = &CacheMissResponse_Http{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockSourceHTTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockSourceHTTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockSourceHTTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeBegin", wireType)
			}
			m.RangeBegin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeBegin |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeEnd", wireType)
			}
			m.RangeEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeEnd |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectSize", wireType)
			}
			m.ObjectSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockSize", wireType)
			}
			m.BlockSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etag", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Etag = append(m.Etag[:0], dAtA[iNdEx:postIndex]...)
			if m.Etag == nil {
				m.Etag = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModified", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastModified = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheExpiration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheExpiration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCachecash(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCachecash
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCachecash
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCachecash(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCachecash = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCachecash   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("cachecash.proto", fileDescriptorCachecash) }

var fileDescriptorCachecash = []byte{
	// 1853 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0x4b, 0x73, 0x1c, 0x49,
	0x11, 0x9e, 0x9e, 0x87, 0xd4, 0x93, 0xf3, 0x54, 0xc9, 0x92, 0xc7, 0x5e, 0x5b, 0x16, 0x0d, 0x04,
	0x32, 0x2c, 0x22, 0xd4, 0xc0, 0x12, 0x61, 0xef, 0x82, 0x91, 0xad, 0xb0, 0x1c, 0xac, 0x6d, 0xd1,
	0xe3, 0x08, 0x4e, 0xd0, 0xd1, 0xd3, 0x5d, 0x1a, 0x35, 0x1e, 0x75, 0x0f, 0xdd, 0x35, 0xeb, 0xc7,
	0x89, 0x13, 0x47, 0x0e, 0x9c, 0xf8, 0x17, 0x04, 0x04, 0x37, 0x0e, 0x04, 0x27, 0x38, 0xf2, 0x0b,
	0x08, 0xc2, 0xfc, 0x05, 0x8e, 0x1c, 0x88, 0xcc, 0xaa, 0xea, 0xc7, 0xa8, 0x47, 0xd6, 0xee, 0x9e,
	0xa6, 0x2a, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0xf3, 0xcb, 0x6f, 0x1a, 0x06, 0xbe, 0xe7, 0x9f, 0x71,
	0xdf, 0x4b, 0xcf, 0xf6, 0xe7, 0x49, 0x2c, 0x62, 0xd6, 0xf2, 0xfd, 0xf3, 0x74, 0x6a, 0x7d, 0x1f,
	0x5a, 0x47, 0x49, 0x12, 0x27, 0x8c, 0x41, 0xd3, 0x8f, 0x03, 0x3e, 0x32, 0x76, 0x8d, 0xbd, 0xa6,
	0x43, 0x63, 0x36, 0x82, 0xf5, 0x73, 0x9e, 0xa6, 0xde, 0x94, 0x8f, 0xea, 0xbb, 0xc6, 0x5e, 0xdb,
	0xd1, 0x53, 0xeb, 0x9b, 0xd0, 0x3e, 0x59, 0x4c, 0x66, 0xa1, 0xff, 0x13, 0xfe, 0x86, 0xdd, 0x06,
	0x98, 0xd3, 0xc4, 0x7d, 0xc9, 0xdf, 0x90, 0x81, 0xae, 0xd3, 0x9e, 0xeb, 0x65, 0xeb, 0xef, 0x75,
	0x80, 0xa3, 0xd4, 0x4f, 0xe2, 0x57, 0x4f, 0xa2, 0xd3, 0x98, 0x7d, 0xe7, 0x82, 0x76, 0xc7, 0x1e,
	0xee, 0x93, 0x37, 0xfb, 0x99, 0xcd, 0xc2, 0x7e, 0xf6, 0x00, 0x36, 0xe7, 0x49, 0xfc, 0x59, 0x18,
	0xf0, 0xc4, 0x2d, 0xec, 0xac, 0xaf, 0xd8, 0xb9, 0xa1, 0x95, 0x4b, 0x0e, 0x06, 0x89, 0xf7, 0xca,
	0x0d, 0xf8, 0xcc, 0x7b, 0x33, 0x6a, 0xd0, 0x0d, 0xdb, 0x28, 0x79, 0x84, 0x02, 0x76, 0x17, 0x86,
	0xfc, 0xf5, 0x3c, 0x4c, 0x3c, 0x11, 0xc6, 0x91, 0x52, 0x6a, 0x92, 0xd2, 0x20, 0x97, 0x4b, 0xd5,
	0x3b, 0xd0, 0x49, 0x85, 0x97, 0x08, 0x77, 0x32, 0x8b, 0xfd, 0x97, 0xa3, 0x16, 0x69, 0x01, 0x89,
	0x0e, 0x51, 0xc2, 0xee, 0xc1, 0x86, 0x08, 0xfd, 0x97, 0x5c, 0xa4, 0xee, 0x9c, 0x27, 0x4a, 0x6d,
	0x6d, 0xb7, 0xb1, 0xd7, 0xb1, 0xfb, 0xca, 0xd5, 0x31, 0x9f, 0x9e, 0xf3, 0x48, 0x38, 0x03, 0xa5,
	0x78, 0xc2, 0x13, 0xb9, 0xf7, 0x0e, 0xd4, 0xc3, 0x60, 0xb4, 0x4e, 0xf7, 0x1a, 0x28, 0x65, 0x15,
	0xb8, 0x47, 0x4e, 0x3d, 0x0c, 0xac, 0x1f, 0xc0, 0xba, 0xda, 0xcc, 0xb6, 0x61, 0x6d, 0xc6, 0xa3,
	0xa9, 0x38, 0x53, 0x0f, 0xa6, 0x66, 0xec, 0x1a, 0xb4, 0x3e, 0xf3, 0x66, 0x0b, 0xf9, 0x60, 0x4d,
	0x47, 0x4e, 0xac, 0xbf, 0x36, 0xa0, 0xfb, 0x82, 0x4e, 0x3b, 0x5c, 0x44, 0xc1, 0x8c, 0xb3, 0x7b,
	0xd0, 0x4e, 0xf8, 0xb9, 0x17, 0x46, 0x01, 0x4f, 0xd4, 0x1b, 0xdc, 0x52, 0x27, 0x16, 0xf5, 0x1c,
	0xad, 0xe3, 0xe4, 0xea, 0xec, 0x3e, 0xf4, 0xa5, 0xe7, 0x6e, 0xc2, 0x7f, 0xb5, 0xe0, 0xa9, 0x18,
	0xb5, 0xe8, 0x7e, 0xd7, 0x4a, 0x06, 0x1c, 0xb9, 0xe6, 0xf4, 0x44, 0x71, 0xca, 0x3e, 0x84, 0xb6,
	0xda, 0x3c, 0x3b, 0x50, 0x71, 0x19, 0x94, 0xf6, 0x7d, 0x7a, 0xe0, 0x98, 0x42, 0x8d, 0x98, 0x0d,
	0xed, 0x89, 0x27, 0xfc, 0x33, 0x37, 0x0d, 0xa7, 0x23, 0x93, 0xdc, 0xdc, 0x52, 0xda, 0x87, 0x28,
	0x1f, 0x87, 0xd3, 0xc8, 0x13, 0x8b, 0x84, 0x3b, 0xe6, 0x44, 0xcd, 0x31, 0xbf, 0x28, 0xd7, 0xdd,
	0x30, 0x3a, 0x8d, 0x47, 0x6d, 0x3a, 0x42, 0x67, 0xc9, 0x43, 0x5c, 0xc0, 0x2c, 0x74, 0xda, 0xbe,
	0x1e, 0xb2, 0x7d, 0xd8, 0xe4, 0x91, 0x9f, 0xbc, 0x99, 0x0b, 0x1e, 0xb8, 0xda, 0x39, 0x7b, 0x04,
	0x94, 0xc7, 0x1b, 0xd9, 0x92, 0x72, 0xcf, 0x66, 0x0f, 0x80, 0x4d, 0x28, 0x3a, 0xe8, 0x55, 0xc4,
	0x13, 0xd7, 0xe7, 0x89, 0x18, 0x75, 0xc8, 0x3b, 0xa6, 0x0f, 0xe2, 0x89, 0x08, 0x4f, 0x43, 0xdf,
	0x13, 0xdc, 0x19, 0x4a, 0xed, 0x31, 0x29, 0xe3, 0x02, 0x3b, 0x00, 0xf3, 0x9c, 0x0b, 0x2f, 0xf0,
	0x84, 0x37, 0xea, 0x96, 0x6e, 0xf5, 0x7c, 0xf2, 0x4b, 0xee, 0x8b, 0xa7, 0x6a, 0xd1, 0xc9, 0xd4,
	0xac, 0xdf, 0xd6, 0x61, 0xab, 0xf2, 0x65, 0x30, 0xa2, 0x9c, 0x92, 0xc4, 0x0d, 0x03, 0xf5, 0x94,
	0x17, 0x92, 0xc7, 0x94, 0x1a, 0x4f, 0x02, 0xbc, 0xac, 0x7a, 0x35, 0x37, 0xc5, 0xdf, 0xc8, 0xe7,
	0x6e, 0x14, 0xab, 0x6c, 0xd9, 0x50, 0x4b, 0x63, 0xb5, 0xf2, 0x2c, 0x66, 0x1f, 0x40, 0x3b, 0x26,
	0x9f, 0xd0, 0xba, 0xac, 0x1c, 0x53, 0x0a, 0x9e, 0x04, 0xec, 0x63, 0xe8, 0xcc, 0x17, 0x6f, 0xdf,
	0xce, 0x54, 0xac, 0x65, 0xe6, 0x7e, 0xa0, 0x43, 0x10, 0xcf, 0x62, 0x9f, 0x4a, 0xe7, 0x84, 0x74,
	0x28, 0xec, 0x30, 0xcf, 0xc6, 0xec, 0x63, 0xd8, 0xf0, 0x67, 0x21, 0x8f, 0x44, 0xb1, 0xaa, 0xcd,
	0x15, 0x55, 0x3d, 0x90, 0xaa, 0x99, 0xc0, 0xfa, 0x08, 0xda, 0xd9, 0x6b, 0xb2, 0xbb, 0xd0, 0xf4,
	0x82, 0x40, 0x67, 0xb2, 0x0e, 0xe6, 0x33, 0x2e, 0x5e, 0xc5, 0xc9, 0xcb, 0x1f, 0x07, 0x41, 0xc2,
	0xd3, 0xd4, 0x21, 0x15, 0xeb, 0x17, 0xd0, 0x2f, 0xcb, 0xd9, 0x4d, 0x30, 0xc3, 0x08, 0xe3, 0xac,
	0x0c, 0x74, 0x9d, 0x6c, 0xce, 0x6e, 0x41, 0x1b, 0xc7, 0x1f, 0xd1, 0x62, 0x5d, 0x22, 0x5b, 0x26,
	0x40, 0xcc, 0x9c, 0xc7, 0x89, 0xa0, 0xb8, 0xf4, 0x1c, 0x1a, 0x5b, 0xbf, 0x31, 0xe0, 0x5a, 0xd5,
	0xd5, 0xb1, 0x62, 0x93, 0x78, 0x11, 0x05, 0x29, 0x1d, 0xd2, 0x73, 0xd4, 0x0c, 0x8d, 0x4c, 0x63,
	0x6f, 0xa6, 0xac, 0xd3, 0x98, 0x7d, 0x05, 0xba, 0x12, 0x66, 0xe2, 0xd3, 0xd3, 0x94, 0x0b, 0x15,
	0x78, 0x09, 0x3d, 0xcf, 0x49, 0x94, 0x23, 0x51, 0xe2, 0x45, 0x53, 0xae, 0xf0, 0x4a, 0x22, 0x91,
	0x83, 0x12, 0xeb, 0x4f, 0x06, 0xf4, 0xcb, 0x45, 0xc2, 0xbe, 0x0e, 0xfd, 0xb9, 0x27, 0xce, 0xdc,
	0x20, 0x4c, 0xb8, 0x8f, 0xee, 0x8d, 0xea, 0xbb, 0x8d, 0x3d, 0xd3, 0xe9, 0xa1, 0xf4, 0x91, 0x16,
	0xa2, 0x69, 0xa5, 0x36, 0xc5, 0xea, 0x6e, 0xec, 0x36, 0xf6, 0xba, 0x0e, 0x48, 0x1d, 0x94, 0xa0,
	0x9d, 0x24, 0x8e, 0x05, 0xe5, 0x3f, 0x59, 0xa6, 0xe3, 0xbb, 0x4e, 0x0f, 0xa5, 0xf9, 0x71, 0x07,
	0xd0, 0x41, 0x8d, 0x30, 0x9a, 0xd2, 0xd3, 0xb6, 0x56, 0x3c, 0x2d, 0x28, 0x25, 0x7c, 0xd5, 0x5b,
	0x60, 0x12, 0x16, 0x22, 0x6a, 0x0f, 0xa1, 0x91, 0xf7, 0x13, 0x1c, 0x5a, 0x7f, 0x34, 0xa0, 0x57,
	0x42, 0x17, 0x4c, 0x4f, 0x82, 0x58, 0x37, 0x0c, 0x5e, 0xab, 0x24, 0x36, 0x49, 0xf0, 0x24, 0x78,
	0x8d, 0x95, 0x11, 0x46, 0x58, 0xa0, 0x68, 0xa6, 0x51, 0xaa, 0x0c, 0x7d, 0x08, 0x3e, 0x75, 0xc4,
	0x13, 0x3c, 0xee, 0x1e, 0x0c, 0x25, 0x6e, 0x14, 0xb2, 0xb1, 0xb9, 0xc2, 0xe5, 0x3e, 0x69, 0xe6,
	0x0d, 0xe6, 0x06, 0x98, 0xda, 0x0d, 0xba, 0x66, 0xd7, 0x59, 0x57, 0x5e, 0x58, 0xbf, 0x36, 0xc0,
	0xd4, 0xc8, 0x86, 0xee, 0x2a, 0x80, 0xc9, 0x6a, 0x4e, 0x81, 0xdd, 0xb3, 0xb8, 0xd2, 0x81, 0xc6,
	0x15, 0x1d, 0x28, 0xc5, 0xa1, 0x59, 0x8e, 0x83, 0xf5, 0xf3, 0xcc, 0x03, 0x1b, 0xfb, 0x43, 0x14,
	0x47, 0x3e, 0x57, 0xe9, 0x26, 0x27, 0xec, 0x3e, 0x6c, 0xc8, 0x48, 0xa5, 0x3c, 0x4d, 0xb1, 0x09,
	0xca, 0xb3, 0x1b, 0x55, 0x11, 0x1b, 0x90, 0xe6, 0x58, 0x2a, 0xe2, 0x9b, 0x9d, 0x80, 0xa9, 0x81,
	0xa6, 0xec, 0x87, 0xb1, 0xf4, 0x1e, 0xdf, 0x80, 0x81, 0x48, 0xbc, 0x28, 0xf5, 0x28, 0xcd, 0xb2,
	0x27, 0xeb, 0x39, 0xfd, 0x82, 0x18, 0x1d, 0xf6, 0x75, 0xb7, 0xfa, 0xd4, 0xbe, 0x0c, 0xa1, 0x8d,
	0x55, 0x08, 0xfd, 0x55, 0xe8, 0x29, 0x5c, 0x4a, 0xb9, 0x9f, 0x70, 0xa1, 0x2e, 0xdb, 0x95, 0xc2,
	0x31, 0xc9, 0xac, 0x3f, 0x18, 0xd0, 0x29, 0xc0, 0x34, 0xfb, 0x21, 0xb0, 0x74, 0x21, 0xa1, 0xee,
	0x0a, 0xfc, 0x64, 0xa8, 0x74, 0xf3, 0x27, 0x28, 0xe1, 0x70, 0xfd, 0x7d, 0x38, 0x7c, 0x0d, 0x5a,
	0x0b, 0x22, 0x56, 0x0d, 0x22, 0x56, 0x72, 0x82, 0x70, 0xb3, 0x5c, 0x53, 0xb9, 0xc0, 0xfa, 0x97,
	0x01, 0xdb, 0xc5, 0x1e, 0x30, 0x5e, 0x4c, 0x64, 0x89, 0xa6, 0xcc, 0x86, 0xad, 0x72, 0x4f, 0xd6,
	0xc5, 0x6b, 0x50, 0xf1, 0x6e, 0x96, 0x9a, 0xb0, 0xaa, 0xe2, 0x3d, 0x18, 0x66, 0xad, 0x58, 0xab,
	0xd7, 0x49, 0xbd, 0xaf, 0x1b, 0xb0, 0xd2, 0xbc, 0x0f, 0x37, 0x2b, 0xe2, 0x9f, 0xe3, 0x03, 0xfa,
	0x79, 0xfd, 0xc2, 0x33, 0xa8, 0xcd, 0x77, 0x61, 0x98, 0x71, 0x07, 0xbd, 0x45, 0x5e, 0x6d, 0x90,
	0xc9, 0xa5, 0xaa, 0xf5, 0x37, 0x03, 0xfa, 0x0f, 0xe3, 0x48, 0x20, 0x3b, 0x52, 0x05, 0x5e, 0xd9,
	0x24, 0x8c, 0x2b, 0x36, 0x09, 0x02, 0x68, 0x4f, 0x9c, 0x29, 0xf6, 0x4a, 0x63, 0x02, 0xce, 0x42,
	0xe7, 0xd3, 0xc0, 0x99, 0xb7, 0xbc, 0x3b, 0xd0, 0x21, 0x4c, 0x75, 0x27, 0x7c, 0x1a, 0x46, 0x9a,
	0xe3, 0x91, 0xe8, 0x10, 0x25, 0x98, 0xe4, 0x52, 0x81, 0x47, 0xc1, 0x68, 0x4d, 0x26, 0x39, 0x09,
	0x8e, 0xa2, 0xc0, 0xfa, 0x9d, 0x01, 0x83, 0xec, 0x0e, 0xe9, 0x3c, 0x8e, 0x52, 0xbe, 0xaa, 0xe9,
	0x1a, 0xab, 0x9a, 0xae, 0x05, 0x2d, 0x8e, 0xa4, 0x5c, 0xa5, 0x51, 0x57, 0xa7, 0x11, 0xca, 0x1c,
	0xb9, 0xc4, 0xbe, 0x05, 0x6b, 0x92, 0x57, 0x28, 0x8c, 0xd8, 0xac, 0xa2, 0x6f, 0x4a, 0xc5, 0xfa,
	0x5f, 0x03, 0xd8, 0x43, 0x8a, 0x0d, 0xf5, 0x4c, 0x1d, 0xdc, 0xc7, 0xa0, 0xb8, 0x89, 0xfb, 0xf9,
	0xc8, 0xe0, 0x60, 0xb2, 0xc4, 0x41, 0x7e, 0x06, 0x23, 0x95, 0x16, 0x9a, 0x19, 0x65, 0xa9, 0xa9,
	0xee, 0x70, 0xbb, 0xc2, 0x60, 0x9e, 0xbf, 0xce, 0xb6, 0xa8, 0xce, 0xeb, 0xef, 0x01, 0xe4, 0x5c,
	0x4b, 0xdd, 0x74, 0x05, 0x03, 0x6c, 0x67, 0x34, 0x6b, 0x05, 0x43, 0x6b, 0x7e, 0x0e, 0x86, 0xf6,
	0x49, 0x05, 0xc7, 0x35, 0x56, 0x71, 0xdc, 0xe3, 0xda, 0x32, 0xcb, 0xdd, 0x2f, 0xb3, 0x5c, 0xa3,
	0x82, 0xe5, 0x1e, 0xd7, 0xca, 0x3c, 0x37, 0x87, 0xb5, 0xf5, 0x8a, 0xf7, 0x94, 0x40, 0x58, 0xd8,
	0x63, 0x2f, 0xe7, 0xb1, 0xb9, 0x9c, 0xc7, 0x87, 0x26, 0xac, 0x49, 0x65, 0xeb, 0x2f, 0x75, 0xd8,
	0x2c, 0x3d, 0xff, 0x17, 0xcc, 0xcb, 0xaf, 0x5d, 0x92, 0x97, 0xc7, 0x35, 0x9d, 0x99, 0x47, 0xd0,
	0x43, 0xca, 0xea, 0x26, 0xea, 0x18, 0xf5, 0x6c, 0x3b, 0x3a, 0xf0, 0x17, 0x1d, 0x79, 0xe4, 0x09,
	0xef, 0xb8, 0xe6, 0x74, 0x89, 0xf3, 0x6a, 0xe7, 0x7e, 0x04, 0x9d, 0xd9, 0x41, 0x6e, 0xa4, 0x59,
	0xca, 0xcb, 0x0a, 0x23, 0x14, 0x52, 0x98, 0x1d, 0x94, 0x0c, 0xd8, 0xb9, 0x81, 0xd6, 0x7b, 0x0d,
	0xd8, 0x64, 0xc0, 0xd6, 0xf3, 0xc3, 0x16, 0x34, 0xf0, 0x2f, 0xf2, 0xb7, 0xe1, 0xfa, 0x0a, 0x9f,
	0x11, 0x5f, 0x88, 0xc4, 0xcb, 0x4e, 0x44, 0x63, 0xeb, 0x08, 0xb6, 0x2a, 0xbd, 0xc3, 0x06, 0x11,
	0x2f, 0x84, 0xa2, 0x23, 0xc6, 0x0a, 0x3a, 0x42, 0x1a, 0xd8, 0x55, 0xaf, 0x57, 0x9b, 0xb1, 0xad,
	0x73, 0x18, 0x92, 0xe8, 0x69, 0x98, 0xa6, 0x3a, 0xdf, 0x96, 0x20, 0xab, 0x7e, 0x39, 0x64, 0x35,
	0xca, 0x90, 0x55, 0xe6, 0xf8, 0xcd, 0x32, 0xc7, 0xb7, 0xfe, 0x6c, 0xc0, 0x46, 0xe1, 0x3c, 0x15,
	0xdb, 0x1b, 0x60, 0xa6, 0xb3, 0x58, 0xa8, 0x36, 0xdf, 0xd8, 0x6b, 0x3a, 0xeb, 0x38, 0xc7, 0x2e,
	0x5f, 0xfc, 0x73, 0x53, 0xbf, 0xd2, 0x9f, 0x9b, 0x12, 0x7d, 0x92, 0x6c, 0x53, 0xd3, 0x27, 0xf6,
	0x21, 0x34, 0xcf, 0x84, 0x98, 0xd3, 0xbf, 0xb1, 0x8e, 0xbd, 0x5d, 0x8c, 0xd7, 0x38, 0x5e, 0x24,
	0x3e, 0x3f, 0x7e, 0xf1, 0xe2, 0xe4, 0xb8, 0xe6, 0x90, 0x16, 0xa6, 0x7c, 0x4a, 0x52, 0xcb, 0x83,
	0xc1, 0x92, 0x12, 0xf2, 0xc9, 0x45, 0x32, 0xa3, 0xc8, 0xb7, 0x1d, 0x1c, 0x7e, 0xb9, 0xb0, 0x61,
	0x64, 0xfa, 0xe5, 0x2b, 0xa1, 0x41, 0x15, 0xc9, 0x34, 0x7c, 0xab, 0xbf, 0xa5, 0x80, 0x14, 0x8d,
	0xc3, 0xb7, 0x9c, 0xdd, 0x06, 0x90, 0x37, 0xa5, 0x75, 0x79, 0xa0, 0x64, 0x4c, 0xb4, 0xcc, 0xa0,
	0xc9, 0x85, 0x37, 0x55, 0xfd, 0x91, 0xc6, 0x48, 0x66, 0x66, 0x5e, 0x2a, 0xdc, 0xf3, 0x38, 0x08,
	0x4f, 0x43, 0x2e, 0x09, 0x66, 0xdb, 0xe9, 0xa2, 0xf0, 0xa9, 0x92, 0x61, 0x93, 0x95, 0xdc, 0x31,
	0xff, 0x60, 0x41, 0xb8, 0xd3, 0x76, 0xe4, 0x87, 0x9f, 0xa3, 0x4c, 0x6c, 0x3f, 0x87, 0xbe, 0x4c,
	0xac, 0x13, 0xf5, 0x9d, 0x84, 0x7d, 0x02, 0xf0, 0x98, 0x0b, 0xd5, 0xb4, 0xd8, 0x56, 0xf6, 0xff,
	0xad, 0xd8, 0x88, 0x6f, 0x6e, 0x2f, 0x8b, 0x65, 0x26, 0x58, 0x35, 0xfb, 0xbf, 0x48, 0xa4, 0xf2,
	0x54, 0x65, 0x8f, 0xc1, 0x7c, 0xcc, 0xd5, 0xe7, 0x90, 0x1b, 0x55, 0xe5, 0x26, 0x0d, 0xbe, 0x07,
	0x0f, 0xac, 0x1a, 0x7b, 0x0a, 0xc3, 0xa3, 0xd7, 0xfe, 0x19, 0xc6, 0x3b, 0x63, 0xd0, 0x97, 0x18,
	0xbc, 0x14, 0x1b, 0x2a, 0xcd, 0xd9, 0x5f, 0xd4, 0x9c, 0x6d, 0xd5, 0xec, 0x9f, 0x42, 0x8f, 0x84,
	0x59, 0x18, 0x1f, 0xa8, 0x7f, 0xa4, 0x58, 0x28, 0xec, 0x7a, 0xf1, 0x8b, 0x43, 0xa1, 0x54, 0x6f,
	0x8e, 0x2e, 0x2e, 0xe8, 0x48, 0x1e, 0x0e, 0xff, 0xf1, 0x6e, 0xc7, 0xf8, 0xe7, 0xbb, 0x1d, 0xe3,
	0xdf, 0xef, 0x76, 0x8c, 0xdf, 0xff, 0x67, 0xa7, 0x36, 0x59, 0xa3, 0x8f, 0x75, 0xdf, 0xfd, 0x7f,
	0x00, 0x00, 0x00, 0xff, 0xff, 0xe3, 0xca, 0x82, 0x94, 0xbf, 0x13, 0x00, 0x00,
}
