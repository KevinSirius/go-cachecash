// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cachecash.proto

package ccmsg

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Error struct {
	Code                 uint64   `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{0}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(m, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetCode() uint64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type PublicKey struct {
	// TODO: Add an enum for key type.
	PublicKey            []byte   `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PublicKey) Reset()         { *m = PublicKey{} }
func (m *PublicKey) String() string { return proto.CompactTextString(m) }
func (*PublicKey) ProtoMessage()    {}
func (*PublicKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{1}
}
func (m *PublicKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublicKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublicKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublicKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublicKey.Merge(m, src)
}
func (m *PublicKey) XXX_Size() int {
	return m.Size()
}
func (m *PublicKey) XXX_DiscardUnknown() {
	xxx_messageInfo_PublicKey.DiscardUnknown(m)
}

var xxx_messageInfo_PublicKey proto.InternalMessageInfo

func (m *PublicKey) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

type EscrowInfo struct {
	PublicKey          *PublicKey `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	PublisherPublicKey *PublicKey `protobuf:"bytes,2,opt,name=publisher_public_key,json=publisherPublicKey,proto3" json:"publisher_public_key,omitempty"`
	DrawDelay          uint64     `protobuf:"varint,3,opt,name=draw_delay,json=drawDelay,proto3" json:"draw_delay,omitempty"`
	ExpirationDelay    uint64     `protobuf:"varint,4,opt,name=expiration_delay,json=expirationDelay,proto3" json:"expiration_delay,omitempty"`
	StartBlock         uint64     `protobuf:"varint,5,opt,name=start_block,json=startBlock,proto3" json:"start_block,omitempty"`
	TicketsPerBlock    []*Segment `protobuf:"bytes,6,rep,name=tickets_per_block,json=ticketsPerBlock,proto3" json:"tickets_per_block,omitempty"`
	// If we are using block/transaction-index based IDs, then this field must not be part of what is actually committed
	// to the blockchain.
	// N.B.: Must be of length `common.EscrowIDSize`.
	Id                   []byte   `protobuf:"bytes,7,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EscrowInfo) Reset()         { *m = EscrowInfo{} }
func (m *EscrowInfo) String() string { return proto.CompactTextString(m) }
func (*EscrowInfo) ProtoMessage()    {}
func (*EscrowInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{2}
}
func (m *EscrowInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EscrowInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EscrowInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EscrowInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EscrowInfo.Merge(m, src)
}
func (m *EscrowInfo) XXX_Size() int {
	return m.Size()
}
func (m *EscrowInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_EscrowInfo.DiscardUnknown(m)
}

var xxx_messageInfo_EscrowInfo proto.InternalMessageInfo

func (m *EscrowInfo) GetPublicKey() *PublicKey {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *EscrowInfo) GetPublisherPublicKey() *PublicKey {
	if m != nil {
		return m.PublisherPublicKey
	}
	return nil
}

func (m *EscrowInfo) GetDrawDelay() uint64 {
	if m != nil {
		return m.DrawDelay
	}
	return 0
}

func (m *EscrowInfo) GetExpirationDelay() uint64 {
	if m != nil {
		return m.ExpirationDelay
	}
	return 0
}

func (m *EscrowInfo) GetStartBlock() uint64 {
	if m != nil {
		return m.StartBlock
	}
	return 0
}

func (m *EscrowInfo) GetTicketsPerBlock() []*Segment {
	if m != nil {
		return m.TicketsPerBlock
	}
	return nil
}

func (m *EscrowInfo) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

type Segment struct {
	Length               uint64   `protobuf:"varint,1,opt,name=length,proto3" json:"length,omitempty"`
	Value                uint64   `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Segment) Reset()         { *m = Segment{} }
func (m *Segment) String() string { return proto.CompactTextString(m) }
func (*Segment) ProtoMessage()    {}
func (*Segment) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{3}
}
func (m *Segment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Segment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Segment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Segment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Segment.Merge(m, src)
}
func (m *Segment) XXX_Size() int {
	return m.Size()
}
func (m *Segment) XXX_DiscardUnknown() {
	xxx_messageInfo_Segment.DiscardUnknown(m)
}

var xxx_messageInfo_Segment proto.InternalMessageInfo

func (m *Segment) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *Segment) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type TicketBundle struct {
	Remainder         *TicketBundleRemainder `protobuf:"bytes,1,opt,name=remainder,proto3" json:"remainder,omitempty"`
	TicketRequest     []*TicketRequest       `protobuf:"bytes,5,rep,name=ticket_request,json=ticketRequest,proto3" json:"ticket_request,omitempty"`
	TicketL1          []*TicketL1            `protobuf:"bytes,6,rep,name=ticket_l1,json=ticketL1,proto3" json:"ticket_l1,omitempty"`
	EncryptedTicketL2 []byte                 `protobuf:"bytes,10,opt,name=encrypted_ticket_l2,json=encryptedTicketL2,proto3" json:"encrypted_ticket_l2,omitempty"`
	BatchSig          *BatchSignature        `protobuf:"bytes,8,opt,name=batch_sig,json=batchSig,proto3" json:"batch_sig,omitempty"`
	BundleSignerCert  *Certificate           `protobuf:"bytes,11,opt,name=bundle_signer_cert,json=bundleSignerCert,proto3" json:"bundle_signer_cert,omitempty"`
	// This field contains connection information for the caches mentioned in the ticket requests.
	// (XXX: There's not any particularly great/specific reason why this couldn't be covered by the hash.)
	CacheInfo            []*CacheInfo    `protobuf:"bytes,9,rep,name=cache_info,json=cacheInfo,proto3" json:"cache_info,omitempty"`
	Metadata             *ObjectMetadata `protobuf:"bytes,12,opt,name=metadata,proto3" json:"metadata,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *TicketBundle) Reset()         { *m = TicketBundle{} }
func (m *TicketBundle) String() string { return proto.CompactTextString(m) }
func (*TicketBundle) ProtoMessage()    {}
func (*TicketBundle) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{4}
}
func (m *TicketBundle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TicketBundle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TicketBundle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TicketBundle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TicketBundle.Merge(m, src)
}
func (m *TicketBundle) XXX_Size() int {
	return m.Size()
}
func (m *TicketBundle) XXX_DiscardUnknown() {
	xxx_messageInfo_TicketBundle.DiscardUnknown(m)
}

var xxx_messageInfo_TicketBundle proto.InternalMessageInfo

func (m *TicketBundle) GetRemainder() *TicketBundleRemainder {
	if m != nil {
		return m.Remainder
	}
	return nil
}

func (m *TicketBundle) GetTicketRequest() []*TicketRequest {
	if m != nil {
		return m.TicketRequest
	}
	return nil
}

func (m *TicketBundle) GetTicketL1() []*TicketL1 {
	if m != nil {
		return m.TicketL1
	}
	return nil
}

func (m *TicketBundle) GetEncryptedTicketL2() []byte {
	if m != nil {
		return m.EncryptedTicketL2
	}
	return nil
}

func (m *TicketBundle) GetBatchSig() *BatchSignature {
	if m != nil {
		return m.BatchSig
	}
	return nil
}

func (m *TicketBundle) GetBundleSignerCert() *Certificate {
	if m != nil {
		return m.BundleSignerCert
	}
	return nil
}

func (m *TicketBundle) GetCacheInfo() []*CacheInfo {
	if m != nil {
		return m.CacheInfo
	}
	return nil
}

func (m *TicketBundle) GetMetadata() *ObjectMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// XXX: This needs a better name.
type TicketBundleRemainder struct {
	// XXX: Is having the request-sequence number as part of the input to the keyed PRF important?
	// TODO: Remove this in favor of the field in the ContentResponse envelope.
	RequestSequenceNo    uint64                `protobuf:"varint,2,opt,name=request_sequence_no,json=requestSequenceNo,proto3" json:"request_sequence_no,omitempty"`
	EscrowId             []byte                `protobuf:"bytes,1,opt,name=escrow_id,json=escrowId,proto3" json:"escrow_id,omitempty"`
	ObjectId             []byte                `protobuf:"bytes,3,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
	PuzzleInfo           *ColocationPuzzleInfo `protobuf:"bytes,7,opt,name=puzzle_info,json=puzzleInfo,proto3" json:"puzzle_info,omitempty"`
	ClientPublicKey      *PublicKey            `protobuf:"bytes,8,opt,name=client_public_key,json=clientPublicKey,proto3" json:"client_public_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *TicketBundleRemainder) Reset()         { *m = TicketBundleRemainder{} }
func (m *TicketBundleRemainder) String() string { return proto.CompactTextString(m) }
func (*TicketBundleRemainder) ProtoMessage()    {}
func (*TicketBundleRemainder) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{5}
}
func (m *TicketBundleRemainder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TicketBundleRemainder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TicketBundleRemainder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TicketBundleRemainder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TicketBundleRemainder.Merge(m, src)
}
func (m *TicketBundleRemainder) XXX_Size() int {
	return m.Size()
}
func (m *TicketBundleRemainder) XXX_DiscardUnknown() {
	xxx_messageInfo_TicketBundleRemainder.DiscardUnknown(m)
}

var xxx_messageInfo_TicketBundleRemainder proto.InternalMessageInfo

func (m *TicketBundleRemainder) GetRequestSequenceNo() uint64 {
	if m != nil {
		return m.RequestSequenceNo
	}
	return 0
}

func (m *TicketBundleRemainder) GetEscrowId() []byte {
	if m != nil {
		return m.EscrowId
	}
	return nil
}

func (m *TicketBundleRemainder) GetObjectId() []byte {
	if m != nil {
		return m.ObjectId
	}
	return nil
}

func (m *TicketBundleRemainder) GetPuzzleInfo() *ColocationPuzzleInfo {
	if m != nil {
		return m.PuzzleInfo
	}
	return nil
}

func (m *TicketBundleRemainder) GetClientPublicKey() *PublicKey {
	if m != nil {
		return m.ClientPublicKey
	}
	return nil
}

type CacheInfo struct {
	Addr                 *NetworkAddress `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CacheInfo) Reset()         { *m = CacheInfo{} }
func (m *CacheInfo) String() string { return proto.CompactTextString(m) }
func (*CacheInfo) ProtoMessage()    {}
func (*CacheInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{6}
}
func (m *CacheInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CacheInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CacheInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheInfo.Merge(m, src)
}
func (m *CacheInfo) XXX_Size() int {
	return m.Size()
}
func (m *CacheInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CacheInfo proto.InternalMessageInfo

func (m *CacheInfo) GetAddr() *NetworkAddress {
	if m != nil {
		return m.Addr
	}
	return nil
}

// XXX: Is this a good name if this message includes a port number?
type NetworkAddress struct {
	// XXX: Or, we could represent this as an AF_* constant and a []byte addr.
	Inetaddr             []byte   `protobuf:"bytes,1,opt,name=inetaddr,proto3" json:"inetaddr,omitempty"`
	Inet6Addr            []byte   `protobuf:"bytes,2,opt,name=inet6addr,proto3" json:"inet6addr,omitempty"`
	Port                 uint32   `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkAddress) Reset()         { *m = NetworkAddress{} }
func (m *NetworkAddress) String() string { return proto.CompactTextString(m) }
func (*NetworkAddress) ProtoMessage()    {}
func (*NetworkAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{7}
}
func (m *NetworkAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkAddress.Merge(m, src)
}
func (m *NetworkAddress) XXX_Size() int {
	return m.Size()
}
func (m *NetworkAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkAddress.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkAddress proto.InternalMessageInfo

func (m *NetworkAddress) GetInetaddr() []byte {
	if m != nil {
		return m.Inetaddr
	}
	return nil
}

func (m *NetworkAddress) GetInet6Addr() []byte {
	if m != nil {
		return m.Inet6Addr
	}
	return nil
}

func (m *NetworkAddress) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type ColocationPuzzleInfo struct {
	Goal []byte `protobuf:"bytes,2,opt,name=goal,proto3" json:"goal,omitempty"`
	// THese fields come from the `colocationpuzzle.Parameters` struct.
	Rounds               uint32   `protobuf:"varint,1,opt,name=rounds,proto3" json:"rounds,omitempty"`
	StartOffset          uint64   `protobuf:"varint,3,opt,name=start_offset,json=startOffset,proto3" json:"start_offset,omitempty"`
	StartRange           uint64   `protobuf:"varint,4,opt,name=start_range,json=startRange,proto3" json:"start_range,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ColocationPuzzleInfo) Reset()         { *m = ColocationPuzzleInfo{} }
func (m *ColocationPuzzleInfo) String() string { return proto.CompactTextString(m) }
func (*ColocationPuzzleInfo) ProtoMessage()    {}
func (*ColocationPuzzleInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{8}
}
func (m *ColocationPuzzleInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColocationPuzzleInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColocationPuzzleInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColocationPuzzleInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColocationPuzzleInfo.Merge(m, src)
}
func (m *ColocationPuzzleInfo) XXX_Size() int {
	return m.Size()
}
func (m *ColocationPuzzleInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ColocationPuzzleInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ColocationPuzzleInfo proto.InternalMessageInfo

func (m *ColocationPuzzleInfo) GetGoal() []byte {
	if m != nil {
		return m.Goal
	}
	return nil
}

func (m *ColocationPuzzleInfo) GetRounds() uint32 {
	if m != nil {
		return m.Rounds
	}
	return 0
}

func (m *ColocationPuzzleInfo) GetStartOffset() uint64 {
	if m != nil {
		return m.StartOffset
	}
	return 0
}

func (m *ColocationPuzzleInfo) GetStartRange() uint64 {
	if m != nil {
		return m.StartRange
	}
	return 0
}

type BatchSignature struct {
	PathDirection        []bool     `protobuf:"varint,2,rep,packed,name=path_direction,json=pathDirection,proto3" json:"path_direction,omitempty"`
	PathDigest           [][]byte   `protobuf:"bytes,3,rep,name=path_digest,json=pathDigest,proto3" json:"path_digest,omitempty"`
	RootSignature        []byte     `protobuf:"bytes,4,opt,name=root_signature,json=rootSignature,proto3" json:"root_signature,omitempty"`
	SigningKey           *PublicKey `protobuf:"bytes,5,opt,name=signing_key,json=signingKey,proto3" json:"signing_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *BatchSignature) Reset()         { *m = BatchSignature{} }
func (m *BatchSignature) String() string { return proto.CompactTextString(m) }
func (*BatchSignature) ProtoMessage()    {}
func (*BatchSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{9}
}
func (m *BatchSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSignature.Merge(m, src)
}
func (m *BatchSignature) XXX_Size() int {
	return m.Size()
}
func (m *BatchSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSignature.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSignature proto.InternalMessageInfo

func (m *BatchSignature) GetPathDirection() []bool {
	if m != nil {
		return m.PathDirection
	}
	return nil
}

func (m *BatchSignature) GetPathDigest() [][]byte {
	if m != nil {
		return m.PathDigest
	}
	return nil
}

func (m *BatchSignature) GetRootSignature() []byte {
	if m != nil {
		return m.RootSignature
	}
	return nil
}

func (m *BatchSignature) GetSigningKey() *PublicKey {
	if m != nil {
		return m.SigningKey
	}
	return nil
}

type BlockKey struct {
	// TODO: Add an enum for key type.
	Key                  []byte   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockKey) Reset()         { *m = BlockKey{} }
func (m *BlockKey) String() string { return proto.CompactTextString(m) }
func (*BlockKey) ProtoMessage()    {}
func (*BlockKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{10}
}
func (m *BlockKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockKey.Merge(m, src)
}
func (m *BlockKey) XXX_Size() int {
	return m.Size()
}
func (m *BlockKey) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockKey.DiscardUnknown(m)
}

var xxx_messageInfo_BlockKey proto.InternalMessageInfo

func (m *BlockKey) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

// This is what the client will present to the cache.  It's not individually signed, but it's covered by the batch
// signature.
type TicketRequest struct {
	BlockIdx             uint64     `protobuf:"varint,2,opt,name=block_idx,json=blockIdx,proto3" json:"block_idx,omitempty"`
	InnerKey             *BlockKey  `protobuf:"bytes,3,opt,name=inner_key,json=innerKey,proto3" json:"inner_key,omitempty"`
	BlockId              []byte     `protobuf:"bytes,5,opt,name=block_id,json=blockId,proto3" json:"block_id,omitempty"`
	CachePublicKey       *PublicKey `protobuf:"bytes,4,opt,name=cache_public_key,json=cachePublicKey,proto3" json:"cache_public_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *TicketRequest) Reset()         { *m = TicketRequest{} }
func (m *TicketRequest) String() string { return proto.CompactTextString(m) }
func (*TicketRequest) ProtoMessage()    {}
func (*TicketRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{11}
}
func (m *TicketRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TicketRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TicketRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TicketRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TicketRequest.Merge(m, src)
}
func (m *TicketRequest) XXX_Size() int {
	return m.Size()
}
func (m *TicketRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TicketRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TicketRequest proto.InternalMessageInfo

func (m *TicketRequest) GetBlockIdx() uint64 {
	if m != nil {
		return m.BlockIdx
	}
	return 0
}

func (m *TicketRequest) GetInnerKey() *BlockKey {
	if m != nil {
		return m.InnerKey
	}
	return nil
}

func (m *TicketRequest) GetBlockId() []byte {
	if m != nil {
		return m.BlockId
	}
	return nil
}

func (m *TicketRequest) GetCachePublicKey() *PublicKey {
	if m != nil {
		return m.CachePublicKey
	}
	return nil
}

// XXX: I suspect that the ticket number may be the only thing here's that's actually important, since it could be used
// in proofs of double-spending (on the CP's behalf).
type TicketL1 struct {
	// PublicKey escrow_public_key = 1;
	TicketNo uint64 `protobuf:"varint,2,opt,name=ticket_no,json=ticketNo,proto3" json:"ticket_no,omitempty"`
	// XXX: This is *also* duplicated between TicketL1 and TicketRequest.
	CachePublicKey *PublicKey `protobuf:"bytes,3,opt,name=cache_public_key,json=cachePublicKey,proto3" json:"cache_public_key,omitempty"`
	// XXX: This is duplicated between this message and the TicketRequest, which could probably be avoided.  However,
	// the cache does need to be able to work out which block-index the L1 ticket corresponds to so that it can derive
	// the right outer key to give to the client.
	BlockIdx             uint64   `protobuf:"varint,4,opt,name=block_idx,json=blockIdx,proto3" json:"block_idx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TicketL1) Reset()         { *m = TicketL1{} }
func (m *TicketL1) String() string { return proto.CompactTextString(m) }
func (*TicketL1) ProtoMessage()    {}
func (*TicketL1) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{12}
}
func (m *TicketL1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TicketL1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TicketL1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TicketL1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TicketL1.Merge(m, src)
}
func (m *TicketL1) XXX_Size() int {
	return m.Size()
}
func (m *TicketL1) XXX_DiscardUnknown() {
	xxx_messageInfo_TicketL1.DiscardUnknown(m)
}

var xxx_messageInfo_TicketL1 proto.InternalMessageInfo

func (m *TicketL1) GetTicketNo() uint64 {
	if m != nil {
		return m.TicketNo
	}
	return 0
}

func (m *TicketL1) GetCachePublicKey() *PublicKey {
	if m != nil {
		return m.CachePublicKey
	}
	return nil
}

func (m *TicketL1) GetBlockIdx() uint64 {
	if m != nil {
		return m.BlockIdx
	}
	return 0
}

// By the time the L2 ticket is decrypted by the client, all of the caches must have provided data and outer encryption
// keys to the client; these are the inputs to the colocation puzzle, whose output is used to decrypt the L2 ticket.
type TicketL2 struct {
	// XXX: It seems like it might not be too hard for a cache to guess the plaintext L2 ticket that corresponds to the
	// hash that it knows.  This would be harder if we didn't tell each cache the other caches' public keys *and*
	// included all of those keys in the hashed ticket L2.  However, it still seems as though the group of hashes trying
	// to claim the ticket could find each other when they all show up to try to claim their win.
	Nonce []byte `protobuf:"bytes,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// The inner session keys are here in order to force the client to solve the colocation puzzle (which is required in
	// order to decrypt the L2 ticket).
	InnerSessionKey      []*BlockKey `protobuf:"bytes,3,rep,name=inner_session_key,json=innerSessionKey,proto3" json:"inner_session_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *TicketL2) Reset()         { *m = TicketL2{} }
func (m *TicketL2) String() string { return proto.CompactTextString(m) }
func (*TicketL2) ProtoMessage()    {}
func (*TicketL2) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{13}
}
func (m *TicketL2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TicketL2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TicketL2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TicketL2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TicketL2.Merge(m, src)
}
func (m *TicketL2) XXX_Size() int {
	return m.Size()
}
func (m *TicketL2) XXX_DiscardUnknown() {
	xxx_messageInfo_TicketL2.DiscardUnknown(m)
}

var xxx_messageInfo_TicketL2 proto.InternalMessageInfo

func (m *TicketL2) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *TicketL2) GetInnerSessionKey() []*BlockKey {
	if m != nil {
		return m.InnerSessionKey
	}
	return nil
}

type TicketL2Info struct {
	EncryptedTicketL2    []byte   `protobuf:"bytes,1,opt,name=encrypted_ticket_l2,json=encryptedTicketL2,proto3" json:"encrypted_ticket_l2,omitempty"`
	PuzzleSecret         []byte   `protobuf:"bytes,2,opt,name=puzzle_secret,json=puzzleSecret,proto3" json:"puzzle_secret,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TicketL2Info) Reset()         { *m = TicketL2Info{} }
func (m *TicketL2Info) String() string { return proto.CompactTextString(m) }
func (*TicketL2Info) ProtoMessage()    {}
func (*TicketL2Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{14}
}
func (m *TicketL2Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TicketL2Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TicketL2Info.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TicketL2Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TicketL2Info.Merge(m, src)
}
func (m *TicketL2Info) XXX_Size() int {
	return m.Size()
}
func (m *TicketL2Info) XXX_DiscardUnknown() {
	xxx_messageInfo_TicketL2Info.DiscardUnknown(m)
}

var xxx_messageInfo_TicketL2Info proto.InternalMessageInfo

func (m *TicketL2Info) GetEncryptedTicketL2() []byte {
	if m != nil {
		return m.EncryptedTicketL2
	}
	return nil
}

func (m *TicketL2Info) GetPuzzleSecret() []byte {
	if m != nil {
		return m.PuzzleSecret
	}
	return nil
}

// Signed by escrow key; ensures that the key that produced the batch signature is authorized.
type Certificate struct {
	SubjectPublicKey     *PublicKey `protobuf:"bytes,1,opt,name=subject_public_key,json=subjectPublicKey,proto3" json:"subject_public_key,omitempty"`
	EscrowId             []byte     `protobuf:"bytes,2,opt,name=escrow_id,json=escrowId,proto3" json:"escrow_id,omitempty"`
	Usage                string     `protobuf:"bytes,3,opt,name=usage,proto3" json:"usage,omitempty"`
	Signature            []byte     `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Certificate) Reset()         { *m = Certificate{} }
func (m *Certificate) String() string { return proto.CompactTextString(m) }
func (*Certificate) ProtoMessage()    {}
func (*Certificate) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{15}
}
func (m *Certificate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Certificate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Certificate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Certificate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Certificate.Merge(m, src)
}
func (m *Certificate) XXX_Size() int {
	return m.Size()
}
func (m *Certificate) XXX_DiscardUnknown() {
	xxx_messageInfo_Certificate.DiscardUnknown(m)
}

var xxx_messageInfo_Certificate proto.InternalMessageInfo

func (m *Certificate) GetSubjectPublicKey() *PublicKey {
	if m != nil {
		return m.SubjectPublicKey
	}
	return nil
}

func (m *Certificate) GetEscrowId() []byte {
	if m != nil {
		return m.EscrowId
	}
	return nil
}

func (m *Certificate) GetUsage() string {
	if m != nil {
		return m.Usage
	}
	return ""
}

func (m *Certificate) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// Containss enough data to let a cache recompute/verify the ticket-bundle digest.
type TicketBundleSubdigests struct {
	TicketRequestDigest     [][]byte `protobuf:"bytes,1,rep,name=ticket_request_digest,json=ticketRequestDigest,proto3" json:"ticket_request_digest,omitempty"`
	TicketL1Digest          [][]byte `protobuf:"bytes,2,rep,name=ticket_l1_digest,json=ticketL1Digest,proto3" json:"ticket_l1_digest,omitempty"`
	EncryptedTicketL2Digest []byte   `protobuf:"bytes,3,opt,name=encrypted_ticket_l2_digest,json=encryptedTicketL2Digest,proto3" json:"encrypted_ticket_l2_digest,omitempty"`
	RemainderDigest         []byte   `protobuf:"bytes,4,opt,name=remainder_digest,json=remainderDigest,proto3" json:"remainder_digest,omitempty"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *TicketBundleSubdigests) Reset()         { *m = TicketBundleSubdigests{} }
func (m *TicketBundleSubdigests) String() string { return proto.CompactTextString(m) }
func (*TicketBundleSubdigests) ProtoMessage()    {}
func (*TicketBundleSubdigests) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{16}
}
func (m *TicketBundleSubdigests) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TicketBundleSubdigests) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TicketBundleSubdigests.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TicketBundleSubdigests) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TicketBundleSubdigests.Merge(m, src)
}
func (m *TicketBundleSubdigests) XXX_Size() int {
	return m.Size()
}
func (m *TicketBundleSubdigests) XXX_DiscardUnknown() {
	xxx_messageInfo_TicketBundleSubdigests.DiscardUnknown(m)
}

var xxx_messageInfo_TicketBundleSubdigests proto.InternalMessageInfo

func (m *TicketBundleSubdigests) GetTicketRequestDigest() [][]byte {
	if m != nil {
		return m.TicketRequestDigest
	}
	return nil
}

func (m *TicketBundleSubdigests) GetTicketL1Digest() [][]byte {
	if m != nil {
		return m.TicketL1Digest
	}
	return nil
}

func (m *TicketBundleSubdigests) GetEncryptedTicketL2Digest() []byte {
	if m != nil {
		return m.EncryptedTicketL2Digest
	}
	return nil
}

func (m *TicketBundleSubdigests) GetRemainderDigest() []byte {
	if m != nil {
		return m.RemainderDigest
	}
	return nil
}

// Client-to-publisher
type ContentRequest struct {
	// TODO: This does not actually need to be repeated with each request, if we are using a connection-oriented
	// transport.
	ClientPublicKey *PublicKey `protobuf:"bytes,1,opt,name=client_public_key,json=clientPublicKey,proto3" json:"client_public_key,omitempty"`
	Path            string     `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// In bytes; the publisher can map that to blocks however it pleases.  range_begin is inclusive and range_end is
	// exclusive.  A value of zero for range_end means "the end of the object".
	RangeBegin           uint64   `protobuf:"varint,5,opt,name=range_begin,json=rangeBegin,proto3" json:"range_begin,omitempty"`
	RangeEnd             uint64   `protobuf:"varint,6,opt,name=range_end,json=rangeEnd,proto3" json:"range_end,omitempty"`
	SequenceNo           uint64   `protobuf:"varint,4,opt,name=sequence_no,json=sequenceNo,proto3" json:"sequence_no,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ContentRequest) Reset()         { *m = ContentRequest{} }
func (m *ContentRequest) String() string { return proto.CompactTextString(m) }
func (*ContentRequest) ProtoMessage()    {}
func (*ContentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{17}
}
func (m *ContentRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContentRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContentRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContentRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContentRequest.Merge(m, src)
}
func (m *ContentRequest) XXX_Size() int {
	return m.Size()
}
func (m *ContentRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ContentRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ContentRequest proto.InternalMessageInfo

func (m *ContentRequest) GetClientPublicKey() *PublicKey {
	if m != nil {
		return m.ClientPublicKey
	}
	return nil
}

func (m *ContentRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *ContentRequest) GetRangeBegin() uint64 {
	if m != nil {
		return m.RangeBegin
	}
	return 0
}

func (m *ContentRequest) GetRangeEnd() uint64 {
	if m != nil {
		return m.RangeEnd
	}
	return 0
}

func (m *ContentRequest) GetSequenceNo() uint64 {
	if m != nil {
		return m.SequenceNo
	}
	return 0
}

// Response to a ContentRequest.
type ContentResponse struct {
	// Identifies the request that this message is a response to.
	RequestSequenceNo uint64 `protobuf:"varint,1,opt,name=request_sequence_no,json=requestSequenceNo,proto3" json:"request_sequence_no,omitempty"`
	// Exactly one of these fields may be present.
	Error                *Error        `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Bundle               *TicketBundle `protobuf:"bytes,3,opt,name=bundle,proto3" json:"bundle,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ContentResponse) Reset()         { *m = ContentResponse{} }
func (m *ContentResponse) String() string { return proto.CompactTextString(m) }
func (*ContentResponse) ProtoMessage()    {}
func (*ContentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{18}
}
func (m *ContentResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContentResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContentResponse.Merge(m, src)
}
func (m *ContentResponse) XXX_Size() int {
	return m.Size()
}
func (m *ContentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ContentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ContentResponse proto.InternalMessageInfo

func (m *ContentResponse) GetRequestSequenceNo() uint64 {
	if m != nil {
		return m.RequestSequenceNo
	}
	return 0
}

func (m *ContentResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ContentResponse) GetBundle() *TicketBundle {
	if m != nil {
		return m.Bundle
	}
	return nil
}

type ClientCacheRequest struct {
	SequenceNo      uint64                 `protobuf:"varint,8,opt,name=sequence_no,json=sequenceNo,proto3" json:"sequence_no,omitempty"`
	BundleRemainder *TicketBundleRemainder `protobuf:"bytes,1,opt,name=bundle_remainder,json=bundleRemainder,proto3" json:"bundle_remainder,omitempty"`
	// Types that are valid to be assigned to Ticket:
	//	*ClientCacheRequest_TicketRequest
	//	*ClientCacheRequest_TicketL1
	//	*ClientCacheRequest_TicketL2
	Ticket isClientCacheRequest_Ticket `protobuf_oneof:"ticket"`
	// Together, these fields allow the cache to verify that the request is authorized.
	TicketBundleSubdigests *TicketBundleSubdigests `protobuf:"bytes,2,opt,name=ticket_bundle_subdigests,json=ticketBundleSubdigests,proto3" json:"ticket_bundle_subdigests,omitempty"`
	BundleSig              *BatchSignature         `protobuf:"bytes,3,opt,name=bundle_sig,json=bundleSig,proto3" json:"bundle_sig,omitempty"`
	BundleSignerCert       *Certificate            `protobuf:"bytes,4,opt,name=bundle_signer_cert,json=bundleSignerCert,proto3" json:"bundle_signer_cert,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                `json:"-"`
	XXX_unrecognized       []byte                  `json:"-"`
	XXX_sizecache          int32                   `json:"-"`
}

func (m *ClientCacheRequest) Reset()         { *m = ClientCacheRequest{} }
func (m *ClientCacheRequest) String() string { return proto.CompactTextString(m) }
func (*ClientCacheRequest) ProtoMessage()    {}
func (*ClientCacheRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{19}
}
func (m *ClientCacheRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientCacheRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientCacheRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientCacheRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientCacheRequest.Merge(m, src)
}
func (m *ClientCacheRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClientCacheRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientCacheRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClientCacheRequest proto.InternalMessageInfo

type isClientCacheRequest_Ticket interface {
	isClientCacheRequest_Ticket()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClientCacheRequest_TicketRequest struct {
	TicketRequest *TicketRequest `protobuf:"bytes,5,opt,name=ticket_request,json=ticketRequest,proto3,oneof"`
}
type ClientCacheRequest_TicketL1 struct {
	TicketL1 *TicketL1 `protobuf:"bytes,6,opt,name=ticket_l1,json=ticketL1,proto3,oneof"`
}
type ClientCacheRequest_TicketL2 struct {
	TicketL2 *TicketL2Info `protobuf:"bytes,7,opt,name=ticket_l2,json=ticketL2,proto3,oneof"`
}

func (*ClientCacheRequest_TicketRequest) isClientCacheRequest_Ticket() {}
func (*ClientCacheRequest_TicketL1) isClientCacheRequest_Ticket()      {}
func (*ClientCacheRequest_TicketL2) isClientCacheRequest_Ticket()      {}

func (m *ClientCacheRequest) GetTicket() isClientCacheRequest_Ticket {
	if m != nil {
		return m.Ticket
	}
	return nil
}

func (m *ClientCacheRequest) GetSequenceNo() uint64 {
	if m != nil {
		return m.SequenceNo
	}
	return 0
}

func (m *ClientCacheRequest) GetBundleRemainder() *TicketBundleRemainder {
	if m != nil {
		return m.BundleRemainder
	}
	return nil
}

func (m *ClientCacheRequest) GetTicketRequest() *TicketRequest {
	if x, ok := m.GetTicket().(*ClientCacheRequest_TicketRequest); ok {
		return x.TicketRequest
	}
	return nil
}

func (m *ClientCacheRequest) GetTicketL1() *TicketL1 {
	if x, ok := m.GetTicket().(*ClientCacheRequest_TicketL1); ok {
		return x.TicketL1
	}
	return nil
}

func (m *ClientCacheRequest) GetTicketL2() *TicketL2Info {
	if x, ok := m.GetTicket().(*ClientCacheRequest_TicketL2); ok {
		return x.TicketL2
	}
	return nil
}

func (m *ClientCacheRequest) GetTicketBundleSubdigests() *TicketBundleSubdigests {
	if m != nil {
		return m.TicketBundleSubdigests
	}
	return nil
}

func (m *ClientCacheRequest) GetBundleSig() *BatchSignature {
	if m != nil {
		return m.BundleSig
	}
	return nil
}

func (m *ClientCacheRequest) GetBundleSignerCert() *Certificate {
	if m != nil {
		return m.BundleSignerCert
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ClientCacheRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ClientCacheRequest_OneofMarshaler, _ClientCacheRequest_OneofUnmarshaler, _ClientCacheRequest_OneofSizer, []interface{}{
		(*ClientCacheRequest_TicketRequest)(nil),
		(*ClientCacheRequest_TicketL1)(nil),
		(*ClientCacheRequest_TicketL2)(nil),
	}
}

func _ClientCacheRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ClientCacheRequest)
	// ticket
	switch x := m.Ticket.(type) {
	case *ClientCacheRequest_TicketRequest:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TicketRequest); err != nil {
			return err
		}
	case *ClientCacheRequest_TicketL1:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TicketL1); err != nil {
			return err
		}
	case *ClientCacheRequest_TicketL2:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TicketL2); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ClientCacheRequest.Ticket has unexpected type %T", x)
	}
	return nil
}

func _ClientCacheRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ClientCacheRequest)
	switch tag {
	case 5: // ticket.ticket_request
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TicketRequest)
		err := b.DecodeMessage(msg)
		m.Ticket = &ClientCacheRequest_TicketRequest{msg}
		return true, err
	case 6: // ticket.ticket_l1
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TicketL1)
		err := b.DecodeMessage(msg)
		m.Ticket = &ClientCacheRequest_TicketL1{msg}
		return true, err
	case 7: // ticket.ticket_l2
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TicketL2Info)
		err := b.DecodeMessage(msg)
		m.Ticket = &ClientCacheRequest_TicketL2{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ClientCacheRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ClientCacheRequest)
	// ticket
	switch x := m.Ticket.(type) {
	case *ClientCacheRequest_TicketRequest:
		s := proto.Size(x.TicketRequest)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientCacheRequest_TicketL1:
		s := proto.Size(x.TicketL1)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientCacheRequest_TicketL2:
		s := proto.Size(x.TicketL2)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// XXX: Remove me!  This is not used over the wire; it's used only in the `cache` package.
type ClientCacheResponse struct {
	// Identifies the request that this message is a response to.
	RequestSequenceNo uint64 `protobuf:"varint,1,opt,name=request_sequence_no,json=requestSequenceNo,proto3" json:"request_sequence_no,omitempty"`
	// Types that are valid to be assigned to Msg:
	//	*ClientCacheResponse_Error
	//	*ClientCacheResponse_DataResponse
	//	*ClientCacheResponse_L1Response
	//	*ClientCacheResponse_L2Response
	Msg                  isClientCacheResponse_Msg `protobuf_oneof:"msg"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *ClientCacheResponse) Reset()         { *m = ClientCacheResponse{} }
func (m *ClientCacheResponse) String() string { return proto.CompactTextString(m) }
func (*ClientCacheResponse) ProtoMessage()    {}
func (*ClientCacheResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{20}
}
func (m *ClientCacheResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientCacheResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientCacheResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientCacheResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientCacheResponse.Merge(m, src)
}
func (m *ClientCacheResponse) XXX_Size() int {
	return m.Size()
}
func (m *ClientCacheResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientCacheResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClientCacheResponse proto.InternalMessageInfo

type isClientCacheResponse_Msg interface {
	isClientCacheResponse_Msg()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClientCacheResponse_Error struct {
	Error *Error `protobuf:"bytes,2,opt,name=error,proto3,oneof"`
}
type ClientCacheResponse_DataResponse struct {
	DataResponse *ClientCacheResponseData `protobuf:"bytes,3,opt,name=data_response,json=dataResponse,proto3,oneof"`
}
type ClientCacheResponse_L1Response struct {
	L1Response *ClientCacheResponseL1 `protobuf:"bytes,4,opt,name=l1_response,json=l1Response,proto3,oneof"`
}
type ClientCacheResponse_L2Response struct {
	L2Response *ClientCacheResponseL2 `protobuf:"bytes,5,opt,name=l2_response,json=l2Response,proto3,oneof"`
}

func (*ClientCacheResponse_Error) isClientCacheResponse_Msg()        {}
func (*ClientCacheResponse_DataResponse) isClientCacheResponse_Msg() {}
func (*ClientCacheResponse_L1Response) isClientCacheResponse_Msg()   {}
func (*ClientCacheResponse_L2Response) isClientCacheResponse_Msg()   {}

func (m *ClientCacheResponse) GetMsg() isClientCacheResponse_Msg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *ClientCacheResponse) GetRequestSequenceNo() uint64 {
	if m != nil {
		return m.RequestSequenceNo
	}
	return 0
}

func (m *ClientCacheResponse) GetError() *Error {
	if x, ok := m.GetMsg().(*ClientCacheResponse_Error); ok {
		return x.Error
	}
	return nil
}

func (m *ClientCacheResponse) GetDataResponse() *ClientCacheResponseData {
	if x, ok := m.GetMsg().(*ClientCacheResponse_DataResponse); ok {
		return x.DataResponse
	}
	return nil
}

func (m *ClientCacheResponse) GetL1Response() *ClientCacheResponseL1 {
	if x, ok := m.GetMsg().(*ClientCacheResponse_L1Response); ok {
		return x.L1Response
	}
	return nil
}

func (m *ClientCacheResponse) GetL2Response() *ClientCacheResponseL2 {
	if x, ok := m.GetMsg().(*ClientCacheResponse_L2Response); ok {
		return x.L2Response
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ClientCacheResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ClientCacheResponse_OneofMarshaler, _ClientCacheResponse_OneofUnmarshaler, _ClientCacheResponse_OneofSizer, []interface{}{
		(*ClientCacheResponse_Error)(nil),
		(*ClientCacheResponse_DataResponse)(nil),
		(*ClientCacheResponse_L1Response)(nil),
		(*ClientCacheResponse_L2Response)(nil),
	}
}

func _ClientCacheResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ClientCacheResponse)
	// msg
	switch x := m.Msg.(type) {
	case *ClientCacheResponse_Error:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case *ClientCacheResponse_DataResponse:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DataResponse); err != nil {
			return err
		}
	case *ClientCacheResponse_L1Response:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L1Response); err != nil {
			return err
		}
	case *ClientCacheResponse_L2Response:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L2Response); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ClientCacheResponse.Msg has unexpected type %T", x)
	}
	return nil
}

func _ClientCacheResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ClientCacheResponse)
	switch tag {
	case 2: // msg.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Msg = &ClientCacheResponse_Error{msg}
		return true, err
	case 3: // msg.data_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientCacheResponseData)
		err := b.DecodeMessage(msg)
		m.Msg = &ClientCacheResponse_DataResponse{msg}
		return true, err
	case 4: // msg.l1_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientCacheResponseL1)
		err := b.DecodeMessage(msg)
		m.Msg = &ClientCacheResponse_L1Response{msg}
		return true, err
	case 5: // msg.l2_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientCacheResponseL2)
		err := b.DecodeMessage(msg)
		m.Msg = &ClientCacheResponse_L2Response{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ClientCacheResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ClientCacheResponse)
	// msg
	switch x := m.Msg.(type) {
	case *ClientCacheResponse_Error:
		s := proto.Size(x.Error)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientCacheResponse_DataResponse:
		s := proto.Size(x.DataResponse)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientCacheResponse_L1Response:
		s := proto.Size(x.L1Response)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientCacheResponse_L2Response:
		s := proto.Size(x.L2Response)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ClientCacheResponseData struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientCacheResponseData) Reset()         { *m = ClientCacheResponseData{} }
func (m *ClientCacheResponseData) String() string { return proto.CompactTextString(m) }
func (*ClientCacheResponseData) ProtoMessage()    {}
func (*ClientCacheResponseData) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{21}
}
func (m *ClientCacheResponseData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientCacheResponseData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientCacheResponseData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientCacheResponseData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientCacheResponseData.Merge(m, src)
}
func (m *ClientCacheResponseData) XXX_Size() int {
	return m.Size()
}
func (m *ClientCacheResponseData) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientCacheResponseData.DiscardUnknown(m)
}

var xxx_messageInfo_ClientCacheResponseData proto.InternalMessageInfo

func (m *ClientCacheResponseData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type ClientCacheResponseL1 struct {
	// contains the outer key
	OuterKey             *BlockKey `protobuf:"bytes,1,opt,name=outer_key,json=outerKey,proto3" json:"outer_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ClientCacheResponseL1) Reset()         { *m = ClientCacheResponseL1{} }
func (m *ClientCacheResponseL1) String() string { return proto.CompactTextString(m) }
func (*ClientCacheResponseL1) ProtoMessage()    {}
func (*ClientCacheResponseL1) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{22}
}
func (m *ClientCacheResponseL1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientCacheResponseL1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientCacheResponseL1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientCacheResponseL1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientCacheResponseL1.Merge(m, src)
}
func (m *ClientCacheResponseL1) XXX_Size() int {
	return m.Size()
}
func (m *ClientCacheResponseL1) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientCacheResponseL1.DiscardUnknown(m)
}

var xxx_messageInfo_ClientCacheResponseL1 proto.InternalMessageInfo

func (m *ClientCacheResponseL1) GetOuterKey() *BlockKey {
	if m != nil {
		return m.OuterKey
	}
	return nil
}

type ClientCacheResponseL2 struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientCacheResponseL2) Reset()         { *m = ClientCacheResponseL2{} }
func (m *ClientCacheResponseL2) String() string { return proto.CompactTextString(m) }
func (*ClientCacheResponseL2) ProtoMessage()    {}
func (*ClientCacheResponseL2) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{23}
}
func (m *ClientCacheResponseL2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientCacheResponseL2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientCacheResponseL2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientCacheResponseL2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientCacheResponseL2.Merge(m, src)
}
func (m *ClientCacheResponseL2) XXX_Size() int {
	return m.Size()
}
func (m *ClientCacheResponseL2) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientCacheResponseL2.DiscardUnknown(m)
}

var xxx_messageInfo_ClientCacheResponseL2 proto.InternalMessageInfo

// XXX: See similarities to ContentRequest.
type CacheMissRequest struct {
	// In blocks.
	// XXX: This was formerly in bytes.  Was there a good reason for that?
	RangeBegin           uint64   `protobuf:"varint,2,opt,name=range_begin,json=rangeBegin,proto3" json:"range_begin,omitempty"`
	RangeEnd             uint64   `protobuf:"varint,3,opt,name=range_end,json=rangeEnd,proto3" json:"range_end,omitempty"`
	ObjectId             []byte   `protobuf:"bytes,4,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CacheMissRequest) Reset()         { *m = CacheMissRequest{} }
func (m *CacheMissRequest) String() string { return proto.CompactTextString(m) }
func (*CacheMissRequest) ProtoMessage()    {}
func (*CacheMissRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{24}
}
func (m *CacheMissRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheMissRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CacheMissRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CacheMissRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheMissRequest.Merge(m, src)
}
func (m *CacheMissRequest) XXX_Size() int {
	return m.Size()
}
func (m *CacheMissRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheMissRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CacheMissRequest proto.InternalMessageInfo

func (m *CacheMissRequest) GetRangeBegin() uint64 {
	if m != nil {
		return m.RangeBegin
	}
	return 0
}

func (m *CacheMissRequest) GetRangeEnd() uint64 {
	if m != nil {
		return m.RangeEnd
	}
	return 0
}

func (m *CacheMissRequest) GetObjectId() []byte {
	if m != nil {
		return m.ObjectId
	}
	return nil
}

type CacheMissResponse struct {
	Metadata             *ObjectMetadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Chunks               []*Chunk        `protobuf:"bytes,2,rep,name=chunks,proto3" json:"chunks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CacheMissResponse) Reset()         { *m = CacheMissResponse{} }
func (m *CacheMissResponse) String() string { return proto.CompactTextString(m) }
func (*CacheMissResponse) ProtoMessage()    {}
func (*CacheMissResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{25}
}
func (m *CacheMissResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheMissResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CacheMissResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CacheMissResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheMissResponse.Merge(m, src)
}
func (m *CacheMissResponse) XXX_Size() int {
	return m.Size()
}
func (m *CacheMissResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheMissResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CacheMissResponse proto.InternalMessageInfo

func (m *CacheMissResponse) GetMetadata() *ObjectMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CacheMissResponse) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

type Chunk struct {
	SlotIdx uint64 `protobuf:"varint,1,opt,name=slot_idx,json=slotIdx,proto3" json:"slot_idx,omitempty"`
	// Types that are valid to be assigned to Source:
	//	*Chunk_Http
	//	*Chunk_Inline
	Source               isChunk_Source `protobuf_oneof:"source"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Chunk) Reset()         { *m = Chunk{} }
func (m *Chunk) String() string { return proto.CompactTextString(m) }
func (*Chunk) ProtoMessage()    {}
func (*Chunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{26}
}
func (m *Chunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Chunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Chunk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Chunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Chunk.Merge(m, src)
}
func (m *Chunk) XXX_Size() int {
	return m.Size()
}
func (m *Chunk) XXX_DiscardUnknown() {
	xxx_messageInfo_Chunk.DiscardUnknown(m)
}

var xxx_messageInfo_Chunk proto.InternalMessageInfo

type isChunk_Source interface {
	isChunk_Source()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Chunk_Http struct {
	Http *BlockSourceHTTP `protobuf:"bytes,10,opt,name=http,proto3,oneof"`
}
type Chunk_Inline struct {
	Inline *BlockSourceInline `protobuf:"bytes,20,opt,name=inline,proto3,oneof"`
}

func (*Chunk_Http) isChunk_Source()   {}
func (*Chunk_Inline) isChunk_Source() {}

func (m *Chunk) GetSource() isChunk_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Chunk) GetSlotIdx() uint64 {
	if m != nil {
		return m.SlotIdx
	}
	return 0
}

func (m *Chunk) GetHttp() *BlockSourceHTTP {
	if x, ok := m.GetSource().(*Chunk_Http); ok {
		return x.Http
	}
	return nil
}

func (m *Chunk) GetInline() *BlockSourceInline {
	if x, ok := m.GetSource().(*Chunk_Inline); ok {
		return x.Inline
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Chunk) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Chunk_OneofMarshaler, _Chunk_OneofUnmarshaler, _Chunk_OneofSizer, []interface{}{
		(*Chunk_Http)(nil),
		(*Chunk_Inline)(nil),
	}
}

func _Chunk_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Chunk)
	// source
	switch x := m.Source.(type) {
	case *Chunk_Http:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Http); err != nil {
			return err
		}
	case *Chunk_Inline:
		_ = b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Inline); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Chunk.Source has unexpected type %T", x)
	}
	return nil
}

func _Chunk_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Chunk)
	switch tag {
	case 10: // source.http
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BlockSourceHTTP)
		err := b.DecodeMessage(msg)
		m.Source = &Chunk_Http{msg}
		return true, err
	case 20: // source.inline
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BlockSourceInline)
		err := b.DecodeMessage(msg)
		m.Source = &Chunk_Inline{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Chunk_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Chunk)
	// source
	switch x := m.Source.(type) {
	case *Chunk_Http:
		s := proto.Size(x.Http)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Chunk_Inline:
		s := proto.Size(x.Inline)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type BlockSourceHTTP struct {
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	RangeBegin           uint64   `protobuf:"varint,2,opt,name=range_begin,json=rangeBegin,proto3" json:"range_begin,omitempty"`
	RangeEnd             uint64   `protobuf:"varint,3,opt,name=range_end,json=rangeEnd,proto3" json:"range_end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockSourceHTTP) Reset()         { *m = BlockSourceHTTP{} }
func (m *BlockSourceHTTP) String() string { return proto.CompactTextString(m) }
func (*BlockSourceHTTP) ProtoMessage()    {}
func (*BlockSourceHTTP) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{27}
}
func (m *BlockSourceHTTP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockSourceHTTP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockSourceHTTP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockSourceHTTP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockSourceHTTP.Merge(m, src)
}
func (m *BlockSourceHTTP) XXX_Size() int {
	return m.Size()
}
func (m *BlockSourceHTTP) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockSourceHTTP.DiscardUnknown(m)
}

var xxx_messageInfo_BlockSourceHTTP proto.InternalMessageInfo

func (m *BlockSourceHTTP) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *BlockSourceHTTP) GetRangeBegin() uint64 {
	if m != nil {
		return m.RangeBegin
	}
	return 0
}

func (m *BlockSourceHTTP) GetRangeEnd() uint64 {
	if m != nil {
		return m.RangeEnd
	}
	return 0
}

type BlockSourceInline struct {
	Block                [][]byte `protobuf:"bytes,1,rep,name=block,proto3" json:"block,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockSourceInline) Reset()         { *m = BlockSourceInline{} }
func (m *BlockSourceInline) String() string { return proto.CompactTextString(m) }
func (*BlockSourceInline) ProtoMessage()    {}
func (*BlockSourceInline) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{28}
}
func (m *BlockSourceInline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockSourceInline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockSourceInline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockSourceInline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockSourceInline.Merge(m, src)
}
func (m *BlockSourceInline) XXX_Size() int {
	return m.Size()
}
func (m *BlockSourceInline) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockSourceInline.DiscardUnknown(m)
}

var xxx_messageInfo_BlockSourceInline proto.InternalMessageInfo

func (m *BlockSourceInline) GetBlock() [][]byte {
	if m != nil {
		return m.Block
	}
	return nil
}

// TODO: this struct is also used at the cache, but most of these fields are irrelevant for the cache and only relevant for the publisher
type ObjectMetadata struct {
	ObjectSize uint64 `protobuf:"varint,1,opt,name=object_size,json=objectSize,proto3" json:"object_size,omitempty"`
	BlockSize  uint64 `protobuf:"varint,2,opt,name=block_size,json=blockSize,proto3" json:"block_size,omitempty"`
	// Passed through by publisher from HTTP upstream.
	Etag         []byte `protobuf:"bytes,4,opt,name=etag,proto3" json:"etag,omitempty"`
	LastModified string `protobuf:"bytes,5,opt,name=last_modified,json=lastModified,proto3" json:"last_modified,omitempty"`
	// Decided by publisher based on HTTP headers.
	CacheExpiration      string   `protobuf:"bytes,6,opt,name=cache_expiration,json=cacheExpiration,proto3" json:"cache_expiration,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectMetadata) Reset()         { *m = ObjectMetadata{} }
func (m *ObjectMetadata) String() string { return proto.CompactTextString(m) }
func (*ObjectMetadata) ProtoMessage()    {}
func (*ObjectMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{29}
}
func (m *ObjectMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectMetadata.Merge(m, src)
}
func (m *ObjectMetadata) XXX_Size() int {
	return m.Size()
}
func (m *ObjectMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectMetadata proto.InternalMessageInfo

func (m *ObjectMetadata) GetObjectSize() uint64 {
	if m != nil {
		return m.ObjectSize
	}
	return 0
}

func (m *ObjectMetadata) GetBlockSize() uint64 {
	if m != nil {
		return m.BlockSize
	}
	return 0
}

func (m *ObjectMetadata) GetEtag() []byte {
	if m != nil {
		return m.Etag
	}
	return nil
}

func (m *ObjectMetadata) GetLastModified() string {
	if m != nil {
		return m.LastModified
	}
	return ""
}

func (m *ObjectMetadata) GetCacheExpiration() string {
	if m != nil {
		return m.CacheExpiration
	}
	return ""
}

type CacheAnnounceRequest struct {
	// TODO: there's no proof the public_key belongs to us
	PublicKey            []byte   `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	Version              string   `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	FreeMemory           uint64   `protobuf:"varint,3,opt,name=free_memory,json=freeMemory,proto3" json:"free_memory,omitempty"`
	TotalMemory          uint64   `protobuf:"varint,4,opt,name=total_memory,json=totalMemory,proto3" json:"total_memory,omitempty"`
	FreeDisk             uint64   `protobuf:"varint,5,opt,name=free_disk,json=freeDisk,proto3" json:"free_disk,omitempty"`
	TotalDisk            uint64   `protobuf:"varint,6,opt,name=total_disk,json=totalDisk,proto3" json:"total_disk,omitempty"`
	StartupTime          int64    `protobuf:"varint,7,opt,name=startup_time,json=startupTime,proto3" json:"startup_time,omitempty"`
	ContactUrl           string   `protobuf:"bytes,8,opt,name=contact_url,json=contactUrl,proto3" json:"contact_url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CacheAnnounceRequest) Reset()         { *m = CacheAnnounceRequest{} }
func (m *CacheAnnounceRequest) String() string { return proto.CompactTextString(m) }
func (*CacheAnnounceRequest) ProtoMessage()    {}
func (*CacheAnnounceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{30}
}
func (m *CacheAnnounceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheAnnounceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CacheAnnounceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CacheAnnounceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheAnnounceRequest.Merge(m, src)
}
func (m *CacheAnnounceRequest) XXX_Size() int {
	return m.Size()
}
func (m *CacheAnnounceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheAnnounceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CacheAnnounceRequest proto.InternalMessageInfo

func (m *CacheAnnounceRequest) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *CacheAnnounceRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *CacheAnnounceRequest) GetFreeMemory() uint64 {
	if m != nil {
		return m.FreeMemory
	}
	return 0
}

func (m *CacheAnnounceRequest) GetTotalMemory() uint64 {
	if m != nil {
		return m.TotalMemory
	}
	return 0
}

func (m *CacheAnnounceRequest) GetFreeDisk() uint64 {
	if m != nil {
		return m.FreeDisk
	}
	return 0
}

func (m *CacheAnnounceRequest) GetTotalDisk() uint64 {
	if m != nil {
		return m.TotalDisk
	}
	return 0
}

func (m *CacheAnnounceRequest) GetStartupTime() int64 {
	if m != nil {
		return m.StartupTime
	}
	return 0
}

func (m *CacheAnnounceRequest) GetContactUrl() string {
	if m != nil {
		return m.ContactUrl
	}
	return ""
}

type CacheAnnounceResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CacheAnnounceResponse) Reset()         { *m = CacheAnnounceResponse{} }
func (m *CacheAnnounceResponse) String() string { return proto.CompactTextString(m) }
func (*CacheAnnounceResponse) ProtoMessage()    {}
func (*CacheAnnounceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{31}
}
func (m *CacheAnnounceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheAnnounceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CacheAnnounceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CacheAnnounceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheAnnounceResponse.Merge(m, src)
}
func (m *CacheAnnounceResponse) XXX_Size() int {
	return m.Size()
}
func (m *CacheAnnounceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheAnnounceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CacheAnnounceResponse proto.InternalMessageInfo

type CacheFetchRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CacheFetchRequest) Reset()         { *m = CacheFetchRequest{} }
func (m *CacheFetchRequest) String() string { return proto.CompactTextString(m) }
func (*CacheFetchRequest) ProtoMessage()    {}
func (*CacheFetchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{32}
}
func (m *CacheFetchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheFetchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CacheFetchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CacheFetchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheFetchRequest.Merge(m, src)
}
func (m *CacheFetchRequest) XXX_Size() int {
	return m.Size()
}
func (m *CacheFetchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheFetchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CacheFetchRequest proto.InternalMessageInfo

type CacheDescription struct {
	PublicKey            []byte   `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	Version              string   `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	FreeMemory           uint64   `protobuf:"varint,3,opt,name=free_memory,json=freeMemory,proto3" json:"free_memory,omitempty"`
	TotalMemory          uint64   `protobuf:"varint,4,opt,name=total_memory,json=totalMemory,proto3" json:"total_memory,omitempty"`
	FreeDisk             uint64   `protobuf:"varint,5,opt,name=free_disk,json=freeDisk,proto3" json:"free_disk,omitempty"`
	TotalDisk            uint64   `protobuf:"varint,6,opt,name=total_disk,json=totalDisk,proto3" json:"total_disk,omitempty"`
	StartupTime          int64    `protobuf:"varint,7,opt,name=startup_time,json=startupTime,proto3" json:"startup_time,omitempty"`
	ContactUrl           string   `protobuf:"bytes,8,opt,name=contact_url,json=contactUrl,proto3" json:"contact_url,omitempty"`
	ExternalIp           string   `protobuf:"bytes,9,opt,name=external_ip,json=externalIp,proto3" json:"external_ip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CacheDescription) Reset()         { *m = CacheDescription{} }
func (m *CacheDescription) String() string { return proto.CompactTextString(m) }
func (*CacheDescription) ProtoMessage()    {}
func (*CacheDescription) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{33}
}
func (m *CacheDescription) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheDescription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CacheDescription.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CacheDescription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheDescription.Merge(m, src)
}
func (m *CacheDescription) XXX_Size() int {
	return m.Size()
}
func (m *CacheDescription) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheDescription.DiscardUnknown(m)
}

var xxx_messageInfo_CacheDescription proto.InternalMessageInfo

func (m *CacheDescription) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *CacheDescription) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *CacheDescription) GetFreeMemory() uint64 {
	if m != nil {
		return m.FreeMemory
	}
	return 0
}

func (m *CacheDescription) GetTotalMemory() uint64 {
	if m != nil {
		return m.TotalMemory
	}
	return 0
}

func (m *CacheDescription) GetFreeDisk() uint64 {
	if m != nil {
		return m.FreeDisk
	}
	return 0
}

func (m *CacheDescription) GetTotalDisk() uint64 {
	if m != nil {
		return m.TotalDisk
	}
	return 0
}

func (m *CacheDescription) GetStartupTime() int64 {
	if m != nil {
		return m.StartupTime
	}
	return 0
}

func (m *CacheDescription) GetContactUrl() string {
	if m != nil {
		return m.ContactUrl
	}
	return ""
}

func (m *CacheDescription) GetExternalIp() string {
	if m != nil {
		return m.ExternalIp
	}
	return ""
}

type CacheFetchResponse struct {
	Caches               []*CacheDescription `protobuf:"bytes,1,rep,name=caches,proto3" json:"caches,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *CacheFetchResponse) Reset()         { *m = CacheFetchResponse{} }
func (m *CacheFetchResponse) String() string { return proto.CompactTextString(m) }
func (*CacheFetchResponse) ProtoMessage()    {}
func (*CacheFetchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e93222b067eb2616, []int{34}
}
func (m *CacheFetchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheFetchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CacheFetchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CacheFetchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheFetchResponse.Merge(m, src)
}
func (m *CacheFetchResponse) XXX_Size() int {
	return m.Size()
}
func (m *CacheFetchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheFetchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CacheFetchResponse proto.InternalMessageInfo

func (m *CacheFetchResponse) GetCaches() []*CacheDescription {
	if m != nil {
		return m.Caches
	}
	return nil
}

func init() {
	proto.RegisterType((*Error)(nil), "ccmsg.Error")
	proto.RegisterType((*PublicKey)(nil), "ccmsg.PublicKey")
	proto.RegisterType((*EscrowInfo)(nil), "ccmsg.EscrowInfo")
	proto.RegisterType((*Segment)(nil), "ccmsg.Segment")
	proto.RegisterType((*TicketBundle)(nil), "ccmsg.TicketBundle")
	proto.RegisterType((*TicketBundleRemainder)(nil), "ccmsg.TicketBundleRemainder")
	proto.RegisterType((*CacheInfo)(nil), "ccmsg.CacheInfo")
	proto.RegisterType((*NetworkAddress)(nil), "ccmsg.NetworkAddress")
	proto.RegisterType((*ColocationPuzzleInfo)(nil), "ccmsg.ColocationPuzzleInfo")
	proto.RegisterType((*BatchSignature)(nil), "ccmsg.BatchSignature")
	proto.RegisterType((*BlockKey)(nil), "ccmsg.BlockKey")
	proto.RegisterType((*TicketRequest)(nil), "ccmsg.TicketRequest")
	proto.RegisterType((*TicketL1)(nil), "ccmsg.TicketL1")
	proto.RegisterType((*TicketL2)(nil), "ccmsg.TicketL2")
	proto.RegisterType((*TicketL2Info)(nil), "ccmsg.TicketL2Info")
	proto.RegisterType((*Certificate)(nil), "ccmsg.Certificate")
	proto.RegisterType((*TicketBundleSubdigests)(nil), "ccmsg.TicketBundleSubdigests")
	proto.RegisterType((*ContentRequest)(nil), "ccmsg.ContentRequest")
	proto.RegisterType((*ContentResponse)(nil), "ccmsg.ContentResponse")
	proto.RegisterType((*ClientCacheRequest)(nil), "ccmsg.ClientCacheRequest")
	proto.RegisterType((*ClientCacheResponse)(nil), "ccmsg.ClientCacheResponse")
	proto.RegisterType((*ClientCacheResponseData)(nil), "ccmsg.ClientCacheResponseData")
	proto.RegisterType((*ClientCacheResponseL1)(nil), "ccmsg.ClientCacheResponseL1")
	proto.RegisterType((*ClientCacheResponseL2)(nil), "ccmsg.ClientCacheResponseL2")
	proto.RegisterType((*CacheMissRequest)(nil), "ccmsg.CacheMissRequest")
	proto.RegisterType((*CacheMissResponse)(nil), "ccmsg.CacheMissResponse")
	proto.RegisterType((*Chunk)(nil), "ccmsg.Chunk")
	proto.RegisterType((*BlockSourceHTTP)(nil), "ccmsg.BlockSourceHTTP")
	proto.RegisterType((*BlockSourceInline)(nil), "ccmsg.BlockSourceInline")
	proto.RegisterType((*ObjectMetadata)(nil), "ccmsg.ObjectMetadata")
	proto.RegisterType((*CacheAnnounceRequest)(nil), "ccmsg.CacheAnnounceRequest")
	proto.RegisterType((*CacheAnnounceResponse)(nil), "ccmsg.CacheAnnounceResponse")
	proto.RegisterType((*CacheFetchRequest)(nil), "ccmsg.CacheFetchRequest")
	proto.RegisterType((*CacheDescription)(nil), "ccmsg.CacheDescription")
	proto.RegisterType((*CacheFetchResponse)(nil), "ccmsg.CacheFetchResponse")
}

func init() { proto.RegisterFile("cachecash.proto", fileDescriptor_e93222b067eb2616) }

var fileDescriptor_e93222b067eb2616 = []byte{
	// 2119 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x58, 0x4b, 0x73, 0x23, 0x49,
	0x11, 0x56, 0xeb, 0x61, 0x4b, 0x29, 0x59, 0x92, 0xcb, 0x8f, 0xe9, 0xf1, 0xcc, 0x18, 0xd3, 0x2c,
	0x11, 0x1e, 0x1e, 0xde, 0x70, 0x03, 0x4b, 0xc4, 0xcc, 0x02, 0xbb, 0x7e, 0x30, 0x76, 0x30, 0x9e,
	0x75, 0xb4, 0x87, 0xe0, 0x04, 0x1d, 0xad, 0xee, 0xb2, 0xd4, 0xb8, 0xd5, 0x2d, 0xba, 0x4b, 0x3b,
	0x9e, 0x39, 0x71, 0xe2, 0xc8, 0x01, 0x2e, 0x9c, 0x38, 0xf1, 0x03, 0x80, 0xe0, 0x40, 0x04, 0x07,
	0x82, 0x1b, 0x47, 0x7e, 0x01, 0x41, 0x0c, 0x7f, 0x81, 0x23, 0x44, 0x10, 0x99, 0x55, 0xfd, 0x92,
	0x25, 0xaf, 0x59, 0x8e, 0x7b, 0xea, 0xae, 0xcc, 0xac, 0xac, 0xac, 0xac, 0x7c, 0x7c, 0x55, 0xd0,
	0x73, 0x1d, 0x77, 0xc4, 0x5d, 0x27, 0x19, 0xed, 0x4d, 0xe2, 0x48, 0x44, 0xac, 0xe1, 0xba, 0xe3,
	0x64, 0x68, 0x7c, 0x03, 0x1a, 0xc7, 0x71, 0x1c, 0xc5, 0x8c, 0x41, 0xdd, 0x8d, 0x3c, 0xae, 0x6b,
	0x3b, 0xda, 0x6e, 0xdd, 0xa2, 0x7f, 0xa6, 0xc3, 0xf2, 0x98, 0x27, 0x89, 0x33, 0xe4, 0x7a, 0x75,
	0x47, 0xdb, 0x6d, 0x59, 0xe9, 0xd0, 0xf8, 0x12, 0xb4, 0xce, 0xa7, 0x83, 0xc0, 0x77, 0xbf, 0xc7,
	0x5f, 0xb3, 0x47, 0x00, 0x13, 0x1a, 0xd8, 0x57, 0xfc, 0x35, 0x29, 0xe8, 0x58, 0xad, 0x49, 0xca,
	0x36, 0xfe, 0x58, 0x05, 0x38, 0x4e, 0xdc, 0x38, 0x7a, 0x75, 0x1a, 0x5e, 0x46, 0xec, 0xdd, 0x1b,
	0xd2, 0x6d, 0xb3, 0xbf, 0x47, 0xd6, 0xec, 0x65, 0x3a, 0x0b, 0xf3, 0xd9, 0x01, 0xac, 0xd3, 0x20,
	0x19, 0xf1, 0xd8, 0x2e, 0x4c, 0xad, 0x2e, 0x98, 0xca, 0x32, 0xe9, 0x92, 0x89, 0x5e, 0xec, 0xbc,
	0xb2, 0x3d, 0x1e, 0x38, 0xaf, 0xf5, 0x1a, 0xed, 0xb1, 0x85, 0x94, 0x23, 0x24, 0xb0, 0xc7, 0xd0,
	0xe7, 0xd7, 0x13, 0x3f, 0x76, 0x84, 0x1f, 0x85, 0x4a, 0xa8, 0x4e, 0x42, 0xbd, 0x9c, 0x2e, 0x45,
	0x3f, 0x07, 0xed, 0x44, 0x38, 0xb1, 0xb0, 0x07, 0x41, 0xe4, 0x5e, 0xe9, 0x0d, 0x92, 0x02, 0x22,
	0x1d, 0x20, 0x85, 0x3d, 0x81, 0x55, 0xe1, 0xbb, 0x57, 0x5c, 0x24, 0xf6, 0x84, 0xc7, 0x4a, 0x6c,
	0x69, 0xa7, 0xb6, 0xdb, 0x36, 0xbb, 0xca, 0xd6, 0x0b, 0x3e, 0x1c, 0xf3, 0x50, 0x58, 0x3d, 0x25,
	0x78, 0xce, 0x63, 0x39, 0xb7, 0x0b, 0x55, 0xdf, 0xd3, 0x97, 0xc9, 0x83, 0x55, 0xdf, 0x33, 0xbe,
	0x09, 0xcb, 0x4a, 0x96, 0x6d, 0xc2, 0x52, 0xc0, 0xc3, 0xa1, 0x18, 0xa9, 0x13, 0x52, 0x23, 0xb6,
	0x0e, 0x8d, 0x8f, 0x9d, 0x60, 0x2a, 0x4f, 0xa8, 0x6e, 0xc9, 0x81, 0xf1, 0xe7, 0x1a, 0x74, 0x5e,
	0x92, 0xf2, 0x83, 0x69, 0xe8, 0x05, 0x9c, 0x3d, 0x81, 0x56, 0xcc, 0xc7, 0x8e, 0x1f, 0x7a, 0x3c,
	0x56, 0x4e, 0x7f, 0xa8, 0xac, 0x29, 0xca, 0x59, 0xa9, 0x8c, 0x95, 0x8b, 0xb3, 0xa7, 0xd0, 0x95,
	0x86, 0xda, 0x31, 0xff, 0xc9, 0x94, 0x27, 0x42, 0x6f, 0xd0, 0x76, 0xd6, 0x4b, 0x0a, 0x2c, 0xc9,
	0xb3, 0x56, 0x44, 0x71, 0xc8, 0xbe, 0x02, 0x2d, 0x35, 0x39, 0xd8, 0x57, 0x6e, 0xe8, 0x95, 0xe6,
	0x3d, 0xdf, 0xb7, 0x9a, 0x42, 0xfd, 0xb1, 0x3d, 0x58, 0xe3, 0xa1, 0x1b, 0xbf, 0x9e, 0x08, 0xee,
	0xd9, 0xe9, 0x3c, 0x53, 0x07, 0xf2, 0xc8, 0x6a, 0xc6, 0x52, 0x33, 0x4d, 0x66, 0x42, 0x6b, 0xe0,
	0x08, 0x77, 0x64, 0x27, 0xfe, 0x50, 0x6f, 0xd2, 0xb6, 0x36, 0x94, 0xf6, 0x03, 0xa4, 0x5f, 0xf8,
	0xc3, 0xd0, 0x11, 0xd3, 0x98, 0x5b, 0xcd, 0x81, 0x1a, 0xb3, 0x0f, 0x80, 0x0d, 0x68, 0xb3, 0x38,
	0x29, 0xe4, 0xb1, 0xed, 0xf2, 0x58, 0xe8, 0x6d, 0x9a, 0xcc, 0xd4, 0xe4, 0x43, 0x1e, 0x0b, 0xff,
	0xd2, 0x77, 0x1d, 0xc1, 0xad, 0xbe, 0x94, 0xbe, 0x20, 0x61, 0x64, 0x60, 0x08, 0x53, 0x3a, 0xd9,
	0x7e, 0x78, 0x19, 0xe9, 0x2d, 0xda, 0x54, 0x1a, 0x87, 0x87, 0xc8, 0xc0, 0x40, 0xb7, 0x5a, 0x6e,
	0xfa, 0xcb, 0xf6, 0xa1, 0x39, 0xe6, 0xc2, 0xf1, 0x1c, 0xe1, 0xe8, 0x9d, 0x92, 0x95, 0x1f, 0x0d,
	0x7e, 0xcc, 0x5d, 0x71, 0xa6, 0x98, 0x56, 0x26, 0x66, 0xfc, 0x47, 0x83, 0x8d, 0xb9, 0x27, 0x83,
	0x3e, 0x52, 0xe7, 0x60, 0x27, 0xf8, 0x0d, 0x5d, 0x6e, 0x87, 0x91, 0x3a, 0xff, 0x55, 0xc5, 0xba,
	0x50, 0x9c, 0x17, 0x11, 0x7b, 0x00, 0x2d, 0x4e, 0xe9, 0x67, 0xfb, 0x9e, 0xca, 0xce, 0xa6, 0x24,
	0x9c, 0x7a, 0xc8, 0x8c, 0xc8, 0x04, 0x64, 0xd6, 0x24, 0x53, 0x12, 0x4e, 0x3d, 0xf6, 0x3e, 0xb4,
	0x27, 0xd3, 0x37, 0x6f, 0x02, 0xb5, 0xd1, 0x65, 0xb2, 0xfc, 0x41, 0xba, 0xd1, 0x28, 0x88, 0x5c,
	0x4a, 0x8c, 0x73, 0x92, 0xa1, 0x3d, 0xc3, 0x24, 0xfb, 0x67, 0xef, 0xc3, 0xaa, 0x1b, 0xf8, 0x3c,
	0x14, 0xc5, 0xa4, 0x6d, 0x2e, 0x48, 0xda, 0x9e, 0x14, 0xcd, 0x08, 0xc6, 0x7b, 0xd0, 0xca, 0x5c,
	0xc9, 0x1e, 0x43, 0xdd, 0xf1, 0xbc, 0x34, 0x70, 0x53, 0xdf, 0xbd, 0xe0, 0xe2, 0x55, 0x14, 0x5f,
	0x7d, 0xe8, 0x79, 0x31, 0x4f, 0x12, 0x8b, 0x44, 0x8c, 0x1f, 0x41, 0xb7, 0x4c, 0x67, 0x5b, 0xd0,
	0xf4, 0x43, 0x74, 0xab, 0x52, 0xd0, 0xb1, 0xb2, 0x31, 0x7b, 0x08, 0x2d, 0xfc, 0x7f, 0x8f, 0x98,
	0x55, 0x59, 0xb9, 0x32, 0x02, 0xd6, 0xc4, 0x49, 0x14, 0x0b, 0xf2, 0xcb, 0x8a, 0x45, 0xff, 0xc6,
	0xcf, 0x34, 0x58, 0x9f, 0xb7, 0x75, 0x14, 0x1e, 0x46, 0x4e, 0xa0, 0xb4, 0xd0, 0x3f, 0x26, 0x6d,
	0x1c, 0x4d, 0x43, 0x2f, 0xa1, 0x85, 0x57, 0x2c, 0x35, 0x62, 0x9f, 0x87, 0x8e, 0x2c, 0x22, 0xd1,
	0xe5, 0x65, 0xc2, 0x85, 0x2a, 0x48, 0xb2, 0xb0, 0x7c, 0x44, 0xa4, 0xbc, 0xce, 0xc4, 0x4e, 0x38,
	0xe4, 0xaa, 0x1a, 0xc9, 0x3a, 0x63, 0x21, 0xc5, 0xf8, 0xbd, 0x06, 0xdd, 0x72, 0x8c, 0xb3, 0x2f,
	0x42, 0x77, 0xe2, 0x88, 0x91, 0xed, 0xf9, 0x31, 0x77, 0xd1, 0x3c, 0xbd, 0xba, 0x53, 0xdb, 0x6d,
	0x5a, 0x2b, 0x48, 0x3d, 0x4a, 0x89, 0xa8, 0x5a, 0x89, 0x0d, 0x31, 0x99, 0x6b, 0x3b, 0xb5, 0xdd,
	0x8e, 0x05, 0x52, 0x06, 0x29, 0xa8, 0x27, 0x8e, 0x22, 0x41, 0xf9, 0x41, 0x9a, 0x69, 0xf9, 0x8e,
	0xb5, 0x82, 0xd4, 0x7c, 0xb9, 0x7d, 0x68, 0xa3, 0x84, 0x1f, 0x0e, 0xe9, 0x68, 0x1b, 0x0b, 0x8e,
	0x16, 0x94, 0x10, 0x9e, 0xea, 0x43, 0x68, 0x52, 0xa5, 0xc3, 0x9a, 0xdc, 0x87, 0x5a, 0xde, 0x2f,
	0xf0, 0xd7, 0xf8, 0x9d, 0x06, 0x2b, 0xa5, 0x62, 0x82, 0xe1, 0x49, 0x05, 0xd4, 0xf6, 0xbd, 0x6b,
	0x15, 0xe1, 0x4d, 0x22, 0x9c, 0x7a, 0xd7, 0x58, 0x5a, 0xfc, 0x10, 0x13, 0x18, 0xd5, 0xd4, 0x68,
	0xf5, 0xb4, 0xb4, 0xa4, 0x8b, 0xe0, 0x51, 0x87, 0x3c, 0xc6, 0xe5, 0xee, 0x43, 0x33, 0x55, 0x45,
	0xa6, 0x76, 0xac, 0x65, 0xa5, 0x89, 0x3d, 0x81, 0xbe, 0xcc, 0xe7, 0x42, 0xa0, 0xd6, 0x17, 0xec,
	0xa6, 0x4b, 0x92, 0x79, 0x9c, 0xfe, 0x54, 0x83, 0x66, 0x5a, 0xc8, 0xd0, 0x5c, 0x55, 0xb4, 0xb2,
	0x84, 0x54, 0xb5, 0xed, 0x45, 0x34, 0x77, 0x95, 0xda, 0xdd, 0x56, 0x29, 0xfb, 0xa1, 0x5e, 0xf6,
	0x83, 0xf1, 0xc3, 0xcc, 0x02, 0x13, 0xdb, 0x41, 0x18, 0x85, 0x2e, 0x57, 0x61, 0x28, 0x07, 0xec,
	0x29, 0xac, 0x4a, 0x4f, 0x25, 0x3c, 0x49, 0xb0, 0xc5, 0xc9, 0xb5, 0x6b, 0xf3, 0x3c, 0xd6, 0x23,
	0xc9, 0x0b, 0x29, 0x88, 0x3b, 0x74, 0xd3, 0x56, 0xf2, 0xdc, 0xa4, 0x40, 0x5f, 0x50, 0xa3, 0xb5,
	0x45, 0x35, 0xfa, 0x0b, 0xb0, 0xa2, 0xaa, 0x48, 0xc2, 0xdd, 0x98, 0x0b, 0x65, 0x5a, 0x47, 0x12,
	0x2f, 0x88, 0x66, 0xfc, 0x5a, 0x83, 0x76, 0xa1, 0xe8, 0xb2, 0x6f, 0x03, 0x4b, 0xa6, 0xb2, 0x30,
	0xdd, 0x01, 0x2d, 0xf4, 0x95, 0x6c, 0xc9, 0x61, 0x79, 0xd1, 0xab, 0xce, 0x14, 0xbd, 0x75, 0x68,
	0x4c, 0x09, 0xd5, 0xd4, 0x08, 0xd5, 0xc8, 0x01, 0xd6, 0x82, 0xd9, 0x80, 0xcf, 0x09, 0xc6, 0xdf,
	0x35, 0xd8, 0x2c, 0xd6, 0xe3, 0x8b, 0xe9, 0x40, 0xe6, 0x4f, 0xc2, 0x4c, 0xd8, 0x28, 0xf7, 0xc7,
	0x34, 0xb3, 0x34, 0xca, 0xac, 0xb5, 0x52, 0x43, 0x54, 0x29, 0xb6, 0x0b, 0xfd, 0xac, 0x2d, 0xa6,
	0xe2, 0x55, 0x12, 0xef, 0xa6, 0xcd, 0x50, 0x49, 0x3e, 0x85, 0xad, 0x39, 0xee, 0xce, 0x93, 0x17,
	0xed, 0xbc, 0x77, 0xc3, 0xeb, 0x6a, 0xf2, 0x63, 0xe8, 0x67, 0x7d, 0x3c, 0x9d, 0x22, 0xb7, 0xd6,
	0xcb, 0xe8, 0x52, 0xd4, 0xf8, 0x8b, 0x06, 0xdd, 0xc3, 0x28, 0x14, 0x08, 0x4c, 0x54, 0xf6, 0xcd,
	0xad, 0xe0, 0xda, 0x1d, 0x2b, 0x38, 0x55, 0x4f, 0x47, 0x8c, 0x14, 0x74, 0xa4, 0x7f, 0x2c, 0x3d,
	0x54, 0xcf, 0xec, 0x01, 0x1f, 0xfa, 0x61, 0x8a, 0x9e, 0x88, 0x74, 0x80, 0x14, 0x3c, 0x37, 0x29,
	0xc0, 0x43, 0x4f, 0x5f, 0x92, 0x81, 0x4e, 0x84, 0xe3, 0xd0, 0xa3, 0x9a, 0x58, 0xe8, 0x78, 0x69,
	0x4d, 0xcc, 0x5a, 0x9d, 0xf1, 0x0b, 0x0d, 0x7a, 0xd9, 0x1e, 0x92, 0x49, 0x14, 0x26, 0x7c, 0x51,
	0xbb, 0xd4, 0x16, 0xb5, 0x4b, 0x03, 0x1a, 0x1c, 0x11, 0xb1, 0xc2, 0x97, 0x1d, 0xb5, 0x51, 0x42,
	0xc9, 0x96, 0x64, 0xb1, 0x2f, 0xc3, 0x92, 0x04, 0x05, 0x2a, 0x81, 0xd7, 0xe6, 0x41, 0x29, 0x25,
	0x62, 0xfc, 0xbb, 0x06, 0xec, 0x90, 0x7c, 0x43, 0x0d, 0x2d, 0x75, 0xee, 0xcc, 0x66, 0x9a, 0xb3,
	0x9b, 0x61, 0xcf, 0x40, 0x21, 0x0f, 0xfb, 0x7f, 0x43, 0x6e, 0xbd, 0xc1, 0x0c, 0x60, 0xf8, 0xd6,
	0x1c, 0xfc, 0xa6, 0x2d, 0xc2, 0x6f, 0x27, 0x95, 0x59, 0x04, 0xb7, 0x57, 0x46, 0x70, 0xda, 0x1c,
	0x04, 0x77, 0x52, 0x29, 0x60, 0x38, 0x33, 0x97, 0x37, 0x15, 0x66, 0x28, 0xfb, 0x47, 0xd6, 0x91,
	0xc2, 0x1c, 0x93, 0xfd, 0x00, 0x74, 0x35, 0x27, 0x85, 0x66, 0x59, 0x7a, 0xa9, 0x73, 0x78, 0x34,
	0x67, 0xcf, 0x79, 0x0e, 0x5a, 0x9b, 0x62, 0x7e, 0x6e, 0x7e, 0x1d, 0x20, 0x07, 0x7b, 0xea, 0xb4,
	0x16, 0x20, 0xc4, 0x56, 0x86, 0xf3, 0x16, 0x40, 0xc4, 0xfa, 0xdd, 0x21, 0xe2, 0x41, 0x13, 0x96,
	0xa4, 0x45, 0xc6, 0x9f, 0xaa, 0xb0, 0x56, 0x3a, 0xfe, 0x4f, 0x19, 0x97, 0xef, 0xdc, 0x12, 0x97,
	0x27, 0x95, 0x34, 0x32, 0x8f, 0x61, 0x05, 0xe1, 0xa3, 0x1d, 0xab, 0x65, 0xd4, 0x96, 0xb7, 0x53,
	0xa3, 0x6f, 0x1a, 0x72, 0xe4, 0x08, 0xe7, 0xa4, 0x62, 0x75, 0x08, 0x7f, 0xa6, 0xc6, 0x7d, 0x07,
	0xda, 0xc1, 0x7e, 0xae, 0xa4, 0x5e, 0x0a, 0xbb, 0x39, 0x4a, 0x28, 0x04, 0x20, 0xd8, 0x2f, 0x29,
	0x30, 0x73, 0x05, 0x8d, 0x4f, 0x54, 0x60, 0x92, 0x02, 0x33, 0x1d, 0x1f, 0x34, 0xa0, 0x86, 0xf7,
	0xd3, 0xaf, 0xc2, 0xbd, 0x05, 0x36, 0x63, 0x7d, 0x21, 0x40, 0x2d, 0x1b, 0x0f, 0xfd, 0x1b, 0xc7,
	0xb0, 0x31, 0xd7, 0x3a, 0xc4, 0x0a, 0xd1, 0x54, 0x28, 0xac, 0xa0, 0x2d, 0xc0, 0x0a, 0x24, 0x81,
	0x2d, 0xef, 0xde, 0x7c, 0x35, 0xa6, 0x31, 0x86, 0x3e, 0x91, 0xce, 0xfc, 0x24, 0x29, 0x24, 0x72,
	0xb1, 0xa6, 0x55, 0x6f, 0xaf, 0x69, 0xb5, 0x99, 0x9a, 0x56, 0x02, 0xe0, 0xf5, 0x32, 0x00, 0x37,
	0x02, 0x58, 0x2d, 0x2c, 0xa7, 0x5c, 0x5b, 0xbc, 0x4c, 0x68, 0x77, 0xba, 0x4c, 0xb0, 0x77, 0x60,
	0xc9, 0x1d, 0x4d, 0xc3, 0xab, 0x84, 0x7a, 0x4c, 0x1e, 0x3c, 0x87, 0x48, 0xb4, 0x14, 0xcf, 0xf8,
	0xb9, 0x06, 0x0d, 0xa2, 0x20, 0x56, 0x4a, 0x82, 0x48, 0x10, 0xda, 0x90, 0x01, 0xb9, 0x8c, 0x63,
	0x09, 0xba, 0xea, 0x23, 0x21, 0x26, 0x74, 0x25, 0x6b, 0x9b, 0x9b, 0x45, 0x1f, 0x5e, 0x44, 0xd3,
	0xd8, 0xe5, 0x27, 0x2f, 0x5f, 0x9e, 0x9f, 0x54, 0x2c, 0x92, 0x62, 0x26, 0x2c, 0xf9, 0x61, 0xe0,
	0x87, 0x5c, 0x5f, 0x27, 0x79, 0xfd, 0xa6, 0xfc, 0x29, 0xf1, 0x4f, 0x2a, 0x96, 0x92, 0xc4, 0xd4,
	0x49, 0x88, 0x63, 0x38, 0xd0, 0x9b, 0x51, 0x8c, 0xa0, 0x71, 0x1a, 0x07, 0x64, 0x54, 0xcb, 0xc2,
	0xdf, 0xff, 0xcf, 0xfd, 0xc6, 0x63, 0x58, 0xbd, 0x61, 0x0b, 0xe2, 0x03, 0x79, 0x6d, 0x97, 0x0d,
	0x5c, 0x0e, 0x8c, 0x3f, 0x68, 0xd0, 0x2d, 0x7b, 0x18, 0xd7, 0x56, 0x87, 0x97, 0xf8, 0x6f, 0xd2,
	0xb7, 0x13, 0x90, 0xa4, 0x0b, 0xff, 0x0d, 0x67, 0x8f, 0x00, 0x24, 0x6e, 0x23, 0xbe, 0xb4, 0x4d,
	0x22, 0x39, 0x62, 0x33, 0xa8, 0x73, 0xe1, 0x0c, 0xd5, 0xb9, 0xd3, 0x3f, 0xc2, 0xa5, 0xc0, 0x49,
	0x84, 0x3d, 0x8e, 0x3c, 0xff, 0xd2, 0xe7, 0x12, 0xac, 0xb6, 0xac, 0x0e, 0x12, 0xcf, 0x14, 0x0d,
	0xfb, 0xba, 0xc4, 0x92, 0xf9, 0xf3, 0x04, 0x95, 0xe6, 0x96, 0x25, 0x1f, 0x7a, 0x8e, 0x33, 0xb2,
	0xf1, 0xcb, 0x2a, 0xac, 0x53, 0x10, 0x7d, 0x18, 0x86, 0xd1, 0x34, 0x74, 0xb3, 0x06, 0x74, 0xfb,
	0xb3, 0x0d, 0xd3, 0x61, 0xf9, 0x63, 0x1e, 0x27, 0xf2, 0x16, 0x41, 0x8f, 0x3f, 0x6a, 0x88, 0xbb,
	0xbe, 0x8c, 0x39, 0xb7, 0xc7, 0x7c, 0x1c, 0xc5, 0xe9, 0x6b, 0x0a, 0x20, 0xe9, 0x8c, 0x28, 0x78,
	0xbd, 0x11, 0x91, 0x70, 0x82, 0x54, 0x42, 0x36, 0xea, 0x36, 0xd1, 0x94, 0xc8, 0x03, 0x68, 0x91,
	0x0e, 0xcf, 0x4f, 0xd2, 0x47, 0x94, 0x26, 0x12, 0x8e, 0xfc, 0xe4, 0x0a, 0x2d, 0x93, 0xf3, 0x89,
	0x2b, 0x51, 0x40, 0x8b, 0x28, 0xc4, 0x4e, 0x6f, 0x4f, 0xd3, 0x89, 0x2d, 0xfc, 0x31, 0xa7, 0x1e,
	0x53, 0x53, 0xb7, 0xa7, 0xe9, 0xe4, 0xa5, 0x3f, 0xe6, 0x68, 0xa2, 0x1b, 0x85, 0xc2, 0x71, 0x85,
	0x8d, 0xe1, 0xd2, 0xa4, 0x0d, 0x80, 0x22, 0x7d, 0x3f, 0x0e, 0x28, 0xc3, 0xcb, 0x4e, 0x91, 0xd9,
	0x65, 0xac, 0xa9, 0x94, 0xfb, 0x2e, 0x17, 0xee, 0x48, 0xb9, 0xca, 0xf8, 0x6d, 0x55, 0xe5, 0xfd,
	0x11, 0x62, 0x48, 0x7f, 0x42, 0xd7, 0xa8, 0xcf, 0xb2, 0xff, 0x50, 0x80, 0x5f, 0x0b, 0x1e, 0x87,
	0x4e, 0x60, 0xfb, 0x13, 0xbd, 0x25, 0x05, 0x52, 0xd2, 0xe9, 0xc4, 0x38, 0x06, 0x56, 0xf4, 0xa3,
	0xaa, 0x5d, 0xef, 0xc2, 0x12, 0xc5, 0x67, 0x42, 0xa9, 0xd5, 0x36, 0xef, 0x15, 0x5f, 0x4d, 0x0a,
	0xce, 0xb5, 0x94, 0x98, 0x79, 0x0e, 0xbd, 0xc3, 0x1c, 0x57, 0x26, 0x23, 0x82, 0x33, 0xf0, 0x8c,
	0x0b, 0x05, 0xf3, 0xd8, 0x46, 0xf6, 0x1c, 0x51, 0x84, 0xae, 0x5b, 0x9b, 0xb3, 0x64, 0x75, 0xbc,
	0x15, 0xf3, 0x5f, 0x78, 0xd3, 0xc8, 0x8b, 0x3b, 0x7b, 0x06, 0xcd, 0x67, 0x5c, 0xbd, 0xdd, 0xdd,
	0x9f, 0xd7, 0xa0, 0xa4, 0xc2, 0x4f, 0xe8, 0xa0, 0x46, 0x85, 0x9d, 0x41, 0xff, 0xf8, 0xda, 0x1d,
	0x61, 0x65, 0xc9, 0x2e, 0x84, 0xb7, 0x28, 0xbc, 0xb5, 0x9b, 0xce, 0x55, 0x67, 0x7e, 0x5a, 0x75,
	0xa6, 0x51, 0x31, 0x2d, 0xe8, 0x1e, 0x66, 0x77, 0x4a, 0xf2, 0xe3, 0x07, 0xea, 0x85, 0x05, 0x9b,
	0x0b, 0x2b, 0x1d, 0x44, 0xa1, 0xbb, 0x6d, 0xe9, 0x37, 0x19, 0x99, 0x2b, 0x7f, 0xa3, 0x41, 0xf7,
	0x45, 0xe4, 0xf1, 0x83, 0x28, 0x12, 0x89, 0x88, 0x9d, 0x89, 0xc7, 0x9e, 0xc3, 0x4a, 0x9a, 0x52,
	0xd2, 0xbd, 0x0f, 0x8a, 0xf3, 0x67, 0x4a, 0x50, 0x6e, 0xf4, 0xdc, 0x54, 0xac, 0xb0, 0x23, 0x68,
	0x53, 0xfc, 0x10, 0x3f, 0x61, 0x25, 0x5b, 0x8a, 0x09, 0xba, 0x75, 0x7f, 0x0e, 0x27, 0xd5, 0x72,
	0xd0, 0xff, 0xeb, 0xdb, 0x6d, 0xed, 0x6f, 0x6f, 0xb7, 0xb5, 0x7f, 0xbc, 0xdd, 0xd6, 0x7e, 0xf5,
	0xcf, 0xed, 0xca, 0x60, 0x89, 0xde, 0xc0, 0xbf, 0xf6, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x25,
	0xf4, 0xd9, 0xf5, 0x16, 0x17, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ClientPublisherClient is the client API for ClientPublisher service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ClientPublisherClient interface {
	GetContent(ctx context.Context, in *ContentRequest, opts ...grpc.CallOption) (*ContentResponse, error)
}

type clientPublisherClient struct {
	cc *grpc.ClientConn
}

func NewClientPublisherClient(cc *grpc.ClientConn) ClientPublisherClient {
	return &clientPublisherClient{cc}
}

func (c *clientPublisherClient) GetContent(ctx context.Context, in *ContentRequest, opts ...grpc.CallOption) (*ContentResponse, error) {
	out := new(ContentResponse)
	err := c.cc.Invoke(ctx, "/ccmsg.ClientPublisher/GetContent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClientPublisherServer is the server API for ClientPublisher service.
type ClientPublisherServer interface {
	GetContent(context.Context, *ContentRequest) (*ContentResponse, error)
}

func RegisterClientPublisherServer(s *grpc.Server, srv ClientPublisherServer) {
	s.RegisterService(&_ClientPublisher_serviceDesc, srv)
}

func _ClientPublisher_GetContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientPublisherServer).GetContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmsg.ClientPublisher/GetContent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientPublisherServer).GetContent(ctx, req.(*ContentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ClientPublisher_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ccmsg.ClientPublisher",
	HandlerType: (*ClientPublisherServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetContent",
			Handler:    _ClientPublisher_GetContent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cachecash.proto",
}

// ClientCacheClient is the client API for ClientCache service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ClientCacheClient interface {
	GetBlock(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseData, error)
	ExchangeTicketL1(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseL1, error)
	ExchangeTicketL2(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseL2, error)
}

type clientCacheClient struct {
	cc *grpc.ClientConn
}

func NewClientCacheClient(cc *grpc.ClientConn) ClientCacheClient {
	return &clientCacheClient{cc}
}

func (c *clientCacheClient) GetBlock(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseData, error) {
	out := new(ClientCacheResponseData)
	err := c.cc.Invoke(ctx, "/ccmsg.ClientCache/GetBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientCacheClient) ExchangeTicketL1(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseL1, error) {
	out := new(ClientCacheResponseL1)
	err := c.cc.Invoke(ctx, "/ccmsg.ClientCache/ExchangeTicketL1", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientCacheClient) ExchangeTicketL2(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseL2, error) {
	out := new(ClientCacheResponseL2)
	err := c.cc.Invoke(ctx, "/ccmsg.ClientCache/ExchangeTicketL2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClientCacheServer is the server API for ClientCache service.
type ClientCacheServer interface {
	GetBlock(context.Context, *ClientCacheRequest) (*ClientCacheResponseData, error)
	ExchangeTicketL1(context.Context, *ClientCacheRequest) (*ClientCacheResponseL1, error)
	ExchangeTicketL2(context.Context, *ClientCacheRequest) (*ClientCacheResponseL2, error)
}

func RegisterClientCacheServer(s *grpc.Server, srv ClientCacheServer) {
	s.RegisterService(&_ClientCache_serviceDesc, srv)
}

func _ClientCache_GetBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientCacheServer).GetBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmsg.ClientCache/GetBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientCacheServer).GetBlock(ctx, req.(*ClientCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClientCache_ExchangeTicketL1_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientCacheServer).ExchangeTicketL1(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmsg.ClientCache/ExchangeTicketL1",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientCacheServer).ExchangeTicketL1(ctx, req.(*ClientCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClientCache_ExchangeTicketL2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientCacheServer).ExchangeTicketL2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmsg.ClientCache/ExchangeTicketL2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientCacheServer).ExchangeTicketL2(ctx, req.(*ClientCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ClientCache_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ccmsg.ClientCache",
	HandlerType: (*ClientCacheServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBlock",
			Handler:    _ClientCache_GetBlock_Handler,
		},
		{
			MethodName: "ExchangeTicketL1",
			Handler:    _ClientCache_ExchangeTicketL1_Handler,
		},
		{
			MethodName: "ExchangeTicketL2",
			Handler:    _ClientCache_ExchangeTicketL2_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cachecash.proto",
}

// CachePublisherClient is the client API for CachePublisher service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CachePublisherClient interface {
	CacheMiss(ctx context.Context, in *CacheMissRequest, opts ...grpc.CallOption) (*CacheMissResponse, error)
}

type cachePublisherClient struct {
	cc *grpc.ClientConn
}

func NewCachePublisherClient(cc *grpc.ClientConn) CachePublisherClient {
	return &cachePublisherClient{cc}
}

func (c *cachePublisherClient) CacheMiss(ctx context.Context, in *CacheMissRequest, opts ...grpc.CallOption) (*CacheMissResponse, error) {
	out := new(CacheMissResponse)
	err := c.cc.Invoke(ctx, "/ccmsg.CachePublisher/CacheMiss", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CachePublisherServer is the server API for CachePublisher service.
type CachePublisherServer interface {
	CacheMiss(context.Context, *CacheMissRequest) (*CacheMissResponse, error)
}

func RegisterCachePublisherServer(s *grpc.Server, srv CachePublisherServer) {
	s.RegisterService(&_CachePublisher_serviceDesc, srv)
}

func _CachePublisher_CacheMiss_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CacheMissRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CachePublisherServer).CacheMiss(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmsg.CachePublisher/CacheMiss",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CachePublisherServer).CacheMiss(ctx, req.(*CacheMissRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CachePublisher_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ccmsg.CachePublisher",
	HandlerType: (*CachePublisherServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CacheMiss",
			Handler:    _CachePublisher_CacheMiss_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cachecash.proto",
}

// NodeBootstrapdClient is the client API for NodeBootstrapd service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NodeBootstrapdClient interface {
	AnnounceCache(ctx context.Context, in *CacheAnnounceRequest, opts ...grpc.CallOption) (*CacheAnnounceResponse, error)
	FetchCaches(ctx context.Context, in *CacheFetchRequest, opts ...grpc.CallOption) (*CacheFetchResponse, error)
}

type nodeBootstrapdClient struct {
	cc *grpc.ClientConn
}

func NewNodeBootstrapdClient(cc *grpc.ClientConn) NodeBootstrapdClient {
	return &nodeBootstrapdClient{cc}
}

func (c *nodeBootstrapdClient) AnnounceCache(ctx context.Context, in *CacheAnnounceRequest, opts ...grpc.CallOption) (*CacheAnnounceResponse, error) {
	out := new(CacheAnnounceResponse)
	err := c.cc.Invoke(ctx, "/ccmsg.NodeBootstrapd/AnnounceCache", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeBootstrapdClient) FetchCaches(ctx context.Context, in *CacheFetchRequest, opts ...grpc.CallOption) (*CacheFetchResponse, error) {
	out := new(CacheFetchResponse)
	err := c.cc.Invoke(ctx, "/ccmsg.NodeBootstrapd/FetchCaches", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeBootstrapdServer is the server API for NodeBootstrapd service.
type NodeBootstrapdServer interface {
	AnnounceCache(context.Context, *CacheAnnounceRequest) (*CacheAnnounceResponse, error)
	FetchCaches(context.Context, *CacheFetchRequest) (*CacheFetchResponse, error)
}

func RegisterNodeBootstrapdServer(s *grpc.Server, srv NodeBootstrapdServer) {
	s.RegisterService(&_NodeBootstrapd_serviceDesc, srv)
}

func _NodeBootstrapd_AnnounceCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CacheAnnounceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeBootstrapdServer).AnnounceCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmsg.NodeBootstrapd/AnnounceCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeBootstrapdServer).AnnounceCache(ctx, req.(*CacheAnnounceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeBootstrapd_FetchCaches_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CacheFetchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeBootstrapdServer).FetchCaches(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmsg.NodeBootstrapd/FetchCaches",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeBootstrapdServer).FetchCaches(ctx, req.(*CacheFetchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _NodeBootstrapd_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ccmsg.NodeBootstrapd",
	HandlerType: (*NodeBootstrapdServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AnnounceCache",
			Handler:    _NodeBootstrapd_AnnounceCache_Handler,
		},
		{
			MethodName: "FetchCaches",
			Handler:    _NodeBootstrapd_FetchCaches_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cachecash.proto",
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PublicKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PublicKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.PublicKey)))
		i += copy(dAtA[i:], m.PublicKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EscrowInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EscrowInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PublicKey != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.PublicKey.Size()))
		n1, err1 := m.PublicKey.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if m.PublisherPublicKey != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.PublisherPublicKey.Size()))
		n2, err2 := m.PublisherPublicKey.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	if m.DrawDelay != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.DrawDelay))
	}
	if m.ExpirationDelay != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.ExpirationDelay))
	}
	if m.StartBlock != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.StartBlock))
	}
	if len(m.TicketsPerBlock) > 0 {
		for _, msg := range m.TicketsPerBlock {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Segment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Segment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Length != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Length))
	}
	if m.Value != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TicketBundle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketBundle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Remainder != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Remainder.Size()))
		n3, err3 := m.Remainder.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	if len(m.TicketRequest) > 0 {
		for _, msg := range m.TicketRequest {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TicketL1) > 0 {
		for _, msg := range m.TicketL1 {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.BatchSig != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BatchSig.Size()))
		n4, err4 := m.BatchSig.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	if len(m.CacheInfo) > 0 {
		for _, msg := range m.CacheInfo {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EncryptedTicketL2) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.EncryptedTicketL2)))
		i += copy(dAtA[i:], m.EncryptedTicketL2)
	}
	if m.BundleSignerCert != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BundleSignerCert.Size()))
		n5, err5 := m.BundleSignerCert.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	if m.Metadata != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Metadata.Size()))
		n6, err6 := m.Metadata.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TicketBundleRemainder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketBundleRemainder) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EscrowId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.EscrowId)))
		i += copy(dAtA[i:], m.EscrowId)
	}
	if m.RequestSequenceNo != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RequestSequenceNo))
	}
	if len(m.ObjectId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.ObjectId)))
		i += copy(dAtA[i:], m.ObjectId)
	}
	if m.PuzzleInfo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.PuzzleInfo.Size()))
		n7, err7 := m.PuzzleInfo.MarshalTo(dAtA[i:])
		if err7 != nil {
			return 0, err7
		}
		i += n7
	}
	if m.ClientPublicKey != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.ClientPublicKey.Size()))
		n8, err8 := m.ClientPublicKey.MarshalTo(dAtA[i:])
		if err8 != nil {
			return 0, err8
		}
		i += n8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CacheInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Addr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Addr.Size()))
		n9, err9 := m.Addr.MarshalTo(dAtA[i:])
		if err9 != nil {
			return 0, err9
		}
		i += n9
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NetworkAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkAddress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Inetaddr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Inetaddr)))
		i += copy(dAtA[i:], m.Inetaddr)
	}
	if len(m.Inet6Addr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Inet6Addr)))
		i += copy(dAtA[i:], m.Inet6Addr)
	}
	if m.Port != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ColocationPuzzleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColocationPuzzleInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rounds != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Rounds))
	}
	if len(m.Goal) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Goal)))
		i += copy(dAtA[i:], m.Goal)
	}
	if m.StartOffset != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.StartOffset))
	}
	if m.StartRange != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.StartRange))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BatchSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSignature) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PathDirection) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.PathDirection)))
		for _, b := range m.PathDirection {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.PathDigest) > 0 {
		for _, b := range m.PathDigest {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.RootSignature) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.RootSignature)))
		i += copy(dAtA[i:], m.RootSignature)
	}
	if m.SigningKey != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.SigningKey.Size()))
		n10, err10 := m.SigningKey.MarshalTo(dAtA[i:])
		if err10 != nil {
			return 0, err10
		}
		i += n10
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TicketRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BlockIdx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BlockIdx))
	}
	if m.InnerKey != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.InnerKey.Size()))
		n11, err11 := m.InnerKey.MarshalTo(dAtA[i:])
		if err11 != nil {
			return 0, err11
		}
		i += n11
	}
	if m.CachePublicKey != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.CachePublicKey.Size()))
		n12, err12 := m.CachePublicKey.MarshalTo(dAtA[i:])
		if err12 != nil {
			return 0, err12
		}
		i += n12
	}
	if len(m.BlockId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.BlockId)))
		i += copy(dAtA[i:], m.BlockId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TicketL1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketL1) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TicketNo != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.TicketNo))
	}
	if m.CachePublicKey != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.CachePublicKey.Size()))
		n13, err13 := m.CachePublicKey.MarshalTo(dAtA[i:])
		if err13 != nil {
			return 0, err13
		}
		i += n13
	}
	if m.BlockIdx != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BlockIdx))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TicketL2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketL2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nonce) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Nonce)))
		i += copy(dAtA[i:], m.Nonce)
	}
	if len(m.InnerSessionKey) > 0 {
		for _, msg := range m.InnerSessionKey {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TicketL2Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketL2Info) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EncryptedTicketL2) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.EncryptedTicketL2)))
		i += copy(dAtA[i:], m.EncryptedTicketL2)
	}
	if len(m.PuzzleSecret) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.PuzzleSecret)))
		i += copy(dAtA[i:], m.PuzzleSecret)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Certificate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Certificate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SubjectPublicKey != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.SubjectPublicKey.Size()))
		n14, err14 := m.SubjectPublicKey.MarshalTo(dAtA[i:])
		if err14 != nil {
			return 0, err14
		}
		i += n14
	}
	if len(m.EscrowId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.EscrowId)))
		i += copy(dAtA[i:], m.EscrowId)
	}
	if len(m.Usage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Usage)))
		i += copy(dAtA[i:], m.Usage)
	}
	if len(m.Signature) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TicketBundleSubdigests) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketBundleSubdigests) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TicketRequestDigest) > 0 {
		for _, b := range m.TicketRequestDigest {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.TicketL1Digest) > 0 {
		for _, b := range m.TicketL1Digest {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.EncryptedTicketL2Digest) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.EncryptedTicketL2Digest)))
		i += copy(dAtA[i:], m.EncryptedTicketL2Digest)
	}
	if len(m.RemainderDigest) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.RemainderDigest)))
		i += copy(dAtA[i:], m.RemainderDigest)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ContentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContentRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClientPublicKey != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.ClientPublicKey.Size()))
		n15, err15 := m.ClientPublicKey.MarshalTo(dAtA[i:])
		if err15 != nil {
			return 0, err15
		}
		i += n15
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.SequenceNo != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.SequenceNo))
	}
	if m.RangeBegin != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RangeBegin))
	}
	if m.RangeEnd != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RangeEnd))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ContentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContentResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestSequenceNo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RequestSequenceNo))
	}
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Error.Size()))
		n16, err16 := m.Error.MarshalTo(dAtA[i:])
		if err16 != nil {
			return 0, err16
		}
		i += n16
	}
	if m.Bundle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Bundle.Size()))
		n17, err17 := m.Bundle.MarshalTo(dAtA[i:])
		if err17 != nil {
			return 0, err17
		}
		i += n17
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClientCacheRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCacheRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BundleRemainder != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BundleRemainder.Size()))
		n18, err18 := m.BundleRemainder.MarshalTo(dAtA[i:])
		if err18 != nil {
			return 0, err18
		}
		i += n18
	}
	if m.TicketBundleSubdigests != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.TicketBundleSubdigests.Size()))
		n19, err19 := m.TicketBundleSubdigests.MarshalTo(dAtA[i:])
		if err19 != nil {
			return 0, err19
		}
		i += n19
	}
	if m.BundleSig != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BundleSig.Size()))
		n20, err20 := m.BundleSig.MarshalTo(dAtA[i:])
		if err20 != nil {
			return 0, err20
		}
		i += n20
	}
	if m.BundleSignerCert != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BundleSignerCert.Size()))
		n21, err21 := m.BundleSignerCert.MarshalTo(dAtA[i:])
		if err21 != nil {
			return 0, err21
		}
		i += n21
	}
	if m.Ticket != nil {
		nn22, err22 := m.Ticket.MarshalTo(dAtA[i:])
		if err22 != nil {
			return 0, err22
		}
		i += nn22
	}
	if m.SequenceNo != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.SequenceNo))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClientCacheRequest_TicketRequest) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TicketRequest != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.TicketRequest.Size()))
		n23, err23 := m.TicketRequest.MarshalTo(dAtA[i:])
		if err23 != nil {
			return 0, err23
		}
		i += n23
	}
	return i, nil
}
func (m *ClientCacheRequest_TicketL1) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TicketL1 != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.TicketL1.Size()))
		n24, err24 := m.TicketL1.MarshalTo(dAtA[i:])
		if err24 != nil {
			return 0, err24
		}
		i += n24
	}
	return i, nil
}
func (m *ClientCacheRequest_TicketL2) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TicketL2 != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.TicketL2.Size()))
		n25, err25 := m.TicketL2.MarshalTo(dAtA[i:])
		if err25 != nil {
			return 0, err25
		}
		i += n25
	}
	return i, nil
}
func (m *ClientCacheResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCacheResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestSequenceNo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RequestSequenceNo))
	}
	if m.Msg != nil {
		nn26, err26 := m.Msg.MarshalTo(dAtA[i:])
		if err26 != nil {
			return 0, err26
		}
		i += nn26
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClientCacheResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Error.Size()))
		n27, err27 := m.Error.MarshalTo(dAtA[i:])
		if err27 != nil {
			return 0, err27
		}
		i += n27
	}
	return i, nil
}
func (m *ClientCacheResponse_DataResponse) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DataResponse != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.DataResponse.Size()))
		n28, err28 := m.DataResponse.MarshalTo(dAtA[i:])
		if err28 != nil {
			return 0, err28
		}
		i += n28
	}
	return i, nil
}
func (m *ClientCacheResponse_L1Response) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.L1Response != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.L1Response.Size()))
		n29, err29 := m.L1Response.MarshalTo(dAtA[i:])
		if err29 != nil {
			return 0, err29
		}
		i += n29
	}
	return i, nil
}
func (m *ClientCacheResponse_L2Response) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.L2Response != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.L2Response.Size()))
		n30, err30 := m.L2Response.MarshalTo(dAtA[i:])
		if err30 != nil {
			return 0, err30
		}
		i += n30
	}
	return i, nil
}
func (m *ClientCacheResponseData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCacheResponseData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClientCacheResponseL1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCacheResponseL1) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OuterKey != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.OuterKey.Size()))
		n31, err31 := m.OuterKey.MarshalTo(dAtA[i:])
		if err31 != nil {
			return 0, err31
		}
		i += n31
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClientCacheResponseL2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCacheResponseL2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CacheMissRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheMissRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RangeBegin != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RangeBegin))
	}
	if m.RangeEnd != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RangeEnd))
	}
	if len(m.ObjectId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.ObjectId)))
		i += copy(dAtA[i:], m.ObjectId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CacheMissResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheMissResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Metadata.Size()))
		n32, err32 := m.Metadata.MarshalTo(dAtA[i:])
		if err32 != nil {
			return 0, err32
		}
		i += n32
	}
	if len(m.Chunks) > 0 {
		for _, msg := range m.Chunks {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Chunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chunk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SlotIdx != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.SlotIdx))
	}
	if m.Source != nil {
		nn33, err33 := m.Source.MarshalTo(dAtA[i:])
		if err33 != nil {
			return 0, err33
		}
		i += nn33
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Chunk_Http) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Http != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Http.Size()))
		n34, err34 := m.Http.MarshalTo(dAtA[i:])
		if err34 != nil {
			return 0, err34
		}
		i += n34
	}
	return i, nil
}
func (m *Chunk_Inline) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Inline != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.Inline.Size()))
		n35, err35 := m.Inline.MarshalTo(dAtA[i:])
		if err35 != nil {
			return 0, err35
		}
		i += n35
	}
	return i, nil
}
func (m *BlockSourceHTTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockSourceHTTP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.RangeBegin != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RangeBegin))
	}
	if m.RangeEnd != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.RangeEnd))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockSourceInline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockSourceInline) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Block) > 0 {
		for _, b := range m.Block {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ObjectMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjectSize != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.ObjectSize))
	}
	if m.BlockSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.BlockSize))
	}
	if len(m.Etag) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Etag)))
		i += copy(dAtA[i:], m.Etag)
	}
	if len(m.LastModified) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.LastModified)))
		i += copy(dAtA[i:], m.LastModified)
	}
	if len(m.CacheExpiration) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.CacheExpiration)))
		i += copy(dAtA[i:], m.CacheExpiration)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CacheAnnounceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheAnnounceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PublicKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.PublicKey)))
		i += copy(dAtA[i:], m.PublicKey)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.FreeMemory != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.FreeMemory))
	}
	if m.TotalMemory != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.TotalMemory))
	}
	if m.FreeDisk != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.FreeDisk))
	}
	if m.TotalDisk != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.TotalDisk))
	}
	if m.StartupTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.StartupTime))
	}
	if len(m.ContactUrl) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.ContactUrl)))
		i += copy(dAtA[i:], m.ContactUrl)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CacheAnnounceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheAnnounceResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CacheFetchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheFetchRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CacheDescription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheDescription) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PublicKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.PublicKey)))
		i += copy(dAtA[i:], m.PublicKey)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.FreeMemory != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.FreeMemory))
	}
	if m.TotalMemory != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.TotalMemory))
	}
	if m.FreeDisk != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.FreeDisk))
	}
	if m.TotalDisk != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.TotalDisk))
	}
	if m.StartupTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(m.StartupTime))
	}
	if len(m.ContactUrl) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.ContactUrl)))
		i += copy(dAtA[i:], m.ContactUrl)
	}
	if len(m.ExternalIp) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCachecash(dAtA, i, uint64(len(m.ExternalIp)))
		i += copy(dAtA[i:], m.ExternalIp)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CacheFetchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheFetchResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Caches) > 0 {
		for _, msg := range m.Caches {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCachecash(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintCachecash(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovCachecash(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PublicKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EscrowInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublicKey != nil {
		l = m.PublicKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.PublisherPublicKey != nil {
		l = m.PublisherPublicKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.DrawDelay != 0 {
		n += 1 + sovCachecash(uint64(m.DrawDelay))
	}
	if m.ExpirationDelay != 0 {
		n += 1 + sovCachecash(uint64(m.ExpirationDelay))
	}
	if m.StartBlock != 0 {
		n += 1 + sovCachecash(uint64(m.StartBlock))
	}
	if len(m.TicketsPerBlock) > 0 {
		for _, e := range m.TicketsPerBlock {
			l = e.Size()
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Segment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Length != 0 {
		n += 1 + sovCachecash(uint64(m.Length))
	}
	if m.Value != 0 {
		n += 1 + sovCachecash(uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TicketBundle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Remainder != nil {
		l = m.Remainder.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if len(m.TicketRequest) > 0 {
		for _, e := range m.TicketRequest {
			l = e.Size()
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	if len(m.TicketL1) > 0 {
		for _, e := range m.TicketL1 {
			l = e.Size()
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	if m.BatchSig != nil {
		l = m.BatchSig.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if len(m.CacheInfo) > 0 {
		for _, e := range m.CacheInfo {
			l = e.Size()
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	l = len(m.EncryptedTicketL2)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.BundleSignerCert != nil {
		l = m.BundleSignerCert.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TicketBundleRemainder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EscrowId)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.RequestSequenceNo != 0 {
		n += 1 + sovCachecash(uint64(m.RequestSequenceNo))
	}
	l = len(m.ObjectId)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.PuzzleInfo != nil {
		l = m.PuzzleInfo.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.ClientPublicKey != nil {
		l = m.ClientPublicKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CacheInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Addr != nil {
		l = m.Addr.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inetaddr)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.Inet6Addr)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovCachecash(uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColocationPuzzleInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rounds != 0 {
		n += 1 + sovCachecash(uint64(m.Rounds))
	}
	l = len(m.Goal)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.StartOffset != 0 {
		n += 1 + sovCachecash(uint64(m.StartOffset))
	}
	if m.StartRange != 0 {
		n += 1 + sovCachecash(uint64(m.StartRange))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BatchSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PathDirection) > 0 {
		n += 1 + sovCachecash(uint64(len(m.PathDirection))) + len(m.PathDirection)*1
	}
	if len(m.PathDigest) > 0 {
		for _, b := range m.PathDigest {
			l = len(b)
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	l = len(m.RootSignature)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.SigningKey != nil {
		l = m.SigningKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TicketRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockIdx != 0 {
		n += 1 + sovCachecash(uint64(m.BlockIdx))
	}
	if m.InnerKey != nil {
		l = m.InnerKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.CachePublicKey != nil {
		l = m.CachePublicKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.BlockId)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TicketL1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TicketNo != 0 {
		n += 1 + sovCachecash(uint64(m.TicketNo))
	}
	if m.CachePublicKey != nil {
		l = m.CachePublicKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.BlockIdx != 0 {
		n += 1 + sovCachecash(uint64(m.BlockIdx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TicketL2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if len(m.InnerSessionKey) > 0 {
		for _, e := range m.InnerSessionKey {
			l = e.Size()
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TicketL2Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EncryptedTicketL2)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.PuzzleSecret)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Certificate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubjectPublicKey != nil {
		l = m.SubjectPublicKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.EscrowId)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.Usage)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TicketBundleSubdigests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TicketRequestDigest) > 0 {
		for _, b := range m.TicketRequestDigest {
			l = len(b)
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	if len(m.TicketL1Digest) > 0 {
		for _, b := range m.TicketL1Digest {
			l = len(b)
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	l = len(m.EncryptedTicketL2Digest)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.RemainderDigest)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContentRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientPublicKey != nil {
		l = m.ClientPublicKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.SequenceNo != 0 {
		n += 1 + sovCachecash(uint64(m.SequenceNo))
	}
	if m.RangeBegin != 0 {
		n += 1 + sovCachecash(uint64(m.RangeBegin))
	}
	if m.RangeEnd != 0 {
		n += 1 + sovCachecash(uint64(m.RangeEnd))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContentResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestSequenceNo != 0 {
		n += 1 + sovCachecash(uint64(m.RequestSequenceNo))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.Bundle != nil {
		l = m.Bundle.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientCacheRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BundleRemainder != nil {
		l = m.BundleRemainder.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.TicketBundleSubdigests != nil {
		l = m.TicketBundleSubdigests.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.BundleSig != nil {
		l = m.BundleSig.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.BundleSignerCert != nil {
		l = m.BundleSignerCert.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.Ticket != nil {
		n += m.Ticket.Size()
	}
	if m.SequenceNo != 0 {
		n += 1 + sovCachecash(uint64(m.SequenceNo))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientCacheRequest_TicketRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TicketRequest != nil {
		l = m.TicketRequest.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *ClientCacheRequest_TicketL1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TicketL1 != nil {
		l = m.TicketL1.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *ClientCacheRequest_TicketL2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TicketL2 != nil {
		l = m.TicketL2.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *ClientCacheResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestSequenceNo != 0 {
		n += 1 + sovCachecash(uint64(m.RequestSequenceNo))
	}
	if m.Msg != nil {
		n += m.Msg.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientCacheResponse_Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *ClientCacheResponse_DataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataResponse != nil {
		l = m.DataResponse.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *ClientCacheResponse_L1Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.L1Response != nil {
		l = m.L1Response.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *ClientCacheResponse_L2Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.L2Response != nil {
		l = m.L2Response.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *ClientCacheResponseData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientCacheResponseL1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OuterKey != nil {
		l = m.OuterKey.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientCacheResponseL2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CacheMissRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeBegin != 0 {
		n += 1 + sovCachecash(uint64(m.RangeBegin))
	}
	if m.RangeEnd != 0 {
		n += 1 + sovCachecash(uint64(m.RangeEnd))
	}
	l = len(m.ObjectId)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CacheMissResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Chunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SlotIdx != 0 {
		n += 1 + sovCachecash(uint64(m.SlotIdx))
	}
	if m.Source != nil {
		n += m.Source.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Chunk_Http) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Http != nil {
		l = m.Http.Size()
		n += 1 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *Chunk_Inline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Inline != nil {
		l = m.Inline.Size()
		n += 2 + l + sovCachecash(uint64(l))
	}
	return n
}
func (m *BlockSourceHTTP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.RangeBegin != 0 {
		n += 1 + sovCachecash(uint64(m.RangeBegin))
	}
	if m.RangeEnd != 0 {
		n += 1 + sovCachecash(uint64(m.RangeEnd))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockSourceInline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Block) > 0 {
		for _, b := range m.Block {
			l = len(b)
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectSize != 0 {
		n += 1 + sovCachecash(uint64(m.ObjectSize))
	}
	if m.BlockSize != 0 {
		n += 1 + sovCachecash(uint64(m.BlockSize))
	}
	l = len(m.Etag)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.LastModified)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.CacheExpiration)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CacheAnnounceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.FreeMemory != 0 {
		n += 1 + sovCachecash(uint64(m.FreeMemory))
	}
	if m.TotalMemory != 0 {
		n += 1 + sovCachecash(uint64(m.TotalMemory))
	}
	if m.FreeDisk != 0 {
		n += 1 + sovCachecash(uint64(m.FreeDisk))
	}
	if m.TotalDisk != 0 {
		n += 1 + sovCachecash(uint64(m.TotalDisk))
	}
	if m.StartupTime != 0 {
		n += 1 + sovCachecash(uint64(m.StartupTime))
	}
	l = len(m.ContactUrl)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CacheAnnounceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CacheFetchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CacheDescription) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.FreeMemory != 0 {
		n += 1 + sovCachecash(uint64(m.FreeMemory))
	}
	if m.TotalMemory != 0 {
		n += 1 + sovCachecash(uint64(m.TotalMemory))
	}
	if m.FreeDisk != 0 {
		n += 1 + sovCachecash(uint64(m.FreeDisk))
	}
	if m.TotalDisk != 0 {
		n += 1 + sovCachecash(uint64(m.TotalDisk))
	}
	if m.StartupTime != 0 {
		n += 1 + sovCachecash(uint64(m.StartupTime))
	}
	l = len(m.ContactUrl)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	l = len(m.ExternalIp)
	if l > 0 {
		n += 1 + l + sovCachecash(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CacheFetchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Caches) > 0 {
		for _, e := range m.Caches {
			l = e.Size()
			n += 1 + l + sovCachecash(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCachecash(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCachecash(x uint64) (n int) {
	return sovCachecash(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EscrowInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EscrowInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EscrowInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublicKey == nil {
				m.PublicKey = &PublicKey{}
			}
			if err := m.PublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublisherPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublisherPublicKey == nil {
				m.PublisherPublicKey = &PublicKey{}
			}
			if err := m.PublisherPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrawDelay", wireType)
			}
			m.DrawDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DrawDelay |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationDelay", wireType)
			}
			m.ExpirationDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationDelay |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBlock", wireType)
			}
			m.StartBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketsPerBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketsPerBlock = append(m.TicketsPerBlock, &Segment{})
			if err := m.TicketsPerBlock[len(m.TicketsPerBlock)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Segment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Segment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Segment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketBundle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketBundle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketBundle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remainder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Remainder == nil {
				m.Remainder = &TicketBundleRemainder{}
			}
			if err := m.Remainder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketRequest = append(m.TicketRequest, &TicketRequest{})
			if err := m.TicketRequest[len(m.TicketRequest)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketL1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketL1 = append(m.TicketL1, &TicketL1{})
			if err := m.TicketL1[len(m.TicketL1)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchSig == nil {
				m.BatchSig = &BatchSignature{}
			}
			if err := m.BatchSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheInfo = append(m.CacheInfo, &CacheInfo{})
			if err := m.CacheInfo[len(m.CacheInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedTicketL2", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedTicketL2 = append(m.EncryptedTicketL2[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedTicketL2 == nil {
				m.EncryptedTicketL2 = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleSignerCert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BundleSignerCert == nil {
				m.BundleSignerCert = &Certificate{}
			}
			if err := m.BundleSignerCert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &ObjectMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketBundleRemainder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketBundleRemainder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketBundleRemainder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowId = append(m.EscrowId[:0], dAtA[iNdEx:postIndex]...)
			if m.EscrowId == nil {
				m.EscrowId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestSequenceNo", wireType)
			}
			m.RequestSequenceNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestSequenceNo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectId = append(m.ObjectId[:0], dAtA[iNdEx:postIndex]...)
			if m.ObjectId == nil {
				m.ObjectId = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PuzzleInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PuzzleInfo == nil {
				m.PuzzleInfo = &ColocationPuzzleInfo{}
			}
			if err := m.PuzzleInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientPublicKey == nil {
				m.ClientPublicKey = &PublicKey{}
			}
			if err := m.ClientPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Addr == nil {
				m.Addr = &NetworkAddress{}
			}
			if err := m.Addr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inetaddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inetaddr = append(m.Inetaddr[:0], dAtA[iNdEx:postIndex]...)
			if m.Inetaddr == nil {
				m.Inetaddr = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inet6Addr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inet6Addr = append(m.Inet6Addr[:0], dAtA[iNdEx:postIndex]...)
			if m.Inet6Addr == nil {
				m.Inet6Addr = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColocationPuzzleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColocationPuzzleInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColocationPuzzleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rounds", wireType)
			}
			m.Rounds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rounds |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Goal = append(m.Goal[:0], dAtA[iNdEx:postIndex]...)
			if m.Goal == nil {
				m.Goal = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartOffset", wireType)
			}
			m.StartOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartOffset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartRange", wireType)
			}
			m.StartRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartRange |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCachecash
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PathDirection = append(m.PathDirection, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCachecash
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCachecash
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCachecash
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.PathDirection) == 0 {
					m.PathDirection = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCachecash
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PathDirection = append(m.PathDirection, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PathDirection", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathDigest = append(m.PathDigest, make([]byte, postIndex-iNdEx))
			copy(m.PathDigest[len(m.PathDigest)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootSignature = append(m.RootSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.RootSignature == nil {
				m.RootSignature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SigningKey == nil {
				m.SigningKey = &PublicKey{}
			}
			if err := m.SigningKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockIdx", wireType)
			}
			m.BlockIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockIdx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InnerKey == nil {
				m.InnerKey = &BlockKey{}
			}
			if err := m.InnerKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachePublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CachePublicKey == nil {
				m.CachePublicKey = &PublicKey{}
			}
			if err := m.CachePublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockId = append(m.BlockId[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockId == nil {
				m.BlockId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketL1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketL1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketL1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketNo", wireType)
			}
			m.TicketNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TicketNo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachePublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CachePublicKey == nil {
				m.CachePublicKey = &PublicKey{}
			}
			if err := m.CachePublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockIdx", wireType)
			}
			m.BlockIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockIdx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketL2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketL2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketL2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = append(m.Nonce[:0], dAtA[iNdEx:postIndex]...)
			if m.Nonce == nil {
				m.Nonce = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerSessionKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InnerSessionKey = append(m.InnerSessionKey, &BlockKey{})
			if err := m.InnerSessionKey[len(m.InnerSessionKey)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketL2Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketL2Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketL2Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedTicketL2", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedTicketL2 = append(m.EncryptedTicketL2[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedTicketL2 == nil {
				m.EncryptedTicketL2 = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PuzzleSecret", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PuzzleSecret = append(m.PuzzleSecret[:0], dAtA[iNdEx:postIndex]...)
			if m.PuzzleSecret == nil {
				m.PuzzleSecret = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Certificate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Certificate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Certificate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubjectPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubjectPublicKey == nil {
				m.SubjectPublicKey = &PublicKey{}
			}
			if err := m.SubjectPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowId = append(m.EscrowId[:0], dAtA[iNdEx:postIndex]...)
			if m.EscrowId == nil {
				m.EscrowId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Usage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketBundleSubdigests) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketBundleSubdigests: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketBundleSubdigests: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketRequestDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketRequestDigest = append(m.TicketRequestDigest, make([]byte, postIndex-iNdEx))
			copy(m.TicketRequestDigest[len(m.TicketRequestDigest)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketL1Digest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketL1Digest = append(m.TicketL1Digest, make([]byte, postIndex-iNdEx))
			copy(m.TicketL1Digest[len(m.TicketL1Digest)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedTicketL2Digest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedTicketL2Digest = append(m.EncryptedTicketL2Digest[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedTicketL2Digest == nil {
				m.EncryptedTicketL2Digest = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainderDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemainderDigest = append(m.RemainderDigest[:0], dAtA[iNdEx:postIndex]...)
			if m.RemainderDigest == nil {
				m.RemainderDigest = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientPublicKey == nil {
				m.ClientPublicKey = &PublicKey{}
			}
			if err := m.ClientPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNo", wireType)
			}
			m.SequenceNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeBegin", wireType)
			}
			m.RangeBegin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeBegin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeEnd", wireType)
			}
			m.RangeEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeEnd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestSequenceNo", wireType)
			}
			m.RequestSequenceNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestSequenceNo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bundle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bundle == nil {
				m.Bundle = &TicketBundle{}
			}
			if err := m.Bundle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientCacheRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCacheRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCacheRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleRemainder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BundleRemainder == nil {
				m.BundleRemainder = &TicketBundleRemainder{}
			}
			if err := m.BundleRemainder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketBundleSubdigests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TicketBundleSubdigests == nil {
				m.TicketBundleSubdigests = &TicketBundleSubdigests{}
			}
			if err := m.TicketBundleSubdigests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleSig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BundleSig == nil {
				m.BundleSig = &BatchSignature{}
			}
			if err := m.BundleSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleSignerCert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BundleSignerCert == nil {
				m.BundleSignerCert = &Certificate{}
			}
			if err := m.BundleSignerCert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TicketRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ticket = &ClientCacheRequest_TicketRequest{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketL1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TicketL1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ticket = &ClientCacheRequest_TicketL1{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketL2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TicketL2Info{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ticket = &ClientCacheRequest_TicketL2{v}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNo", wireType)
			}
			m.SequenceNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientCacheResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCacheResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCacheResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestSequenceNo", wireType)
			}
			m.RequestSequenceNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestSequenceNo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &ClientCacheResponse_Error{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClientCacheResponseData{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &ClientCacheResponse_DataResponse{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClientCacheResponseL1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &ClientCacheResponse_L1Response{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClientCacheResponseL2{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &ClientCacheResponse_L2Response{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientCacheResponseData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCacheResponseData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCacheResponseData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientCacheResponseL1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCacheResponseL1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCacheResponseL1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OuterKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OuterKey == nil {
				m.OuterKey = &BlockKey{}
			}
			if err := m.OuterKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientCacheResponseL2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCacheResponseL2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCacheResponseL2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheMissRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheMissRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheMissRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeBegin", wireType)
			}
			m.RangeBegin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeBegin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeEnd", wireType)
			}
			m.RangeEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeEnd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectId = append(m.ObjectId[:0], dAtA[iNdEx:postIndex]...)
			if m.ObjectId == nil {
				m.ObjectId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheMissResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheMissResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheMissResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &ObjectMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotIdx", wireType)
			}
			m.SlotIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlotIdx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockSourceHTTP{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Source = &Chunk_Http{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockSourceInline{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Source = &Chunk_Inline{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockSourceHTTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockSourceHTTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockSourceHTTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeBegin", wireType)
			}
			m.RangeBegin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeBegin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeEnd", wireType)
			}
			m.RangeEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeEnd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockSourceInline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockSourceInline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockSourceInline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Block = append(m.Block, make([]byte, postIndex-iNdEx))
			copy(m.Block[len(m.Block)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectSize", wireType)
			}
			m.ObjectSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockSize", wireType)
			}
			m.BlockSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etag", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Etag = append(m.Etag[:0], dAtA[iNdEx:postIndex]...)
			if m.Etag == nil {
				m.Etag = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModified", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastModified = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheExpiration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheExpiration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheAnnounceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheAnnounceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheAnnounceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeMemory", wireType)
			}
			m.FreeMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeMemory |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMemory", wireType)
			}
			m.TotalMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalMemory |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeDisk", wireType)
			}
			m.FreeDisk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeDisk |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDisk", wireType)
			}
			m.TotalDisk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalDisk |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartupTime", wireType)
			}
			m.StartupTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartupTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContactUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContactUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheAnnounceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheAnnounceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheAnnounceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheFetchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheFetchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheFetchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheDescription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheDescription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheDescription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeMemory", wireType)
			}
			m.FreeMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeMemory |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMemory", wireType)
			}
			m.TotalMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalMemory |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeDisk", wireType)
			}
			m.FreeDisk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeDisk |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDisk", wireType)
			}
			m.TotalDisk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalDisk |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartupTime", wireType)
			}
			m.StartupTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartupTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContactUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContactUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheFetchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheFetchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheFetchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCachecash
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCachecash
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caches = append(m.Caches, &CacheDescription{})
			if err := m.Caches[len(m.Caches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCachecash(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCachecash
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCachecash(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCachecash
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCachecash
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCachecash
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthCachecash
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCachecash
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCachecash(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthCachecash
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCachecash = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCachecash   = fmt.Errorf("proto: integer overflow")
)
