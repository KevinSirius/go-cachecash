// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: common.proto

package ccmsg

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Error struct {
	Code                 uint64   `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{0}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(m, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetCode() uint64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type PublicKey struct {
	// TODO: Add an enum for key type.
	PublicKey            []byte   `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PublicKey) Reset()         { *m = PublicKey{} }
func (m *PublicKey) String() string { return proto.CompactTextString(m) }
func (*PublicKey) ProtoMessage()    {}
func (*PublicKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{1}
}
func (m *PublicKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublicKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublicKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublicKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublicKey.Merge(m, src)
}
func (m *PublicKey) XXX_Size() int {
	return m.Size()
}
func (m *PublicKey) XXX_DiscardUnknown() {
	xxx_messageInfo_PublicKey.DiscardUnknown(m)
}

var xxx_messageInfo_PublicKey proto.InternalMessageInfo

func (m *PublicKey) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

type EscrowInfo struct {
	PublicKey          *PublicKey `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	PublisherPublicKey *PublicKey `protobuf:"bytes,2,opt,name=publisher_public_key,json=publisherPublicKey,proto3" json:"publisher_public_key,omitempty"`
	DrawDelay          uint64     `protobuf:"varint,3,opt,name=draw_delay,json=drawDelay,proto3" json:"draw_delay,omitempty"`
	ExpirationDelay    uint64     `protobuf:"varint,4,opt,name=expiration_delay,json=expirationDelay,proto3" json:"expiration_delay,omitempty"`
	StartBlock         uint64     `protobuf:"varint,5,opt,name=start_block,json=startBlock,proto3" json:"start_block,omitempty"`
	TicketsPerBlock    []*Segment `protobuf:"bytes,6,rep,name=tickets_per_block,json=ticketsPerBlock,proto3" json:"tickets_per_block,omitempty"`
	// If we are using block/transaction-index based IDs, then this field must not be part of what is actually committed
	// to the blockchain.
	// N.B.: Must be of length `common.EscrowIDSize`.
	Id                   []byte   `protobuf:"bytes,7,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EscrowInfo) Reset()         { *m = EscrowInfo{} }
func (m *EscrowInfo) String() string { return proto.CompactTextString(m) }
func (*EscrowInfo) ProtoMessage()    {}
func (*EscrowInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{2}
}
func (m *EscrowInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EscrowInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EscrowInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EscrowInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EscrowInfo.Merge(m, src)
}
func (m *EscrowInfo) XXX_Size() int {
	return m.Size()
}
func (m *EscrowInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_EscrowInfo.DiscardUnknown(m)
}

var xxx_messageInfo_EscrowInfo proto.InternalMessageInfo

func (m *EscrowInfo) GetPublicKey() *PublicKey {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *EscrowInfo) GetPublisherPublicKey() *PublicKey {
	if m != nil {
		return m.PublisherPublicKey
	}
	return nil
}

func (m *EscrowInfo) GetDrawDelay() uint64 {
	if m != nil {
		return m.DrawDelay
	}
	return 0
}

func (m *EscrowInfo) GetExpirationDelay() uint64 {
	if m != nil {
		return m.ExpirationDelay
	}
	return 0
}

func (m *EscrowInfo) GetStartBlock() uint64 {
	if m != nil {
		return m.StartBlock
	}
	return 0
}

func (m *EscrowInfo) GetTicketsPerBlock() []*Segment {
	if m != nil {
		return m.TicketsPerBlock
	}
	return nil
}

func (m *EscrowInfo) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

type Segment struct {
	Length               uint64   `protobuf:"varint,1,opt,name=length,proto3" json:"length,omitempty"`
	Value                uint64   `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Segment) Reset()         { *m = Segment{} }
func (m *Segment) String() string { return proto.CompactTextString(m) }
func (*Segment) ProtoMessage()    {}
func (*Segment) Descriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{3}
}
func (m *Segment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Segment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Segment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Segment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Segment.Merge(m, src)
}
func (m *Segment) XXX_Size() int {
	return m.Size()
}
func (m *Segment) XXX_DiscardUnknown() {
	xxx_messageInfo_Segment.DiscardUnknown(m)
}

var xxx_messageInfo_Segment proto.InternalMessageInfo

func (m *Segment) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *Segment) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type TicketBundle struct {
	Remainder         *TicketBundleRemainder `protobuf:"bytes,1,opt,name=remainder,proto3" json:"remainder,omitempty"`
	TicketRequest     []*TicketRequest       `protobuf:"bytes,5,rep,name=ticket_request,json=ticketRequest,proto3" json:"ticket_request,omitempty"`
	TicketL1          []*TicketL1            `protobuf:"bytes,6,rep,name=ticket_l1,json=ticketL1,proto3" json:"ticket_l1,omitempty"`
	EncryptedTicketL2 []byte                 `protobuf:"bytes,10,opt,name=encrypted_ticket_l2,json=encryptedTicketL2,proto3" json:"encrypted_ticket_l2,omitempty"`
	BatchSig          *BatchSignature        `protobuf:"bytes,8,opt,name=batch_sig,json=batchSig,proto3" json:"batch_sig,omitempty"`
	BundleSignerCert  *Certificate           `protobuf:"bytes,11,opt,name=bundle_signer_cert,json=bundleSignerCert,proto3" json:"bundle_signer_cert,omitempty"`
	// This field contains connection information for the caches mentioned in the ticket requests.
	// (XXX: There's not any particularly great/specific reason why this couldn't be covered by the hash.)
	CacheInfo            []*CacheInfo    `protobuf:"bytes,9,rep,name=cache_info,json=cacheInfo,proto3" json:"cache_info,omitempty"`
	Metadata             *ObjectMetadata `protobuf:"bytes,12,opt,name=metadata,proto3" json:"metadata,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *TicketBundle) Reset()         { *m = TicketBundle{} }
func (m *TicketBundle) String() string { return proto.CompactTextString(m) }
func (*TicketBundle) ProtoMessage()    {}
func (*TicketBundle) Descriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{4}
}
func (m *TicketBundle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TicketBundle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TicketBundle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TicketBundle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TicketBundle.Merge(m, src)
}
func (m *TicketBundle) XXX_Size() int {
	return m.Size()
}
func (m *TicketBundle) XXX_DiscardUnknown() {
	xxx_messageInfo_TicketBundle.DiscardUnknown(m)
}

var xxx_messageInfo_TicketBundle proto.InternalMessageInfo

func (m *TicketBundle) GetRemainder() *TicketBundleRemainder {
	if m != nil {
		return m.Remainder
	}
	return nil
}

func (m *TicketBundle) GetTicketRequest() []*TicketRequest {
	if m != nil {
		return m.TicketRequest
	}
	return nil
}

func (m *TicketBundle) GetTicketL1() []*TicketL1 {
	if m != nil {
		return m.TicketL1
	}
	return nil
}

func (m *TicketBundle) GetEncryptedTicketL2() []byte {
	if m != nil {
		return m.EncryptedTicketL2
	}
	return nil
}

func (m *TicketBundle) GetBatchSig() *BatchSignature {
	if m != nil {
		return m.BatchSig
	}
	return nil
}

func (m *TicketBundle) GetBundleSignerCert() *Certificate {
	if m != nil {
		return m.BundleSignerCert
	}
	return nil
}

func (m *TicketBundle) GetCacheInfo() []*CacheInfo {
	if m != nil {
		return m.CacheInfo
	}
	return nil
}

func (m *TicketBundle) GetMetadata() *ObjectMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// XXX: This needs a better name.
type TicketBundleRemainder struct {
	// XXX: Is having the request-sequence number as part of the input to the keyed PRF important?
	// TODO: Remove this in favor of the field in the ContentResponse envelope.
	RequestSequenceNo    uint64                `protobuf:"varint,2,opt,name=request_sequence_no,json=requestSequenceNo,proto3" json:"request_sequence_no,omitempty"`
	EscrowId             []byte                `protobuf:"bytes,1,opt,name=escrow_id,json=escrowId,proto3" json:"escrow_id,omitempty"`
	ObjectId             []byte                `protobuf:"bytes,3,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
	PuzzleInfo           *ColocationPuzzleInfo `protobuf:"bytes,7,opt,name=puzzle_info,json=puzzleInfo,proto3" json:"puzzle_info,omitempty"`
	ClientPublicKey      *PublicKey            `protobuf:"bytes,8,opt,name=client_public_key,json=clientPublicKey,proto3" json:"client_public_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *TicketBundleRemainder) Reset()         { *m = TicketBundleRemainder{} }
func (m *TicketBundleRemainder) String() string { return proto.CompactTextString(m) }
func (*TicketBundleRemainder) ProtoMessage()    {}
func (*TicketBundleRemainder) Descriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{5}
}
func (m *TicketBundleRemainder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TicketBundleRemainder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TicketBundleRemainder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TicketBundleRemainder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TicketBundleRemainder.Merge(m, src)
}
func (m *TicketBundleRemainder) XXX_Size() int {
	return m.Size()
}
func (m *TicketBundleRemainder) XXX_DiscardUnknown() {
	xxx_messageInfo_TicketBundleRemainder.DiscardUnknown(m)
}

var xxx_messageInfo_TicketBundleRemainder proto.InternalMessageInfo

func (m *TicketBundleRemainder) GetRequestSequenceNo() uint64 {
	if m != nil {
		return m.RequestSequenceNo
	}
	return 0
}

func (m *TicketBundleRemainder) GetEscrowId() []byte {
	if m != nil {
		return m.EscrowId
	}
	return nil
}

func (m *TicketBundleRemainder) GetObjectId() []byte {
	if m != nil {
		return m.ObjectId
	}
	return nil
}

func (m *TicketBundleRemainder) GetPuzzleInfo() *ColocationPuzzleInfo {
	if m != nil {
		return m.PuzzleInfo
	}
	return nil
}

func (m *TicketBundleRemainder) GetClientPublicKey() *PublicKey {
	if m != nil {
		return m.ClientPublicKey
	}
	return nil
}

type CacheInfo struct {
	Addr                 *NetworkAddress `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	Pubkey               *PublicKey      `protobuf:"bytes,2,opt,name=pubkey,proto3" json:"pubkey,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CacheInfo) Reset()         { *m = CacheInfo{} }
func (m *CacheInfo) String() string { return proto.CompactTextString(m) }
func (*CacheInfo) ProtoMessage()    {}
func (*CacheInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{6}
}
func (m *CacheInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CacheInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CacheInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheInfo.Merge(m, src)
}
func (m *CacheInfo) XXX_Size() int {
	return m.Size()
}
func (m *CacheInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CacheInfo proto.InternalMessageInfo

func (m *CacheInfo) GetAddr() *NetworkAddress {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *CacheInfo) GetPubkey() *PublicKey {
	if m != nil {
		return m.Pubkey
	}
	return nil
}

// XXX: Is this a good name if this message includes a port number?
type NetworkAddress struct {
	// XXX: Or, we could represent this as an AF_* constant and a []byte addr.
	Inetaddr             []byte   `protobuf:"bytes,1,opt,name=inetaddr,proto3" json:"inetaddr,omitempty"`
	Inet6Addr            []byte   `protobuf:"bytes,2,opt,name=inet6addr,proto3" json:"inet6addr,omitempty"`
	Port                 uint32   `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkAddress) Reset()         { *m = NetworkAddress{} }
func (m *NetworkAddress) String() string { return proto.CompactTextString(m) }
func (*NetworkAddress) ProtoMessage()    {}
func (*NetworkAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{7}
}
func (m *NetworkAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkAddress.Merge(m, src)
}
func (m *NetworkAddress) XXX_Size() int {
	return m.Size()
}
func (m *NetworkAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkAddress.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkAddress proto.InternalMessageInfo

func (m *NetworkAddress) GetInetaddr() []byte {
	if m != nil {
		return m.Inetaddr
	}
	return nil
}

func (m *NetworkAddress) GetInet6Addr() []byte {
	if m != nil {
		return m.Inet6Addr
	}
	return nil
}

func (m *NetworkAddress) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type ColocationPuzzleInfo struct {
	Goal []byte `protobuf:"bytes,2,opt,name=goal,proto3" json:"goal,omitempty"`
	// THese fields come from the `colocationpuzzle.Parameters` struct.
	Rounds               uint32   `protobuf:"varint,1,opt,name=rounds,proto3" json:"rounds,omitempty"`
	StartOffset          uint64   `protobuf:"varint,3,opt,name=start_offset,json=startOffset,proto3" json:"start_offset,omitempty"`
	StartRange           uint64   `protobuf:"varint,4,opt,name=start_range,json=startRange,proto3" json:"start_range,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ColocationPuzzleInfo) Reset()         { *m = ColocationPuzzleInfo{} }
func (m *ColocationPuzzleInfo) String() string { return proto.CompactTextString(m) }
func (*ColocationPuzzleInfo) ProtoMessage()    {}
func (*ColocationPuzzleInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{8}
}
func (m *ColocationPuzzleInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColocationPuzzleInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColocationPuzzleInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColocationPuzzleInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColocationPuzzleInfo.Merge(m, src)
}
func (m *ColocationPuzzleInfo) XXX_Size() int {
	return m.Size()
}
func (m *ColocationPuzzleInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ColocationPuzzleInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ColocationPuzzleInfo proto.InternalMessageInfo

func (m *ColocationPuzzleInfo) GetGoal() []byte {
	if m != nil {
		return m.Goal
	}
	return nil
}

func (m *ColocationPuzzleInfo) GetRounds() uint32 {
	if m != nil {
		return m.Rounds
	}
	return 0
}

func (m *ColocationPuzzleInfo) GetStartOffset() uint64 {
	if m != nil {
		return m.StartOffset
	}
	return 0
}

func (m *ColocationPuzzleInfo) GetStartRange() uint64 {
	if m != nil {
		return m.StartRange
	}
	return 0
}

type BatchSignature struct {
	PathDirection        []bool     `protobuf:"varint,2,rep,packed,name=path_direction,json=pathDirection,proto3" json:"path_direction,omitempty"`
	PathDigest           [][]byte   `protobuf:"bytes,3,rep,name=path_digest,json=pathDigest,proto3" json:"path_digest,omitempty"`
	RootSignature        []byte     `protobuf:"bytes,4,opt,name=root_signature,json=rootSignature,proto3" json:"root_signature,omitempty"`
	SigningKey           *PublicKey `protobuf:"bytes,5,opt,name=signing_key,json=signingKey,proto3" json:"signing_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *BatchSignature) Reset()         { *m = BatchSignature{} }
func (m *BatchSignature) String() string { return proto.CompactTextString(m) }
func (*BatchSignature) ProtoMessage()    {}
func (*BatchSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{9}
}
func (m *BatchSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSignature.Merge(m, src)
}
func (m *BatchSignature) XXX_Size() int {
	return m.Size()
}
func (m *BatchSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSignature.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSignature proto.InternalMessageInfo

func (m *BatchSignature) GetPathDirection() []bool {
	if m != nil {
		return m.PathDirection
	}
	return nil
}

func (m *BatchSignature) GetPathDigest() [][]byte {
	if m != nil {
		return m.PathDigest
	}
	return nil
}

func (m *BatchSignature) GetRootSignature() []byte {
	if m != nil {
		return m.RootSignature
	}
	return nil
}

func (m *BatchSignature) GetSigningKey() *PublicKey {
	if m != nil {
		return m.SigningKey
	}
	return nil
}

type BlockKey struct {
	// TODO: Add an enum for key type.
	Key                  []byte   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockKey) Reset()         { *m = BlockKey{} }
func (m *BlockKey) String() string { return proto.CompactTextString(m) }
func (*BlockKey) ProtoMessage()    {}
func (*BlockKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{10}
}
func (m *BlockKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockKey.Merge(m, src)
}
func (m *BlockKey) XXX_Size() int {
	return m.Size()
}
func (m *BlockKey) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockKey.DiscardUnknown(m)
}

var xxx_messageInfo_BlockKey proto.InternalMessageInfo

func (m *BlockKey) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

// This is what the client will present to the cache.  It's not individually signed, but it's covered by the batch
// signature.
type TicketRequest struct {
	ChunkIdx             uint64     `protobuf:"varint,2,opt,name=chunk_idx,json=chunkIdx,proto3" json:"chunk_idx,omitempty"`
	InnerKey             *BlockKey  `protobuf:"bytes,3,opt,name=inner_key,json=innerKey,proto3" json:"inner_key,omitempty"`
	ChunkId              []byte     `protobuf:"bytes,5,opt,name=chunk_id,json=chunkId,proto3" json:"chunk_id,omitempty"`
	CachePublicKey       *PublicKey `protobuf:"bytes,4,opt,name=cache_public_key,json=cachePublicKey,proto3" json:"cache_public_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *TicketRequest) Reset()         { *m = TicketRequest{} }
func (m *TicketRequest) String() string { return proto.CompactTextString(m) }
func (*TicketRequest) ProtoMessage()    {}
func (*TicketRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{11}
}
func (m *TicketRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TicketRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TicketRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TicketRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TicketRequest.Merge(m, src)
}
func (m *TicketRequest) XXX_Size() int {
	return m.Size()
}
func (m *TicketRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TicketRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TicketRequest proto.InternalMessageInfo

func (m *TicketRequest) GetChunkIdx() uint64 {
	if m != nil {
		return m.ChunkIdx
	}
	return 0
}

func (m *TicketRequest) GetInnerKey() *BlockKey {
	if m != nil {
		return m.InnerKey
	}
	return nil
}

func (m *TicketRequest) GetChunkId() []byte {
	if m != nil {
		return m.ChunkId
	}
	return nil
}

func (m *TicketRequest) GetCachePublicKey() *PublicKey {
	if m != nil {
		return m.CachePublicKey
	}
	return nil
}

// XXX: I suspect that the ticket number may be the only thing here's that's actually important, since it could be used
// in proofs of double-spending (on the CP's behalf).
type TicketL1 struct {
	// PublicKey escrow_public_key = 1;
	TicketNo uint64 `protobuf:"varint,2,opt,name=ticket_no,json=ticketNo,proto3" json:"ticket_no,omitempty"`
	// XXX: This is *also* duplicated between TicketL1 and TicketRequest.
	CachePublicKey *PublicKey `protobuf:"bytes,3,opt,name=cache_public_key,json=cachePublicKey,proto3" json:"cache_public_key,omitempty"`
	// XXX: This is duplicated between this message and the TicketRequest, which could probably be avoided.  However,
	// the cache does need to be able to work out which block-index the L1 ticket corresponds to so that it can derive
	// the right outer key to give to the client.
	ChunkIdx             uint64   `protobuf:"varint,4,opt,name=chunk_idx,json=chunkIdx,proto3" json:"chunk_idx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TicketL1) Reset()         { *m = TicketL1{} }
func (m *TicketL1) String() string { return proto.CompactTextString(m) }
func (*TicketL1) ProtoMessage()    {}
func (*TicketL1) Descriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{12}
}
func (m *TicketL1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TicketL1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TicketL1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TicketL1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TicketL1.Merge(m, src)
}
func (m *TicketL1) XXX_Size() int {
	return m.Size()
}
func (m *TicketL1) XXX_DiscardUnknown() {
	xxx_messageInfo_TicketL1.DiscardUnknown(m)
}

var xxx_messageInfo_TicketL1 proto.InternalMessageInfo

func (m *TicketL1) GetTicketNo() uint64 {
	if m != nil {
		return m.TicketNo
	}
	return 0
}

func (m *TicketL1) GetCachePublicKey() *PublicKey {
	if m != nil {
		return m.CachePublicKey
	}
	return nil
}

func (m *TicketL1) GetChunkIdx() uint64 {
	if m != nil {
		return m.ChunkIdx
	}
	return 0
}

// By the time the L2 ticket is decrypted by the client, all of the caches must have provided data and outer encryption
// keys to the client; these are the inputs to the colocation puzzle, whose output is used to decrypt the L2 ticket.
type TicketL2 struct {
	// XXX: It seems like it might not be too hard for a cache to guess the plaintext L2 ticket that corresponds to the
	// hash that it knows.  This would be harder if we didn't tell each cache the other caches' public keys *and*
	// included all of those keys in the hashed ticket L2.  However, it still seems as though the group of hashes trying
	// to claim the ticket could find each other when they all show up to try to claim their win.
	Nonce []byte `protobuf:"bytes,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// The inner session keys are here in order to force the client to solve the colocation puzzle (which is required in
	// order to decrypt the L2 ticket).
	InnerSessionKey      []*BlockKey `protobuf:"bytes,3,rep,name=inner_session_key,json=innerSessionKey,proto3" json:"inner_session_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *TicketL2) Reset()         { *m = TicketL2{} }
func (m *TicketL2) String() string { return proto.CompactTextString(m) }
func (*TicketL2) ProtoMessage()    {}
func (*TicketL2) Descriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{13}
}
func (m *TicketL2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TicketL2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TicketL2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TicketL2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TicketL2.Merge(m, src)
}
func (m *TicketL2) XXX_Size() int {
	return m.Size()
}
func (m *TicketL2) XXX_DiscardUnknown() {
	xxx_messageInfo_TicketL2.DiscardUnknown(m)
}

var xxx_messageInfo_TicketL2 proto.InternalMessageInfo

func (m *TicketL2) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *TicketL2) GetInnerSessionKey() []*BlockKey {
	if m != nil {
		return m.InnerSessionKey
	}
	return nil
}

type TicketL2Info struct {
	EncryptedTicketL2    []byte   `protobuf:"bytes,1,opt,name=encrypted_ticket_l2,json=encryptedTicketL2,proto3" json:"encrypted_ticket_l2,omitempty"`
	PuzzleSecret         []byte   `protobuf:"bytes,2,opt,name=puzzle_secret,json=puzzleSecret,proto3" json:"puzzle_secret,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TicketL2Info) Reset()         { *m = TicketL2Info{} }
func (m *TicketL2Info) String() string { return proto.CompactTextString(m) }
func (*TicketL2Info) ProtoMessage()    {}
func (*TicketL2Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{14}
}
func (m *TicketL2Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TicketL2Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TicketL2Info.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TicketL2Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TicketL2Info.Merge(m, src)
}
func (m *TicketL2Info) XXX_Size() int {
	return m.Size()
}
func (m *TicketL2Info) XXX_DiscardUnknown() {
	xxx_messageInfo_TicketL2Info.DiscardUnknown(m)
}

var xxx_messageInfo_TicketL2Info proto.InternalMessageInfo

func (m *TicketL2Info) GetEncryptedTicketL2() []byte {
	if m != nil {
		return m.EncryptedTicketL2
	}
	return nil
}

func (m *TicketL2Info) GetPuzzleSecret() []byte {
	if m != nil {
		return m.PuzzleSecret
	}
	return nil
}

// Signed by escrow key; ensures that the key that produced the batch signature is authorized.
type Certificate struct {
	SubjectPublicKey     *PublicKey `protobuf:"bytes,1,opt,name=subject_public_key,json=subjectPublicKey,proto3" json:"subject_public_key,omitempty"`
	EscrowId             []byte     `protobuf:"bytes,2,opt,name=escrow_id,json=escrowId,proto3" json:"escrow_id,omitempty"`
	Usage                string     `protobuf:"bytes,3,opt,name=usage,proto3" json:"usage,omitempty"`
	Signature            []byte     `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Certificate) Reset()         { *m = Certificate{} }
func (m *Certificate) String() string { return proto.CompactTextString(m) }
func (*Certificate) ProtoMessage()    {}
func (*Certificate) Descriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{15}
}
func (m *Certificate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Certificate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Certificate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Certificate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Certificate.Merge(m, src)
}
func (m *Certificate) XXX_Size() int {
	return m.Size()
}
func (m *Certificate) XXX_DiscardUnknown() {
	xxx_messageInfo_Certificate.DiscardUnknown(m)
}

var xxx_messageInfo_Certificate proto.InternalMessageInfo

func (m *Certificate) GetSubjectPublicKey() *PublicKey {
	if m != nil {
		return m.SubjectPublicKey
	}
	return nil
}

func (m *Certificate) GetEscrowId() []byte {
	if m != nil {
		return m.EscrowId
	}
	return nil
}

func (m *Certificate) GetUsage() string {
	if m != nil {
		return m.Usage
	}
	return ""
}

func (m *Certificate) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// Contains enough data to let a cache recompute/verify the ticket-bundle digest.
type TicketBundleSubdigests struct {
	TicketRequestDigest     [][]byte `protobuf:"bytes,1,rep,name=ticket_request_digest,json=ticketRequestDigest,proto3" json:"ticket_request_digest,omitempty"`
	TicketL1Digest          [][]byte `protobuf:"bytes,2,rep,name=ticket_l1_digest,json=ticketL1Digest,proto3" json:"ticket_l1_digest,omitempty"`
	EncryptedTicketL2Digest []byte   `protobuf:"bytes,3,opt,name=encrypted_ticket_l2_digest,json=encryptedTicketL2Digest,proto3" json:"encrypted_ticket_l2_digest,omitempty"`
	RemainderDigest         []byte   `protobuf:"bytes,4,opt,name=remainder_digest,json=remainderDigest,proto3" json:"remainder_digest,omitempty"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *TicketBundleSubdigests) Reset()         { *m = TicketBundleSubdigests{} }
func (m *TicketBundleSubdigests) String() string { return proto.CompactTextString(m) }
func (*TicketBundleSubdigests) ProtoMessage()    {}
func (*TicketBundleSubdigests) Descriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{16}
}
func (m *TicketBundleSubdigests) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TicketBundleSubdigests) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TicketBundleSubdigests.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TicketBundleSubdigests) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TicketBundleSubdigests.Merge(m, src)
}
func (m *TicketBundleSubdigests) XXX_Size() int {
	return m.Size()
}
func (m *TicketBundleSubdigests) XXX_DiscardUnknown() {
	xxx_messageInfo_TicketBundleSubdigests.DiscardUnknown(m)
}

var xxx_messageInfo_TicketBundleSubdigests proto.InternalMessageInfo

func (m *TicketBundleSubdigests) GetTicketRequestDigest() [][]byte {
	if m != nil {
		return m.TicketRequestDigest
	}
	return nil
}

func (m *TicketBundleSubdigests) GetTicketL1Digest() [][]byte {
	if m != nil {
		return m.TicketL1Digest
	}
	return nil
}

func (m *TicketBundleSubdigests) GetEncryptedTicketL2Digest() []byte {
	if m != nil {
		return m.EncryptedTicketL2Digest
	}
	return nil
}

func (m *TicketBundleSubdigests) GetRemainderDigest() []byte {
	if m != nil {
		return m.RemainderDigest
	}
	return nil
}

// TODO: this struct is also used at the cache, but most of these fields are irrelevant for the cache and only relevant for the publisher
type ObjectMetadata struct {
	ObjectSize uint64 `protobuf:"varint,1,opt,name=object_size,json=objectSize,proto3" json:"object_size,omitempty"`
	ChunkSize  uint64 `protobuf:"varint,2,opt,name=chunk_size,json=chunkSize,proto3" json:"chunk_size,omitempty"`
	// Passed through by publisher from HTTP upstream.
	Etag         []byte `protobuf:"bytes,4,opt,name=etag,proto3" json:"etag,omitempty"`
	LastModified string `protobuf:"bytes,5,opt,name=last_modified,json=lastModified,proto3" json:"last_modified,omitempty"`
	// Decided by publisher based on HTTP headers.
	CacheExpiration       string   `protobuf:"bytes,6,opt,name=cache_expiration,json=cacheExpiration,proto3" json:"cache_expiration,omitempty"`
	MinimumBacklogDepth   uint32   `protobuf:"varint,7,opt,name=minimum_backlog_depth,json=minimumBacklogDepth,proto3" json:"minimum_backlog_depth,omitempty"`
	BundleRequestInterval uint32   `protobuf:"varint,8,opt,name=bundle_request_interval,json=bundleRequestInterval,proto3" json:"bundle_request_interval,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *ObjectMetadata) Reset()         { *m = ObjectMetadata{} }
func (m *ObjectMetadata) String() string { return proto.CompactTextString(m) }
func (*ObjectMetadata) ProtoMessage()    {}
func (*ObjectMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_555bd8c177793206, []int{17}
}
func (m *ObjectMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectMetadata.Merge(m, src)
}
func (m *ObjectMetadata) XXX_Size() int {
	return m.Size()
}
func (m *ObjectMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectMetadata proto.InternalMessageInfo

func (m *ObjectMetadata) GetObjectSize() uint64 {
	if m != nil {
		return m.ObjectSize
	}
	return 0
}

func (m *ObjectMetadata) GetChunkSize() uint64 {
	if m != nil {
		return m.ChunkSize
	}
	return 0
}

func (m *ObjectMetadata) GetEtag() []byte {
	if m != nil {
		return m.Etag
	}
	return nil
}

func (m *ObjectMetadata) GetLastModified() string {
	if m != nil {
		return m.LastModified
	}
	return ""
}

func (m *ObjectMetadata) GetCacheExpiration() string {
	if m != nil {
		return m.CacheExpiration
	}
	return ""
}

func (m *ObjectMetadata) GetMinimumBacklogDepth() uint32 {
	if m != nil {
		return m.MinimumBacklogDepth
	}
	return 0
}

func (m *ObjectMetadata) GetBundleRequestInterval() uint32 {
	if m != nil {
		return m.BundleRequestInterval
	}
	return 0
}

func init() {
	proto.RegisterType((*Error)(nil), "ccmsg.Error")
	proto.RegisterType((*PublicKey)(nil), "ccmsg.PublicKey")
	proto.RegisterType((*EscrowInfo)(nil), "ccmsg.EscrowInfo")
	proto.RegisterType((*Segment)(nil), "ccmsg.Segment")
	proto.RegisterType((*TicketBundle)(nil), "ccmsg.TicketBundle")
	proto.RegisterType((*TicketBundleRemainder)(nil), "ccmsg.TicketBundleRemainder")
	proto.RegisterType((*CacheInfo)(nil), "ccmsg.CacheInfo")
	proto.RegisterType((*NetworkAddress)(nil), "ccmsg.NetworkAddress")
	proto.RegisterType((*ColocationPuzzleInfo)(nil), "ccmsg.ColocationPuzzleInfo")
	proto.RegisterType((*BatchSignature)(nil), "ccmsg.BatchSignature")
	proto.RegisterType((*BlockKey)(nil), "ccmsg.BlockKey")
	proto.RegisterType((*TicketRequest)(nil), "ccmsg.TicketRequest")
	proto.RegisterType((*TicketL1)(nil), "ccmsg.TicketL1")
	proto.RegisterType((*TicketL2)(nil), "ccmsg.TicketL2")
	proto.RegisterType((*TicketL2Info)(nil), "ccmsg.TicketL2Info")
	proto.RegisterType((*Certificate)(nil), "ccmsg.Certificate")
	proto.RegisterType((*TicketBundleSubdigests)(nil), "ccmsg.TicketBundleSubdigests")
	proto.RegisterType((*ObjectMetadata)(nil), "ccmsg.ObjectMetadata")
}

func init() { proto.RegisterFile("common.proto", fileDescriptor_555bd8c177793206) }

var fileDescriptor_555bd8c177793206 = []byte{
	// 1330 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0xcd, 0x6e, 0x1c, 0x45,
	0x10, 0x66, 0xf6, 0xc7, 0xde, 0xad, 0xfd, 0x75, 0xc7, 0x4e, 0x86, 0x24, 0x18, 0x33, 0x08, 0x69,
	0x83, 0xc0, 0x91, 0x17, 0x11, 0xa4, 0x24, 0x42, 0xe0, 0x24, 0x07, 0x8b, 0xfc, 0x69, 0x96, 0x2b,
	0x0c, 0xb3, 0x3d, 0xbd, 0xb3, 0x8d, 0x67, 0xa7, 0x97, 0x9e, 0x9e, 0x24, 0xf6, 0x89, 0x13, 0xcf,
	0xc0, 0x09, 0xf1, 0x0a, 0x70, 0xe2, 0xc6, 0x95, 0x23, 0x4f, 0x80, 0x90, 0x79, 0x0e, 0x24, 0xd4,
	0xd5, 0x3d, 0xb3, 0x3b, 0x89, 0x8d, 0x72, 0x9a, 0xee, 0xaa, 0xaf, 0xaa, 0xab, 0xab, 0xab, 0xbe,
	0x1a, 0xe8, 0x52, 0xb1, 0x58, 0x88, 0x74, 0x7f, 0x29, 0x85, 0x12, 0xa4, 0x49, 0xe9, 0x22, 0x8b,
	0xaf, 0x7e, 0x18, 0x73, 0x35, 0xcf, 0xa7, 0xfb, 0x54, 0x2c, 0x6e, 0xc6, 0x22, 0x16, 0x37, 0x51,
	0x3b, 0xcd, 0x67, 0xb8, 0xc3, 0x0d, 0xae, 0x8c, 0x95, 0xf7, 0x31, 0x34, 0x1f, 0x48, 0x29, 0x24,
	0x21, 0xd0, 0xa0, 0x22, 0x62, 0xae, 0xb3, 0xe7, 0x8c, 0x1a, 0x3e, 0xae, 0x89, 0x0b, 0x9b, 0x0b,
	0x96, 0x65, 0x61, 0xcc, 0xdc, 0xda, 0x9e, 0x33, 0x6a, 0xfb, 0xc5, 0xd6, 0x7b, 0x1f, 0xda, 0x4f,
	0xf3, 0x69, 0xc2, 0xe9, 0x17, 0xec, 0x84, 0xbc, 0x05, 0xb0, 0xc4, 0x4d, 0x70, 0xcc, 0x4e, 0xd0,
	0x41, 0xd7, 0x6f, 0x2f, 0x0b, 0xb5, 0xf7, 0x5b, 0x0d, 0xe0, 0x41, 0x46, 0xa5, 0x78, 0x7e, 0x94,
	0xce, 0x04, 0xb9, 0xf9, 0x0a, 0xba, 0x33, 0x1e, 0xee, 0x63, 0xf0, 0xfb, 0xa5, 0xcf, 0x35, 0x7b,
	0x72, 0x08, 0xdb, 0xb8, 0xc9, 0xe6, 0x4c, 0x06, 0x6b, 0xa6, 0xb5, 0x0b, 0x4c, 0x49, 0x89, 0xae,
	0x84, 0x18, 0xc9, 0xf0, 0x79, 0x10, 0xb1, 0x24, 0x3c, 0x71, 0xeb, 0x78, 0xc7, 0xb6, 0x96, 0xdc,
	0xd7, 0x02, 0x72, 0x03, 0x86, 0xec, 0xc5, 0x92, 0xcb, 0x50, 0x71, 0x91, 0x5a, 0x50, 0x03, 0x41,
	0x83, 0x95, 0xdc, 0x40, 0xdf, 0x86, 0x4e, 0xa6, 0x42, 0xa9, 0x82, 0x69, 0x22, 0xe8, 0xb1, 0xdb,
	0x44, 0x14, 0xa0, 0xe8, 0x50, 0x4b, 0xc8, 0x6d, 0xd8, 0x52, 0x9c, 0x1e, 0x33, 0x95, 0x05, 0x4b,
	0x26, 0x2d, 0x6c, 0x63, 0xaf, 0x3e, 0xea, 0x8c, 0xfb, 0x36, 0xd6, 0x09, 0x8b, 0x17, 0x2c, 0x55,
	0xfe, 0xc0, 0x02, 0x9f, 0x32, 0x69, 0x6c, 0xfb, 0x50, 0xe3, 0x91, 0xbb, 0x89, 0x19, 0xac, 0xf1,
	0xc8, 0xfb, 0x04, 0x36, 0x2d, 0x96, 0x5c, 0x86, 0x8d, 0x84, 0xa5, 0xb1, 0x9a, 0xdb, 0x17, 0xb2,
	0x3b, 0xb2, 0x0d, 0xcd, 0x67, 0x61, 0x92, 0x9b, 0x17, 0x6a, 0xf8, 0x66, 0xe3, 0xfd, 0x5e, 0x87,
	0xee, 0x97, 0xe8, 0xfc, 0x30, 0x4f, 0xa3, 0x84, 0x91, 0xdb, 0xd0, 0x96, 0x6c, 0x11, 0xf2, 0x34,
	0x62, 0xd2, 0x26, 0xfd, 0xba, 0x8d, 0x66, 0x1d, 0xe7, 0x17, 0x18, 0x7f, 0x05, 0x27, 0x77, 0xa0,
	0x6f, 0x02, 0x0d, 0x24, 0xfb, 0x2e, 0x67, 0x99, 0x72, 0x9b, 0x78, 0x9d, 0xed, 0x8a, 0x03, 0xdf,
	0xe8, 0xfc, 0x9e, 0x5a, 0xdf, 0x92, 0x0f, 0xa0, 0x6d, 0x8d, 0x93, 0x03, 0x9b, 0x86, 0x41, 0xc5,
	0xee, 0xe1, 0x81, 0xdf, 0x52, 0x76, 0x45, 0xf6, 0xe1, 0x12, 0x4b, 0xa9, 0x3c, 0x59, 0x2a, 0x16,
	0x05, 0x85, 0xdd, 0xd8, 0x05, 0xcc, 0xc8, 0x56, 0xa9, 0xb2, 0x96, 0x63, 0x32, 0x86, 0xf6, 0x34,
	0x54, 0x74, 0x1e, 0x64, 0x3c, 0x76, 0x5b, 0x78, 0xad, 0x1d, 0xeb, 0xfd, 0x50, 0xcb, 0x27, 0x3c,
	0x4e, 0x43, 0x95, 0x4b, 0xe6, 0xb7, 0xa6, 0x76, 0x4f, 0x3e, 0x03, 0x32, 0xc5, 0xcb, 0x6a, 0xa3,
	0x94, 0xc9, 0x80, 0x32, 0xa9, 0xdc, 0x0e, 0x1a, 0x13, 0x6b, 0x7c, 0x8f, 0x49, 0xc5, 0x67, 0x9c,
	0x86, 0x8a, 0xf9, 0x43, 0x83, 0x9e, 0x20, 0x58, 0x2b, 0x74, 0x09, 0xd3, 0x90, 0xce, 0x59, 0xc0,
	0xd3, 0x99, 0x70, 0xdb, 0x78, 0xa9, 0xa2, 0x0e, 0xef, 0x69, 0x85, 0x2e, 0x74, 0xbf, 0x4d, 0x8b,
	0x25, 0x39, 0x80, 0xd6, 0x82, 0xa9, 0x30, 0x0a, 0x55, 0xe8, 0x76, 0x2b, 0x51, 0x3e, 0x99, 0x7e,
	0xcb, 0xa8, 0x7a, 0x64, 0x95, 0x7e, 0x09, 0xf3, 0xfe, 0x75, 0x60, 0xe7, 0xdc, 0x97, 0xd1, 0x39,
	0xb2, 0xef, 0x10, 0x64, 0xfa, 0x9b, 0x52, 0x16, 0xa4, 0xc2, 0xbe, 0xff, 0x96, 0x55, 0x4d, 0xac,
	0xe6, 0xb1, 0x20, 0xd7, 0xa0, 0xcd, 0xb0, 0xfd, 0x02, 0x1e, 0xd9, 0xee, 0x6c, 0x19, 0xc1, 0x51,
	0xa4, 0x95, 0x02, 0x43, 0xd0, 0xca, 0xba, 0x51, 0x1a, 0xc1, 0x51, 0x44, 0xee, 0x42, 0x67, 0x99,
	0x9f, 0x9e, 0x26, 0xf6, 0xa2, 0x9b, 0x18, 0xf9, 0xb5, 0xe2, 0xa2, 0x22, 0x11, 0x14, 0x1b, 0xe3,
	0x29, 0x62, 0xf0, 0xce, 0xb0, 0x2c, 0xd7, 0xe4, 0x2e, 0x6c, 0xd1, 0x84, 0xb3, 0x54, 0xad, 0x37,
	0x6d, 0xeb, 0x82, 0xa6, 0x1d, 0x18, 0x68, 0x29, 0xf0, 0xbe, 0x81, 0x76, 0x99, 0x4a, 0x72, 0x03,
	0x1a, 0x61, 0x14, 0x15, 0x85, 0x5b, 0xe4, 0xee, 0x31, 0x53, 0xcf, 0x85, 0x3c, 0xfe, 0x3c, 0x8a,
	0x24, 0xcb, 0x32, 0x1f, 0x21, 0x64, 0x04, 0x1b, 0xcb, 0x7c, 0xfa, 0x7f, 0xfc, 0x60, 0xf5, 0xde,
	0xd7, 0xd0, 0xaf, 0x7a, 0x20, 0x57, 0xa1, 0xc5, 0x53, 0xfd, 0x00, 0xf6, 0xa8, 0xae, 0x5f, 0xee,
	0xc9, 0x75, 0x68, 0xeb, 0xf5, 0x2d, 0x54, 0xd6, 0x0c, 0xc7, 0x95, 0x02, 0xcd, 0x9e, 0x4b, 0x21,
	0x15, 0x66, 0xb0, 0xe7, 0xe3, 0xda, 0xfb, 0xc1, 0x81, 0xed, 0xf3, 0x92, 0xa4, 0xc1, 0xb1, 0x08,
	0x13, 0xeb, 0x05, 0xd7, 0xba, 0xbd, 0xa5, 0xc8, 0xd3, 0x28, 0xc3, 0x83, 0x7b, 0xbe, 0xdd, 0x91,
	0x77, 0xa0, 0x6b, 0xe8, 0x46, 0xcc, 0x66, 0x19, 0x53, 0x96, 0xba, 0x0c, 0x05, 0x3d, 0x41, 0xd1,
	0x8a, 0x91, 0x64, 0x98, 0xc6, 0xcc, 0xf2, 0x96, 0x61, 0x24, 0x5f, 0x4b, 0xbc, 0x5f, 0x1d, 0xe8,
	0x57, 0xbb, 0x81, 0xbc, 0x07, 0xfd, 0x65, 0xa8, 0xe6, 0x41, 0xc4, 0x25, 0xa3, 0x3a, 0x3c, 0xb7,
	0xb6, 0x57, 0x1f, 0xb5, 0xfc, 0x9e, 0x96, 0xde, 0x2f, 0x84, 0xda, 0xb5, 0x85, 0xc5, 0xba, 0xed,
	0xeb, 0x7b, 0xf5, 0x51, 0xd7, 0x07, 0x83, 0xd1, 0x12, 0xed, 0x47, 0x0a, 0xa1, 0xb0, 0x93, 0xd0,
	0x33, 0x1e, 0xdf, 0xf5, 0x7b, 0x5a, 0xba, 0x3a, 0xee, 0x00, 0x3a, 0x1a, 0xc1, 0xd3, 0x18, 0x8b,
	0xa0, 0x79, 0xc1, 0xcb, 0x80, 0x05, 0xe9, 0xf7, 0xbf, 0x0e, 0x2d, 0xe4, 0x44, 0xcd, 0xde, 0x43,
	0xa8, 0xaf, 0x26, 0x8b, 0x5e, 0x7a, 0xbf, 0x38, 0xd0, 0xab, 0xd0, 0x8e, 0x2e, 0x64, 0x3a, 0xcf,
	0xd3, 0xe3, 0x80, 0x47, 0x2f, 0x6c, 0x2f, 0xb4, 0x50, 0x70, 0x14, 0xbd, 0xd0, 0x24, 0xc4, 0x53,
	0xdd, 0xea, 0xda, 0x4d, 0x1d, 0x4f, 0x2f, 0x48, 0xa8, 0x38, 0x44, 0x3f, 0x75, 0xca, 0xa4, 0x3e,
	0xee, 0x4d, 0x68, 0x15, 0xae, 0x30, 0xd4, 0xae, 0xbf, 0x69, 0x3d, 0x91, 0xdb, 0x30, 0x34, 0x9d,
	0xbf, 0x56, 0xd2, 0x8d, 0x0b, 0x6e, 0xd3, 0x47, 0xe4, 0xaa, 0xa2, 0xbf, 0x77, 0xa0, 0x55, 0x50,
	0x9e, 0x0e, 0xd7, 0xd2, 0x5b, 0xd9, 0xba, 0x96, 0x05, 0x1f, 0x8b, 0x73, 0x4f, 0xa9, 0xbf, 0xde,
	0x29, 0xd5, 0x3c, 0x34, 0xaa, 0x79, 0xf0, 0xbe, 0x2a, 0x23, 0x18, 0xeb, 0xc1, 0x91, 0x8a, 0x94,
	0x32, 0x5b, 0x86, 0x66, 0x43, 0xee, 0xc0, 0x96, 0xc9, 0x54, 0xc6, 0xb2, 0x4c, 0x0f, 0x43, 0x73,
	0x76, 0xfd, 0xbc, 0x8c, 0x0d, 0x10, 0x39, 0x31, 0x40, 0x7d, 0x43, 0x5a, 0x0c, 0x9d, 0x87, 0x63,
	0x2c, 0xf4, 0x0b, 0xd8, 0xdc, 0xb9, 0x88, 0xcd, 0xdf, 0x85, 0x9e, 0xe5, 0x9b, 0x8c, 0x51, 0xc9,
	0x94, 0x0d, 0xad, 0x6b, 0x84, 0x13, 0x94, 0x79, 0x3f, 0x39, 0xd0, 0x59, 0xa3, 0x67, 0xf2, 0x29,
	0x90, 0x2c, 0x37, 0x14, 0xf6, 0x1a, 0xff, 0x15, 0x43, 0x8b, 0xad, 0x24, 0x6c, 0x45, 0x8f, 0xb5,
	0x97, 0xe8, 0x71, 0x1b, 0x9a, 0x39, 0xfe, 0xff, 0xd4, 0xf1, 0xff, 0xc7, 0x6c, 0x34, 0x17, 0xbc,
	0x5c, 0xf0, 0x2b, 0x81, 0xf7, 0x97, 0x03, 0x97, 0xd7, 0x99, 0x7b, 0x92, 0x4f, 0x4d, 0xff, 0x64,
	0x64, 0x0c, 0x3b, 0xd5, 0x49, 0x5a, 0x74, 0x96, 0x83, 0x9d, 0x75, 0xa9, 0x32, 0x3a, 0x6d, 0x8b,
	0x8d, 0x60, 0x58, 0x0e, 0xd0, 0x02, 0x5e, 0x43, 0x78, 0xbf, 0x18, 0x9b, 0x16, 0x79, 0x07, 0xae,
	0x9e, 0x93, 0xee, 0x55, 0xf3, 0xea, 0x38, 0xaf, 0xbc, 0x92, 0x75, 0x6b, 0x7c, 0x03, 0x86, 0xe5,
	0xc4, 0x2f, 0x4c, 0xcc, 0xd5, 0x06, 0xa5, 0xdc, 0x40, 0xbd, 0x9f, 0x6b, 0xd0, 0xaf, 0xce, 0x2d,
	0x4d, 0x14, 0x76, 0x8c, 0x64, 0xfc, 0xb4, 0xf8, 0x89, 0x04, 0x23, 0x9a, 0xf0, 0x53, 0xa6, 0x7f,
	0xc0, 0x4c, 0x59, 0xa2, 0xde, 0x14, 0xbc, 0x29, 0x54, 0x54, 0x13, 0x68, 0x30, 0x15, 0xc6, 0xf6,
	0x44, 0x5c, 0xeb, 0x6a, 0x48, 0xc2, 0x4c, 0x05, 0x0b, 0x11, 0xf1, 0x19, 0x67, 0xa6, 0x17, 0xdb,
	0x7e, 0x57, 0x0b, 0x1f, 0x59, 0x99, 0x0e, 0xdb, 0xb4, 0xca, 0xea, 0x3f, 0xcd, 0xdd, 0x40, 0xdc,
	0x00, 0xe5, 0x0f, 0x4a, 0xb1, 0x4e, 0xfe, 0x82, 0xa7, 0x7c, 0x91, 0x2f, 0x82, 0x69, 0x48, 0x8f,
	0x13, 0x11, 0x07, 0x11, 0x5b, 0xaa, 0x39, 0xce, 0xb5, 0x9e, 0x7f, 0xc9, 0x2a, 0x0f, 0x8d, 0xee,
	0xbe, 0x56, 0x91, 0x5b, 0x70, 0xc5, 0xfe, 0x2b, 0x14, 0x0f, 0xc6, 0x53, 0xc5, 0xe4, 0xb3, 0x30,
	0xc1, 0x49, 0xd6, 0xf3, 0x77, 0xa6, 0x76, 0x3a, 0xa3, 0xf6, 0xc8, 0x2a, 0x0f, 0x87, 0x7f, 0x9c,
	0xed, 0x3a, 0x7f, 0x9e, 0xed, 0x3a, 0x7f, 0x9f, 0xed, 0x3a, 0x3f, 0xfe, 0xb3, 0xfb, 0xc6, 0x74,
	0x03, 0xff, 0xb7, 0x3f, 0xfa, 0x2f, 0x00, 0x00, 0xff, 0xff, 0xb2, 0x35, 0x00, 0x49, 0xb5, 0x0b,
	0x00, 0x00,
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PublicKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PublicKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.PublicKey)))
		i += copy(dAtA[i:], m.PublicKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EscrowInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EscrowInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PublicKey != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PublicKey.Size()))
		n1, err := m.PublicKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.PublisherPublicKey != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PublisherPublicKey.Size()))
		n2, err := m.PublisherPublicKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.DrawDelay != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.DrawDelay))
	}
	if m.ExpirationDelay != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ExpirationDelay))
	}
	if m.StartBlock != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.StartBlock))
	}
	if len(m.TicketsPerBlock) > 0 {
		for _, msg := range m.TicketsPerBlock {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Segment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Segment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Length != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Length))
	}
	if m.Value != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TicketBundle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketBundle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Remainder != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Remainder.Size()))
		n3, err := m.Remainder.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.TicketRequest) > 0 {
		for _, msg := range m.TicketRequest {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TicketL1) > 0 {
		for _, msg := range m.TicketL1 {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.BatchSig != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.BatchSig.Size()))
		n4, err := m.BatchSig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.CacheInfo) > 0 {
		for _, msg := range m.CacheInfo {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EncryptedTicketL2) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.EncryptedTicketL2)))
		i += copy(dAtA[i:], m.EncryptedTicketL2)
	}
	if m.BundleSignerCert != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.BundleSignerCert.Size()))
		n5, err := m.BundleSignerCert.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Metadata != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Metadata.Size()))
		n6, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TicketBundleRemainder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketBundleRemainder) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EscrowId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.EscrowId)))
		i += copy(dAtA[i:], m.EscrowId)
	}
	if m.RequestSequenceNo != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.RequestSequenceNo))
	}
	if len(m.ObjectId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.ObjectId)))
		i += copy(dAtA[i:], m.ObjectId)
	}
	if m.PuzzleInfo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PuzzleInfo.Size()))
		n7, err := m.PuzzleInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.ClientPublicKey != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ClientPublicKey.Size()))
		n8, err := m.ClientPublicKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CacheInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Addr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Addr.Size()))
		n9, err := m.Addr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Pubkey != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Pubkey.Size()))
		n10, err := m.Pubkey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NetworkAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkAddress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Inetaddr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Inetaddr)))
		i += copy(dAtA[i:], m.Inetaddr)
	}
	if len(m.Inet6Addr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Inet6Addr)))
		i += copy(dAtA[i:], m.Inet6Addr)
	}
	if m.Port != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ColocationPuzzleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColocationPuzzleInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rounds != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Rounds))
	}
	if len(m.Goal) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Goal)))
		i += copy(dAtA[i:], m.Goal)
	}
	if m.StartOffset != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.StartOffset))
	}
	if m.StartRange != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.StartRange))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BatchSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSignature) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PathDirection) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.PathDirection)))
		for _, b := range m.PathDirection {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.PathDigest) > 0 {
		for _, b := range m.PathDigest {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCommon(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.RootSignature) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.RootSignature)))
		i += copy(dAtA[i:], m.RootSignature)
	}
	if m.SigningKey != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SigningKey.Size()))
		n11, err := m.SigningKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TicketRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChunkIdx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ChunkIdx))
	}
	if m.InnerKey != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.InnerKey.Size()))
		n12, err := m.InnerKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.CachePublicKey != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CachePublicKey.Size()))
		n13, err := m.CachePublicKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.ChunkId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.ChunkId)))
		i += copy(dAtA[i:], m.ChunkId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TicketL1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketL1) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TicketNo != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.TicketNo))
	}
	if m.CachePublicKey != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CachePublicKey.Size()))
		n14, err := m.CachePublicKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.ChunkIdx != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ChunkIdx))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TicketL2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketL2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nonce) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Nonce)))
		i += copy(dAtA[i:], m.Nonce)
	}
	if len(m.InnerSessionKey) > 0 {
		for _, msg := range m.InnerSessionKey {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TicketL2Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketL2Info) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EncryptedTicketL2) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.EncryptedTicketL2)))
		i += copy(dAtA[i:], m.EncryptedTicketL2)
	}
	if len(m.PuzzleSecret) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.PuzzleSecret)))
		i += copy(dAtA[i:], m.PuzzleSecret)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Certificate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Certificate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SubjectPublicKey != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SubjectPublicKey.Size()))
		n15, err := m.SubjectPublicKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.EscrowId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.EscrowId)))
		i += copy(dAtA[i:], m.EscrowId)
	}
	if len(m.Usage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Usage)))
		i += copy(dAtA[i:], m.Usage)
	}
	if len(m.Signature) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TicketBundleSubdigests) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketBundleSubdigests) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TicketRequestDigest) > 0 {
		for _, b := range m.TicketRequestDigest {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.TicketL1Digest) > 0 {
		for _, b := range m.TicketL1Digest {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCommon(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.EncryptedTicketL2Digest) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.EncryptedTicketL2Digest)))
		i += copy(dAtA[i:], m.EncryptedTicketL2Digest)
	}
	if len(m.RemainderDigest) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.RemainderDigest)))
		i += copy(dAtA[i:], m.RemainderDigest)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ObjectMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjectSize != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ObjectSize))
	}
	if m.ChunkSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ChunkSize))
	}
	if len(m.Etag) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Etag)))
		i += copy(dAtA[i:], m.Etag)
	}
	if len(m.LastModified) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.LastModified)))
		i += copy(dAtA[i:], m.LastModified)
	}
	if len(m.CacheExpiration) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.CacheExpiration)))
		i += copy(dAtA[i:], m.CacheExpiration)
	}
	if m.MinimumBacklogDepth != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.MinimumBacklogDepth))
	}
	if m.BundleRequestInterval != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.BundleRequestInterval))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintCommon(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovCommon(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PublicKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EscrowInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublicKey != nil {
		l = m.PublicKey.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.PublisherPublicKey != nil {
		l = m.PublisherPublicKey.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.DrawDelay != 0 {
		n += 1 + sovCommon(uint64(m.DrawDelay))
	}
	if m.ExpirationDelay != 0 {
		n += 1 + sovCommon(uint64(m.ExpirationDelay))
	}
	if m.StartBlock != 0 {
		n += 1 + sovCommon(uint64(m.StartBlock))
	}
	if len(m.TicketsPerBlock) > 0 {
		for _, e := range m.TicketsPerBlock {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Segment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Length != 0 {
		n += 1 + sovCommon(uint64(m.Length))
	}
	if m.Value != 0 {
		n += 1 + sovCommon(uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TicketBundle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Remainder != nil {
		l = m.Remainder.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.TicketRequest) > 0 {
		for _, e := range m.TicketRequest {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.TicketL1) > 0 {
		for _, e := range m.TicketL1 {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.BatchSig != nil {
		l = m.BatchSig.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.CacheInfo) > 0 {
		for _, e := range m.CacheInfo {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	l = len(m.EncryptedTicketL2)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.BundleSignerCert != nil {
		l = m.BundleSignerCert.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TicketBundleRemainder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EscrowId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.RequestSequenceNo != 0 {
		n += 1 + sovCommon(uint64(m.RequestSequenceNo))
	}
	l = len(m.ObjectId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.PuzzleInfo != nil {
		l = m.PuzzleInfo.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.ClientPublicKey != nil {
		l = m.ClientPublicKey.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CacheInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Addr != nil {
		l = m.Addr.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Pubkey != nil {
		l = m.Pubkey.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inetaddr)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Inet6Addr)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovCommon(uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColocationPuzzleInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rounds != 0 {
		n += 1 + sovCommon(uint64(m.Rounds))
	}
	l = len(m.Goal)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.StartOffset != 0 {
		n += 1 + sovCommon(uint64(m.StartOffset))
	}
	if m.StartRange != 0 {
		n += 1 + sovCommon(uint64(m.StartRange))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BatchSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PathDirection) > 0 {
		n += 1 + sovCommon(uint64(len(m.PathDirection))) + len(m.PathDirection)*1
	}
	if len(m.PathDigest) > 0 {
		for _, b := range m.PathDigest {
			l = len(b)
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	l = len(m.RootSignature)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.SigningKey != nil {
		l = m.SigningKey.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TicketRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChunkIdx != 0 {
		n += 1 + sovCommon(uint64(m.ChunkIdx))
	}
	if m.InnerKey != nil {
		l = m.InnerKey.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.CachePublicKey != nil {
		l = m.CachePublicKey.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.ChunkId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TicketL1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TicketNo != 0 {
		n += 1 + sovCommon(uint64(m.TicketNo))
	}
	if m.CachePublicKey != nil {
		l = m.CachePublicKey.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.ChunkIdx != 0 {
		n += 1 + sovCommon(uint64(m.ChunkIdx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TicketL2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.InnerSessionKey) > 0 {
		for _, e := range m.InnerSessionKey {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TicketL2Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EncryptedTicketL2)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.PuzzleSecret)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Certificate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubjectPublicKey != nil {
		l = m.SubjectPublicKey.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.EscrowId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Usage)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TicketBundleSubdigests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TicketRequestDigest) > 0 {
		for _, b := range m.TicketRequestDigest {
			l = len(b)
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.TicketL1Digest) > 0 {
		for _, b := range m.TicketL1Digest {
			l = len(b)
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	l = len(m.EncryptedTicketL2Digest)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.RemainderDigest)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectSize != 0 {
		n += 1 + sovCommon(uint64(m.ObjectSize))
	}
	if m.ChunkSize != 0 {
		n += 1 + sovCommon(uint64(m.ChunkSize))
	}
	l = len(m.Etag)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.LastModified)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.CacheExpiration)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.MinimumBacklogDepth != 0 {
		n += 1 + sovCommon(uint64(m.MinimumBacklogDepth))
	}
	if m.BundleRequestInterval != 0 {
		n += 1 + sovCommon(uint64(m.BundleRequestInterval))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCommon(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCommon(x uint64) (n int) {
	return sovCommon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EscrowInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EscrowInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EscrowInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublicKey == nil {
				m.PublicKey = &PublicKey{}
			}
			if err := m.PublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublisherPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublisherPublicKey == nil {
				m.PublisherPublicKey = &PublicKey{}
			}
			if err := m.PublisherPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrawDelay", wireType)
			}
			m.DrawDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DrawDelay |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationDelay", wireType)
			}
			m.ExpirationDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationDelay |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBlock", wireType)
			}
			m.StartBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketsPerBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketsPerBlock = append(m.TicketsPerBlock, &Segment{})
			if err := m.TicketsPerBlock[len(m.TicketsPerBlock)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Segment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Segment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Segment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketBundle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketBundle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketBundle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remainder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Remainder == nil {
				m.Remainder = &TicketBundleRemainder{}
			}
			if err := m.Remainder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketRequest = append(m.TicketRequest, &TicketRequest{})
			if err := m.TicketRequest[len(m.TicketRequest)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketL1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketL1 = append(m.TicketL1, &TicketL1{})
			if err := m.TicketL1[len(m.TicketL1)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchSig == nil {
				m.BatchSig = &BatchSignature{}
			}
			if err := m.BatchSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheInfo = append(m.CacheInfo, &CacheInfo{})
			if err := m.CacheInfo[len(m.CacheInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedTicketL2", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedTicketL2 = append(m.EncryptedTicketL2[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedTicketL2 == nil {
				m.EncryptedTicketL2 = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleSignerCert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BundleSignerCert == nil {
				m.BundleSignerCert = &Certificate{}
			}
			if err := m.BundleSignerCert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &ObjectMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketBundleRemainder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketBundleRemainder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketBundleRemainder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowId = append(m.EscrowId[:0], dAtA[iNdEx:postIndex]...)
			if m.EscrowId == nil {
				m.EscrowId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestSequenceNo", wireType)
			}
			m.RequestSequenceNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestSequenceNo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectId = append(m.ObjectId[:0], dAtA[iNdEx:postIndex]...)
			if m.ObjectId == nil {
				m.ObjectId = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PuzzleInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PuzzleInfo == nil {
				m.PuzzleInfo = &ColocationPuzzleInfo{}
			}
			if err := m.PuzzleInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientPublicKey == nil {
				m.ClientPublicKey = &PublicKey{}
			}
			if err := m.ClientPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Addr == nil {
				m.Addr = &NetworkAddress{}
			}
			if err := m.Addr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pubkey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pubkey == nil {
				m.Pubkey = &PublicKey{}
			}
			if err := m.Pubkey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inetaddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inetaddr = append(m.Inetaddr[:0], dAtA[iNdEx:postIndex]...)
			if m.Inetaddr == nil {
				m.Inetaddr = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inet6Addr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inet6Addr = append(m.Inet6Addr[:0], dAtA[iNdEx:postIndex]...)
			if m.Inet6Addr == nil {
				m.Inet6Addr = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColocationPuzzleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColocationPuzzleInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColocationPuzzleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rounds", wireType)
			}
			m.Rounds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rounds |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Goal = append(m.Goal[:0], dAtA[iNdEx:postIndex]...)
			if m.Goal == nil {
				m.Goal = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartOffset", wireType)
			}
			m.StartOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartOffset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartRange", wireType)
			}
			m.StartRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartRange |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PathDirection = append(m.PathDirection, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCommon
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.PathDirection) == 0 {
					m.PathDirection = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PathDirection = append(m.PathDirection, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PathDirection", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathDigest = append(m.PathDigest, make([]byte, postIndex-iNdEx))
			copy(m.PathDigest[len(m.PathDigest)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootSignature = append(m.RootSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.RootSignature == nil {
				m.RootSignature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SigningKey == nil {
				m.SigningKey = &PublicKey{}
			}
			if err := m.SigningKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkIdx", wireType)
			}
			m.ChunkIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkIdx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InnerKey == nil {
				m.InnerKey = &BlockKey{}
			}
			if err := m.InnerKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachePublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CachePublicKey == nil {
				m.CachePublicKey = &PublicKey{}
			}
			if err := m.CachePublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChunkId = append(m.ChunkId[:0], dAtA[iNdEx:postIndex]...)
			if m.ChunkId == nil {
				m.ChunkId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketL1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketL1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketL1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketNo", wireType)
			}
			m.TicketNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TicketNo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachePublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CachePublicKey == nil {
				m.CachePublicKey = &PublicKey{}
			}
			if err := m.CachePublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkIdx", wireType)
			}
			m.ChunkIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkIdx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketL2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketL2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketL2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = append(m.Nonce[:0], dAtA[iNdEx:postIndex]...)
			if m.Nonce == nil {
				m.Nonce = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerSessionKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InnerSessionKey = append(m.InnerSessionKey, &BlockKey{})
			if err := m.InnerSessionKey[len(m.InnerSessionKey)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketL2Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketL2Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketL2Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedTicketL2", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedTicketL2 = append(m.EncryptedTicketL2[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedTicketL2 == nil {
				m.EncryptedTicketL2 = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PuzzleSecret", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PuzzleSecret = append(m.PuzzleSecret[:0], dAtA[iNdEx:postIndex]...)
			if m.PuzzleSecret == nil {
				m.PuzzleSecret = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Certificate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Certificate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Certificate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubjectPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubjectPublicKey == nil {
				m.SubjectPublicKey = &PublicKey{}
			}
			if err := m.SubjectPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowId = append(m.EscrowId[:0], dAtA[iNdEx:postIndex]...)
			if m.EscrowId == nil {
				m.EscrowId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Usage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketBundleSubdigests) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketBundleSubdigests: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketBundleSubdigests: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketRequestDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketRequestDigest = append(m.TicketRequestDigest, make([]byte, postIndex-iNdEx))
			copy(m.TicketRequestDigest[len(m.TicketRequestDigest)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketL1Digest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketL1Digest = append(m.TicketL1Digest, make([]byte, postIndex-iNdEx))
			copy(m.TicketL1Digest[len(m.TicketL1Digest)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedTicketL2Digest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedTicketL2Digest = append(m.EncryptedTicketL2Digest[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedTicketL2Digest == nil {
				m.EncryptedTicketL2Digest = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainderDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemainderDigest = append(m.RemainderDigest[:0], dAtA[iNdEx:postIndex]...)
			if m.RemainderDigest == nil {
				m.RemainderDigest = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectSize", wireType)
			}
			m.ObjectSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSize", wireType)
			}
			m.ChunkSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etag", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Etag = append(m.Etag[:0], dAtA[iNdEx:postIndex]...)
			if m.Etag == nil {
				m.Etag = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModified", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastModified = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheExpiration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheExpiration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumBacklogDepth", wireType)
			}
			m.MinimumBacklogDepth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumBacklogDepth |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleRequestInterval", wireType)
			}
			m.BundleRequestInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BundleRequestInterval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCommon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCommon
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthCommon
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCommon(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthCommon
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCommon = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCommon   = fmt.Errorf("proto: integer overflow")
)
