// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: client_cache.proto

package ccmsg

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ClientCacheRequest struct {
	SequenceNo      uint64                 `protobuf:"varint,8,opt,name=sequence_no,json=sequenceNo,proto3" json:"sequence_no,omitempty"`
	BundleRemainder *TicketBundleRemainder `protobuf:"bytes,1,opt,name=bundle_remainder,json=bundleRemainder,proto3" json:"bundle_remainder,omitempty"`
	// Types that are valid to be assigned to Ticket:
	//	*ClientCacheRequest_TicketRequest
	//	*ClientCacheRequest_TicketL1
	//	*ClientCacheRequest_TicketL2
	Ticket isClientCacheRequest_Ticket `protobuf_oneof:"ticket"`
	// Together, these fields allow the cache to verify that the request is authorized.
	TicketBundleSubdigests *TicketBundleSubdigests `protobuf:"bytes,2,opt,name=ticket_bundle_subdigests,json=ticketBundleSubdigests,proto3" json:"ticket_bundle_subdigests,omitempty"`
	BundleSig              *BatchSignature         `protobuf:"bytes,3,opt,name=bundle_sig,json=bundleSig,proto3" json:"bundle_sig,omitempty"`
	BundleSignerCert       *Certificate            `protobuf:"bytes,4,opt,name=bundle_signer_cert,json=bundleSignerCert,proto3" json:"bundle_signer_cert,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                `json:"-"`
	XXX_unrecognized       []byte                  `json:"-"`
	XXX_sizecache          int32                   `json:"-"`
}

func (m *ClientCacheRequest) Reset()         { *m = ClientCacheRequest{} }
func (m *ClientCacheRequest) String() string { return proto.CompactTextString(m) }
func (*ClientCacheRequest) ProtoMessage()    {}
func (*ClientCacheRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d558922f34a2f36f, []int{0}
}
func (m *ClientCacheRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientCacheRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientCacheRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientCacheRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientCacheRequest.Merge(m, src)
}
func (m *ClientCacheRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClientCacheRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientCacheRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClientCacheRequest proto.InternalMessageInfo

type isClientCacheRequest_Ticket interface {
	isClientCacheRequest_Ticket()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClientCacheRequest_TicketRequest struct {
	TicketRequest *TicketRequest `protobuf:"bytes,5,opt,name=ticket_request,json=ticketRequest,proto3,oneof"`
}
type ClientCacheRequest_TicketL1 struct {
	TicketL1 *TicketL1 `protobuf:"bytes,6,opt,name=ticket_l1,json=ticketL1,proto3,oneof"`
}
type ClientCacheRequest_TicketL2 struct {
	TicketL2 *TicketL2Info `protobuf:"bytes,7,opt,name=ticket_l2,json=ticketL2,proto3,oneof"`
}

func (*ClientCacheRequest_TicketRequest) isClientCacheRequest_Ticket() {}
func (*ClientCacheRequest_TicketL1) isClientCacheRequest_Ticket()      {}
func (*ClientCacheRequest_TicketL2) isClientCacheRequest_Ticket()      {}

func (m *ClientCacheRequest) GetTicket() isClientCacheRequest_Ticket {
	if m != nil {
		return m.Ticket
	}
	return nil
}

func (m *ClientCacheRequest) GetSequenceNo() uint64 {
	if m != nil {
		return m.SequenceNo
	}
	return 0
}

func (m *ClientCacheRequest) GetBundleRemainder() *TicketBundleRemainder {
	if m != nil {
		return m.BundleRemainder
	}
	return nil
}

func (m *ClientCacheRequest) GetTicketRequest() *TicketRequest {
	if x, ok := m.GetTicket().(*ClientCacheRequest_TicketRequest); ok {
		return x.TicketRequest
	}
	return nil
}

func (m *ClientCacheRequest) GetTicketL1() *TicketL1 {
	if x, ok := m.GetTicket().(*ClientCacheRequest_TicketL1); ok {
		return x.TicketL1
	}
	return nil
}

func (m *ClientCacheRequest) GetTicketL2() *TicketL2Info {
	if x, ok := m.GetTicket().(*ClientCacheRequest_TicketL2); ok {
		return x.TicketL2
	}
	return nil
}

func (m *ClientCacheRequest) GetTicketBundleSubdigests() *TicketBundleSubdigests {
	if m != nil {
		return m.TicketBundleSubdigests
	}
	return nil
}

func (m *ClientCacheRequest) GetBundleSig() *BatchSignature {
	if m != nil {
		return m.BundleSig
	}
	return nil
}

func (m *ClientCacheRequest) GetBundleSignerCert() *Certificate {
	if m != nil {
		return m.BundleSignerCert
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ClientCacheRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ClientCacheRequest_OneofMarshaler, _ClientCacheRequest_OneofUnmarshaler, _ClientCacheRequest_OneofSizer, []interface{}{
		(*ClientCacheRequest_TicketRequest)(nil),
		(*ClientCacheRequest_TicketL1)(nil),
		(*ClientCacheRequest_TicketL2)(nil),
	}
}

func _ClientCacheRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ClientCacheRequest)
	// ticket
	switch x := m.Ticket.(type) {
	case *ClientCacheRequest_TicketRequest:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TicketRequest); err != nil {
			return err
		}
	case *ClientCacheRequest_TicketL1:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TicketL1); err != nil {
			return err
		}
	case *ClientCacheRequest_TicketL2:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TicketL2); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ClientCacheRequest.Ticket has unexpected type %T", x)
	}
	return nil
}

func _ClientCacheRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ClientCacheRequest)
	switch tag {
	case 5: // ticket.ticket_request
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TicketRequest)
		err := b.DecodeMessage(msg)
		m.Ticket = &ClientCacheRequest_TicketRequest{msg}
		return true, err
	case 6: // ticket.ticket_l1
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TicketL1)
		err := b.DecodeMessage(msg)
		m.Ticket = &ClientCacheRequest_TicketL1{msg}
		return true, err
	case 7: // ticket.ticket_l2
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TicketL2Info)
		err := b.DecodeMessage(msg)
		m.Ticket = &ClientCacheRequest_TicketL2{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ClientCacheRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ClientCacheRequest)
	// ticket
	switch x := m.Ticket.(type) {
	case *ClientCacheRequest_TicketRequest:
		s := proto.Size(x.TicketRequest)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientCacheRequest_TicketL1:
		s := proto.Size(x.TicketL1)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientCacheRequest_TicketL2:
		s := proto.Size(x.TicketL2)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// XXX: Remove me!  This is not used over the wire; it's used only in the `cache` package.
type ClientCacheResponse struct {
	// Identifies the request that this message is a response to.
	RequestSequenceNo uint64 `protobuf:"varint,1,opt,name=request_sequence_no,json=requestSequenceNo,proto3" json:"request_sequence_no,omitempty"`
	// Types that are valid to be assigned to Msg:
	//	*ClientCacheResponse_Error
	//	*ClientCacheResponse_DataResponse
	//	*ClientCacheResponse_L1Response
	//	*ClientCacheResponse_L2Response
	Msg                  isClientCacheResponse_Msg `protobuf_oneof:"msg"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *ClientCacheResponse) Reset()         { *m = ClientCacheResponse{} }
func (m *ClientCacheResponse) String() string { return proto.CompactTextString(m) }
func (*ClientCacheResponse) ProtoMessage()    {}
func (*ClientCacheResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d558922f34a2f36f, []int{1}
}
func (m *ClientCacheResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientCacheResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientCacheResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientCacheResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientCacheResponse.Merge(m, src)
}
func (m *ClientCacheResponse) XXX_Size() int {
	return m.Size()
}
func (m *ClientCacheResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientCacheResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClientCacheResponse proto.InternalMessageInfo

type isClientCacheResponse_Msg interface {
	isClientCacheResponse_Msg()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClientCacheResponse_Error struct {
	Error *Error `protobuf:"bytes,2,opt,name=error,proto3,oneof"`
}
type ClientCacheResponse_DataResponse struct {
	DataResponse *ClientCacheResponseData `protobuf:"bytes,3,opt,name=data_response,json=dataResponse,proto3,oneof"`
}
type ClientCacheResponse_L1Response struct {
	L1Response *ClientCacheResponseL1 `protobuf:"bytes,4,opt,name=l1_response,json=l1Response,proto3,oneof"`
}
type ClientCacheResponse_L2Response struct {
	L2Response *ClientCacheResponseL2 `protobuf:"bytes,5,opt,name=l2_response,json=l2Response,proto3,oneof"`
}

func (*ClientCacheResponse_Error) isClientCacheResponse_Msg()        {}
func (*ClientCacheResponse_DataResponse) isClientCacheResponse_Msg() {}
func (*ClientCacheResponse_L1Response) isClientCacheResponse_Msg()   {}
func (*ClientCacheResponse_L2Response) isClientCacheResponse_Msg()   {}

func (m *ClientCacheResponse) GetMsg() isClientCacheResponse_Msg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *ClientCacheResponse) GetRequestSequenceNo() uint64 {
	if m != nil {
		return m.RequestSequenceNo
	}
	return 0
}

func (m *ClientCacheResponse) GetError() *Error {
	if x, ok := m.GetMsg().(*ClientCacheResponse_Error); ok {
		return x.Error
	}
	return nil
}

func (m *ClientCacheResponse) GetDataResponse() *ClientCacheResponseData {
	if x, ok := m.GetMsg().(*ClientCacheResponse_DataResponse); ok {
		return x.DataResponse
	}
	return nil
}

func (m *ClientCacheResponse) GetL1Response() *ClientCacheResponseL1 {
	if x, ok := m.GetMsg().(*ClientCacheResponse_L1Response); ok {
		return x.L1Response
	}
	return nil
}

func (m *ClientCacheResponse) GetL2Response() *ClientCacheResponseL2 {
	if x, ok := m.GetMsg().(*ClientCacheResponse_L2Response); ok {
		return x.L2Response
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ClientCacheResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ClientCacheResponse_OneofMarshaler, _ClientCacheResponse_OneofUnmarshaler, _ClientCacheResponse_OneofSizer, []interface{}{
		(*ClientCacheResponse_Error)(nil),
		(*ClientCacheResponse_DataResponse)(nil),
		(*ClientCacheResponse_L1Response)(nil),
		(*ClientCacheResponse_L2Response)(nil),
	}
}

func _ClientCacheResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ClientCacheResponse)
	// msg
	switch x := m.Msg.(type) {
	case *ClientCacheResponse_Error:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case *ClientCacheResponse_DataResponse:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DataResponse); err != nil {
			return err
		}
	case *ClientCacheResponse_L1Response:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L1Response); err != nil {
			return err
		}
	case *ClientCacheResponse_L2Response:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L2Response); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ClientCacheResponse.Msg has unexpected type %T", x)
	}
	return nil
}

func _ClientCacheResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ClientCacheResponse)
	switch tag {
	case 2: // msg.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Msg = &ClientCacheResponse_Error{msg}
		return true, err
	case 3: // msg.data_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientCacheResponseData)
		err := b.DecodeMessage(msg)
		m.Msg = &ClientCacheResponse_DataResponse{msg}
		return true, err
	case 4: // msg.l1_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientCacheResponseL1)
		err := b.DecodeMessage(msg)
		m.Msg = &ClientCacheResponse_L1Response{msg}
		return true, err
	case 5: // msg.l2_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientCacheResponseL2)
		err := b.DecodeMessage(msg)
		m.Msg = &ClientCacheResponse_L2Response{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ClientCacheResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ClientCacheResponse)
	// msg
	switch x := m.Msg.(type) {
	case *ClientCacheResponse_Error:
		s := proto.Size(x.Error)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientCacheResponse_DataResponse:
		s := proto.Size(x.DataResponse)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientCacheResponse_L1Response:
		s := proto.Size(x.L1Response)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientCacheResponse_L2Response:
		s := proto.Size(x.L2Response)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ClientCacheResponseData struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientCacheResponseData) Reset()         { *m = ClientCacheResponseData{} }
func (m *ClientCacheResponseData) String() string { return proto.CompactTextString(m) }
func (*ClientCacheResponseData) ProtoMessage()    {}
func (*ClientCacheResponseData) Descriptor() ([]byte, []int) {
	return fileDescriptor_d558922f34a2f36f, []int{2}
}
func (m *ClientCacheResponseData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientCacheResponseData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientCacheResponseData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientCacheResponseData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientCacheResponseData.Merge(m, src)
}
func (m *ClientCacheResponseData) XXX_Size() int {
	return m.Size()
}
func (m *ClientCacheResponseData) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientCacheResponseData.DiscardUnknown(m)
}

var xxx_messageInfo_ClientCacheResponseData proto.InternalMessageInfo

func (m *ClientCacheResponseData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type ClientCacheResponseL1 struct {
	// contains the outer key
	OuterKey             *BlockKey `protobuf:"bytes,1,opt,name=outer_key,json=outerKey,proto3" json:"outer_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ClientCacheResponseL1) Reset()         { *m = ClientCacheResponseL1{} }
func (m *ClientCacheResponseL1) String() string { return proto.CompactTextString(m) }
func (*ClientCacheResponseL1) ProtoMessage()    {}
func (*ClientCacheResponseL1) Descriptor() ([]byte, []int) {
	return fileDescriptor_d558922f34a2f36f, []int{3}
}
func (m *ClientCacheResponseL1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientCacheResponseL1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientCacheResponseL1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientCacheResponseL1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientCacheResponseL1.Merge(m, src)
}
func (m *ClientCacheResponseL1) XXX_Size() int {
	return m.Size()
}
func (m *ClientCacheResponseL1) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientCacheResponseL1.DiscardUnknown(m)
}

var xxx_messageInfo_ClientCacheResponseL1 proto.InternalMessageInfo

func (m *ClientCacheResponseL1) GetOuterKey() *BlockKey {
	if m != nil {
		return m.OuterKey
	}
	return nil
}

type ClientCacheResponseL2 struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientCacheResponseL2) Reset()         { *m = ClientCacheResponseL2{} }
func (m *ClientCacheResponseL2) String() string { return proto.CompactTextString(m) }
func (*ClientCacheResponseL2) ProtoMessage()    {}
func (*ClientCacheResponseL2) Descriptor() ([]byte, []int) {
	return fileDescriptor_d558922f34a2f36f, []int{4}
}
func (m *ClientCacheResponseL2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientCacheResponseL2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientCacheResponseL2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientCacheResponseL2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientCacheResponseL2.Merge(m, src)
}
func (m *ClientCacheResponseL2) XXX_Size() int {
	return m.Size()
}
func (m *ClientCacheResponseL2) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientCacheResponseL2.DiscardUnknown(m)
}

var xxx_messageInfo_ClientCacheResponseL2 proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ClientCacheRequest)(nil), "ccmsg.ClientCacheRequest")
	proto.RegisterType((*ClientCacheResponse)(nil), "ccmsg.ClientCacheResponse")
	proto.RegisterType((*ClientCacheResponseData)(nil), "ccmsg.ClientCacheResponseData")
	proto.RegisterType((*ClientCacheResponseL1)(nil), "ccmsg.ClientCacheResponseL1")
	proto.RegisterType((*ClientCacheResponseL2)(nil), "ccmsg.ClientCacheResponseL2")
}

func init() { proto.RegisterFile("client_cache.proto", fileDescriptor_d558922f34a2f36f) }

var fileDescriptor_d558922f34a2f36f = []byte{
	// 599 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x94, 0xd1, 0x6e, 0xd3, 0x3e,
	0x14, 0xc6, 0x93, 0xad, 0xdd, 0xbf, 0x3b, 0xed, 0xfe, 0x2b, 0x1e, 0x63, 0x61, 0x82, 0x32, 0x45,
	0x5c, 0xec, 0x82, 0x75, 0xaa, 0xe1, 0x16, 0x81, 0x5a, 0xaa, 0x15, 0x0d, 0xb8, 0x70, 0x91, 0xb8,
	0x8c, 0x52, 0xf7, 0x2c, 0x8d, 0xda, 0xda, 0xc3, 0x71, 0x24, 0xf6, 0x26, 0xbc, 0x0b, 0x2f, 0xc0,
	0x25, 0x8f, 0x80, 0xc6, 0x2b, 0x70, 0xc9, 0x05, 0xaa, 0xe3, 0xb4, 0x8d, 0x08, 0x9b, 0xc4, 0x9d,
	0x7d, 0xce, 0xf7, 0xfd, 0xfa, 0xd9, 0x3e, 0x29, 0x10, 0x3e, 0x8b, 0x51, 0xe8, 0x80, 0x87, 0x7c,
	0x82, 0xed, 0x4b, 0x25, 0xb5, 0x24, 0x55, 0xce, 0xe7, 0x49, 0x74, 0x78, 0x12, 0xc5, 0x7a, 0x92,
	0x8e, 0xda, 0x5c, 0xce, 0x4f, 0x23, 0x19, 0xc9, 0x53, 0xd3, 0x1d, 0xa5, 0x17, 0x66, 0x67, 0x36,
	0x66, 0x95, 0xb9, 0x0e, 0x1b, 0x5c, 0xce, 0xe7, 0x52, 0x64, 0x3b, 0xff, 0xd7, 0x26, 0x90, 0x9e,
	0x41, 0xf7, 0x16, 0x64, 0x86, 0x1f, 0x53, 0x4c, 0x34, 0x79, 0x04, 0xf5, 0x64, 0xb1, 0x14, 0x1c,
	0x03, 0x21, 0xbd, 0xda, 0x91, 0x7b, 0x5c, 0x61, 0x90, 0x97, 0xde, 0x49, 0x72, 0x06, 0xcd, 0x51,
	0x2a, 0xc6, 0x33, 0x0c, 0x14, 0xce, 0xc3, 0x58, 0x8c, 0x51, 0x79, 0xee, 0x91, 0x7b, 0x5c, 0xa7,
	0x0f, 0xda, 0x26, 0x56, 0xfb, 0x7d, 0xcc, 0xa7, 0xa8, 0xbb, 0x46, 0xc4, 0x72, 0x0d, 0xdb, 0x1d,
	0x15, 0x0b, 0xe4, 0x39, 0xfc, 0xaf, 0x8d, 0x32, 0x50, 0xd9, 0x6f, 0x7b, 0x55, 0x83, 0xb9, 0x5b,
	0xc0, 0xd8, 0x5c, 0x03, 0x87, 0xed, 0xe8, 0xf5, 0x02, 0x69, 0xc3, 0xb6, 0xb5, 0xcf, 0x3a, 0xde,
	0x96, 0x71, 0xee, 0x16, 0x9c, 0x6f, 0x3a, 0x03, 0x87, 0xd5, 0xb4, 0x5d, 0x13, 0xba, 0xd2, 0x53,
	0xef, 0x3f, 0xa3, 0xdf, 0x2b, 0xea, 0xe9, 0x6b, 0x71, 0x21, 0xd7, 0x3c, 0x94, 0x7c, 0x00, 0xcf,
	0x7a, 0xec, 0x91, 0x93, 0x74, 0x34, 0x8e, 0x23, 0x4c, 0x74, 0xe2, 0x6d, 0x18, 0xc4, 0xc3, 0x92,
	0x33, 0x0f, 0x97, 0x22, 0x76, 0x4f, 0x97, 0xd6, 0xc9, 0x33, 0x80, 0x9c, 0x18, 0x47, 0xde, 0xa6,
	0x41, 0xed, 0x5b, 0x54, 0x37, 0xd4, 0x7c, 0x32, 0x8c, 0x23, 0x11, 0xea, 0x54, 0x21, 0xdb, 0xce,
	0x84, 0xc3, 0x38, 0x22, 0x2f, 0x81, 0xac, 0x5c, 0x02, 0x55, 0xc0, 0x51, 0x69, 0xaf, 0x62, 0xdc,
	0xc4, 0xba, 0x7b, 0xa8, 0x74, 0x7c, 0x11, 0xf3, 0x50, 0x23, 0x6b, 0x2e, 0xad, 0x02, 0xd5, 0xa2,
	0xd1, 0xad, 0xc1, 0x56, 0x96, 0xc8, 0xff, 0xb2, 0x01, 0x7b, 0x85, 0xe7, 0x4f, 0x2e, 0xa5, 0x48,
	0x90, 0xb4, 0x61, 0xcf, 0x3e, 0x47, 0xb0, 0x3e, 0x07, 0xae, 0x99, 0x83, 0x3b, 0xb6, 0x35, 0x5c,
	0x8d, 0xc3, 0x63, 0xa8, 0xa2, 0x52, 0x52, 0xd9, 0xfb, 0x68, 0xd8, 0x18, 0xfd, 0x45, 0x6d, 0xe0,
	0xb0, 0xac, 0x49, 0xfa, 0xb0, 0x33, 0x0e, 0x75, 0x18, 0x28, 0xfb, 0x33, 0xf6, 0xc8, 0xad, 0x3c,
	0xf4, 0x9f, 0x41, 0x5e, 0x85, 0x3a, 0x1c, 0x38, 0xac, 0xb1, 0xb0, 0x2d, 0xc3, 0xbd, 0x80, 0xfa,
	0xac, 0xb3, 0x82, 0x54, 0x0a, 0x63, 0x57, 0x02, 0x31, 0x23, 0x00, 0xb3, 0x4e, 0x01, 0x40, 0x57,
	0x80, 0xea, 0xad, 0x00, 0x6a, 0x00, 0x34, 0xdf, 0x77, 0xab, 0xb0, 0x39, 0x4f, 0x22, 0xff, 0x04,
	0x0e, 0xfe, 0x92, 0x99, 0x10, 0xa8, 0x2c, 0x32, 0x9b, 0x1b, 0x6b, 0x30, 0xb3, 0xf6, 0xfb, 0xb0,
	0x5f, 0x9a, 0x8e, 0x3c, 0x81, 0x6d, 0x99, 0x6a, 0x54, 0xc1, 0x14, 0xaf, 0xec, 0x57, 0x94, 0x0f,
	0x71, 0x77, 0x26, 0xf9, 0xf4, 0x1c, 0xaf, 0x58, 0xcd, 0x28, 0xce, 0xf1, 0xca, 0x3f, 0x28, 0xc7,
	0x50, 0xfa, 0xd3, 0x85, 0xfa, 0x5a, 0x87, 0x9c, 0x41, 0xed, 0x0c, 0x75, 0x6f, 0x92, 0x8a, 0x29,
	0xb9, 0x5f, 0x76, 0x3a, 0xf3, 0x8a, 0x87, 0xb7, 0x5c, 0xbf, 0xef, 0x90, 0xb7, 0xd0, 0xec, 0x7f,
	0xe2, 0x93, 0x50, 0x44, 0x98, 0x7f, 0x54, 0x37, 0x01, 0x6f, 0x7c, 0x8a, 0x52, 0x1c, 0xfd, 0x57,
	0x1c, 0xf5, 0x9d, 0x6e, 0xf3, 0xeb, 0x75, 0xcb, 0xfd, 0x76, 0xdd, 0x72, 0xbf, 0x5f, 0xb7, 0xdc,
	0xcf, 0x3f, 0x5a, 0xce, 0x68, 0xcb, 0xfc, 0xb7, 0x3d, 0xfd, 0x1d, 0x00, 0x00, 0xff, 0xff, 0xa1,
	0x6e, 0x8e, 0xd1, 0x35, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ClientCacheClient is the client API for ClientCache service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ClientCacheClient interface {
	GetChunk(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseData, error)
	ExchangeTicketL1(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseL1, error)
	ExchangeTicketL2(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseL2, error)
}

type clientCacheClient struct {
	cc *grpc.ClientConn
}

func NewClientCacheClient(cc *grpc.ClientConn) ClientCacheClient {
	return &clientCacheClient{cc}
}

func (c *clientCacheClient) GetChunk(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseData, error) {
	out := new(ClientCacheResponseData)
	err := c.cc.Invoke(ctx, "/ccmsg.ClientCache/GetChunk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientCacheClient) ExchangeTicketL1(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseL1, error) {
	out := new(ClientCacheResponseL1)
	err := c.cc.Invoke(ctx, "/ccmsg.ClientCache/ExchangeTicketL1", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientCacheClient) ExchangeTicketL2(ctx context.Context, in *ClientCacheRequest, opts ...grpc.CallOption) (*ClientCacheResponseL2, error) {
	out := new(ClientCacheResponseL2)
	err := c.cc.Invoke(ctx, "/ccmsg.ClientCache/ExchangeTicketL2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClientCacheServer is the server API for ClientCache service.
type ClientCacheServer interface {
	GetChunk(context.Context, *ClientCacheRequest) (*ClientCacheResponseData, error)
	ExchangeTicketL1(context.Context, *ClientCacheRequest) (*ClientCacheResponseL1, error)
	ExchangeTicketL2(context.Context, *ClientCacheRequest) (*ClientCacheResponseL2, error)
}

func RegisterClientCacheServer(s *grpc.Server, srv ClientCacheServer) {
	s.RegisterService(&_ClientCache_serviceDesc, srv)
}

func _ClientCache_GetChunk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientCacheServer).GetChunk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmsg.ClientCache/GetChunk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientCacheServer).GetChunk(ctx, req.(*ClientCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClientCache_ExchangeTicketL1_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientCacheServer).ExchangeTicketL1(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmsg.ClientCache/ExchangeTicketL1",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientCacheServer).ExchangeTicketL1(ctx, req.(*ClientCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClientCache_ExchangeTicketL2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientCacheServer).ExchangeTicketL2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ccmsg.ClientCache/ExchangeTicketL2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientCacheServer).ExchangeTicketL2(ctx, req.(*ClientCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ClientCache_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ccmsg.ClientCache",
	HandlerType: (*ClientCacheServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetChunk",
			Handler:    _ClientCache_GetChunk_Handler,
		},
		{
			MethodName: "ExchangeTicketL1",
			Handler:    _ClientCache_ExchangeTicketL1_Handler,
		},
		{
			MethodName: "ExchangeTicketL2",
			Handler:    _ClientCache_ExchangeTicketL2_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "client_cache.proto",
}

func (m *ClientCacheRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCacheRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BundleRemainder != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintClientCache(dAtA, i, uint64(m.BundleRemainder.Size()))
		n1, err := m.BundleRemainder.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.TicketBundleSubdigests != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintClientCache(dAtA, i, uint64(m.TicketBundleSubdigests.Size()))
		n2, err := m.TicketBundleSubdigests.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.BundleSig != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintClientCache(dAtA, i, uint64(m.BundleSig.Size()))
		n3, err := m.BundleSig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.BundleSignerCert != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintClientCache(dAtA, i, uint64(m.BundleSignerCert.Size()))
		n4, err := m.BundleSignerCert.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Ticket != nil {
		nn5, err := m.Ticket.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	if m.SequenceNo != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintClientCache(dAtA, i, uint64(m.SequenceNo))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClientCacheRequest_TicketRequest) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TicketRequest != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintClientCache(dAtA, i, uint64(m.TicketRequest.Size()))
		n6, err := m.TicketRequest.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *ClientCacheRequest_TicketL1) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TicketL1 != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintClientCache(dAtA, i, uint64(m.TicketL1.Size()))
		n7, err := m.TicketL1.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *ClientCacheRequest_TicketL2) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TicketL2 != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintClientCache(dAtA, i, uint64(m.TicketL2.Size()))
		n8, err := m.TicketL2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *ClientCacheResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCacheResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestSequenceNo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintClientCache(dAtA, i, uint64(m.RequestSequenceNo))
	}
	if m.Msg != nil {
		nn9, err := m.Msg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn9
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClientCacheResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintClientCache(dAtA, i, uint64(m.Error.Size()))
		n10, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *ClientCacheResponse_DataResponse) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DataResponse != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintClientCache(dAtA, i, uint64(m.DataResponse.Size()))
		n11, err := m.DataResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *ClientCacheResponse_L1Response) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.L1Response != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintClientCache(dAtA, i, uint64(m.L1Response.Size()))
		n12, err := m.L1Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *ClientCacheResponse_L2Response) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.L2Response != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintClientCache(dAtA, i, uint64(m.L2Response.Size()))
		n13, err := m.L2Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *ClientCacheResponseData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCacheResponseData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintClientCache(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClientCacheResponseL1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCacheResponseL1) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OuterKey != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintClientCache(dAtA, i, uint64(m.OuterKey.Size()))
		n14, err := m.OuterKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClientCacheResponseL2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCacheResponseL2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintClientCache(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ClientCacheRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BundleRemainder != nil {
		l = m.BundleRemainder.Size()
		n += 1 + l + sovClientCache(uint64(l))
	}
	if m.TicketBundleSubdigests != nil {
		l = m.TicketBundleSubdigests.Size()
		n += 1 + l + sovClientCache(uint64(l))
	}
	if m.BundleSig != nil {
		l = m.BundleSig.Size()
		n += 1 + l + sovClientCache(uint64(l))
	}
	if m.BundleSignerCert != nil {
		l = m.BundleSignerCert.Size()
		n += 1 + l + sovClientCache(uint64(l))
	}
	if m.Ticket != nil {
		n += m.Ticket.Size()
	}
	if m.SequenceNo != 0 {
		n += 1 + sovClientCache(uint64(m.SequenceNo))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientCacheRequest_TicketRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TicketRequest != nil {
		l = m.TicketRequest.Size()
		n += 1 + l + sovClientCache(uint64(l))
	}
	return n
}
func (m *ClientCacheRequest_TicketL1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TicketL1 != nil {
		l = m.TicketL1.Size()
		n += 1 + l + sovClientCache(uint64(l))
	}
	return n
}
func (m *ClientCacheRequest_TicketL2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TicketL2 != nil {
		l = m.TicketL2.Size()
		n += 1 + l + sovClientCache(uint64(l))
	}
	return n
}
func (m *ClientCacheResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestSequenceNo != 0 {
		n += 1 + sovClientCache(uint64(m.RequestSequenceNo))
	}
	if m.Msg != nil {
		n += m.Msg.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientCacheResponse_Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovClientCache(uint64(l))
	}
	return n
}
func (m *ClientCacheResponse_DataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataResponse != nil {
		l = m.DataResponse.Size()
		n += 1 + l + sovClientCache(uint64(l))
	}
	return n
}
func (m *ClientCacheResponse_L1Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.L1Response != nil {
		l = m.L1Response.Size()
		n += 1 + l + sovClientCache(uint64(l))
	}
	return n
}
func (m *ClientCacheResponse_L2Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.L2Response != nil {
		l = m.L2Response.Size()
		n += 1 + l + sovClientCache(uint64(l))
	}
	return n
}
func (m *ClientCacheResponseData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovClientCache(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientCacheResponseL1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OuterKey != nil {
		l = m.OuterKey.Size()
		n += 1 + l + sovClientCache(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientCacheResponseL2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovClientCache(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozClientCache(x uint64) (n int) {
	return sovClientCache(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClientCacheRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientCache
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCacheRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCacheRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleRemainder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientCache
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientCache
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientCache
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BundleRemainder == nil {
				m.BundleRemainder = &TicketBundleRemainder{}
			}
			if err := m.BundleRemainder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketBundleSubdigests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientCache
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientCache
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientCache
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TicketBundleSubdigests == nil {
				m.TicketBundleSubdigests = &TicketBundleSubdigests{}
			}
			if err := m.TicketBundleSubdigests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleSig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientCache
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientCache
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientCache
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BundleSig == nil {
				m.BundleSig = &BatchSignature{}
			}
			if err := m.BundleSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleSignerCert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientCache
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientCache
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientCache
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BundleSignerCert == nil {
				m.BundleSignerCert = &Certificate{}
			}
			if err := m.BundleSignerCert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientCache
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientCache
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientCache
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TicketRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ticket = &ClientCacheRequest_TicketRequest{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketL1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientCache
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientCache
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientCache
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TicketL1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ticket = &ClientCacheRequest_TicketL1{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketL2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientCache
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientCache
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientCache
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TicketL2Info{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ticket = &ClientCacheRequest_TicketL2{v}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNo", wireType)
			}
			m.SequenceNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientCache
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipClientCache(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientCache
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientCache
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientCacheResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientCache
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCacheResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCacheResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestSequenceNo", wireType)
			}
			m.RequestSequenceNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientCache
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestSequenceNo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientCache
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientCache
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientCache
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &ClientCacheResponse_Error{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientCache
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientCache
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientCache
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClientCacheResponseData{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &ClientCacheResponse_DataResponse{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientCache
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientCache
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientCache
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClientCacheResponseL1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &ClientCacheResponse_L1Response{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientCache
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientCache
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientCache
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClientCacheResponseL2{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &ClientCacheResponse_L2Response{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientCache(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientCache
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientCache
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientCacheResponseData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientCache
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCacheResponseData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCacheResponseData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientCache
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClientCache
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthClientCache
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientCache(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientCache
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientCache
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientCacheResponseL1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientCache
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCacheResponseL1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCacheResponseL1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OuterKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientCache
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientCache
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientCache
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OuterKey == nil {
				m.OuterKey = &BlockKey{}
			}
			if err := m.OuterKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientCache(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientCache
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientCache
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientCacheResponseL2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientCache
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCacheResponseL2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCacheResponseL2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipClientCache(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientCache
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientCache
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipClientCache(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowClientCache
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClientCache
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClientCache
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthClientCache
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthClientCache
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowClientCache
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipClientCache(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthClientCache
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthClientCache = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowClientCache   = fmt.Errorf("proto: integer overflow")
)
