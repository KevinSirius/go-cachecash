{{ define "unmarshalType" }}
{{- if .IsNativeType }}
{{- if .IsBytesType -}}
	{{ declare .Item .TypeName "unmarshal" "iL" "uint64" }}
	{{ declare .Item .TypeName "unmarshal" "ni" "int" }}
	iL, ni = binary.Uvarint(data[n:])
	if ni <= 0 {
		return 0, errors.Wrap(ranger.ErrShortRead, "Obtaining length of {{ .QualName }}")
	}
	n += ni
	{{ declare .Item .TypeName "unmarshal" "byt" "[]byte"	}}
	{{- if (and .Require.Length .IsNativeType) }}
	if iL != {{ .Require.Length }} {
		return 0, errors.Wrap(ranger.ErrLengthMismatch, "{{ .QualName }}")
	}
	{{- else if (and .Require.MaxLength .IsNativeType) }}
	if iL > {{ .Require.MaxLength }} {
		{{ if .Item }}
		return 0, errors.Wrapf(ranger.ErrTooMany, "{{ .QualName }} index %d", i)
		{{ else }}
		return 0, errors.Wrap(ranger.ErrTooMany, "{{ .QualName }}")
		{{ end }}
	}
	{{ end }}

	if iL > uint64(len(data[n:])) {
		{{ if .Item }}
		return 0, errors.Wrapf(ranger.ErrShortRead, "{{ .QualName }} index %d", i)
		{{ else }}
		return 0, errors.Wrap(ranger.ErrShortRead, "{{ .QualName }}")
		{{ end }}
	}

	if iL > {{ .MaxByteRange }} {
		return 0, errors.Wrap(ranger.ErrTooMany, "Out of range in {{ .QualName }}")
	}

	byt = make([]byte, iL)
	n += copy(byt, data[n:uint64(n)+iL])
	obj.{{ .FieldName }}{{ if .Item }}[i]{{ end }} = {{ if (eq .ValueType "string") }}string({{ end }}byt{{ if (eq .ValueType "string") }}){{ end }}
{{- else -}}
	{{- if (not .Require.Static) }}
	{{ declare .Item .TypeName "unmarshal" "iL" "uint64" }}
	{{- end }}
	{{ declare .Item .TypeName "unmarshal" "ni" "int" }}

	{{- if .Require.Static }}
	if len(data[n:]) < {{ typeLength .ValueType .FieldName .Require.Static }} {
		return 0, errors.Wrap(ranger.ErrShortRead, "{{ .QualName }}")
	}
	{{- end }}
	{{ unmarshaler .ValueType (printf "obj.%s" .FieldName) .Item .Require.Static }}

	{{- if (and (not .Require.Static) (not (eq .StructureType "array"))) }}
	if iL & {{ truncated .ValueType }} != iL {
		return 0, errors.Wrap(ranger.ErrTooLarge, "{{ .QualName }}")
	}
	{{- end }}
	{{- if (not .Require.Static) }}
	n += ni
	{{- end }}
{{- end -}}
{{- else -}}
{{- if .IsInterface }}
	if len(data[n:]) < {{ typeLength .GetInterface.Input .FieldName true }} {
		return 0, errors.Wrap(ranger.ErrShortRead, "{{ .QualName }} ({{ .ValueType }})")
	}
	var intf {{ .GetInterface.Input }}
	{{ unmarshaler .GetInterface.Input "intf" .Item true }}

	var v {{ .ValueType }}

	switch intf {
	{{ range $foo, $map := .GetInterface.Cases -}}
	{{ range $key, $value := $map -}}
	case {{ $key }}:
		v = {{ printf "&%s{}" $value }}
	{{ end -}}
	{{ end -}}
	default:
		return 0, errors.Wrap(ranger.ErrBadInterface, "{{ .QualName }} ({{ .ValueType }})")
	}

	obj.{{ .FieldName }} = v
	{{ declare .Item .TypeName "unmarshal" "iL" "uint64" }}
	{{ declare .Item .TypeName "unmarshal" "ni" "int" }}
	{{ declare .Item .TypeName "unmarshal" "err" "error" }}
	iL, ni = binary.Uvarint(data[n:])
	if ni <= 0 {
		return 0, errors.Wrap(ranger.ErrShortRead, "Obtaining length of {{ .QualName }}")
	}
	n += ni
	if iL > uint64(len(data[n:])) {
		return 0, errors.Wrap(ranger.ErrShortRead, "{{ .QualName }}")
	}
	if iL > {{ .MaxByteRange }} {
		return 0, errors.Wrap(ranger.ErrTooMany, "Out of range in {{ .QualName }}")
	}
	ni, err = obj.{{ .FieldName }}.UnmarshalFrom(data[n:uint64(n)+iL])
	if err != nil {
		return 0, errors.Wrap(err, "{{ .QualName }} ({{ .ValueType }})")
	}

	n += ni
{{- else if (or .Embedded (eq .StructureType "scalar")) }}
		{{ declare .Item .TypeName "unmarshal" "iL" "uint64" }}
		{{ declare .Item .TypeName "unmarshal" "ni" "int" }}
		{{ declare .Item .TypeName "unmarshal" "err" "error" }}
		iL, ni = binary.Uvarint(data[n:])
		{{- if (and .Require.Length .IsNativeType)}}
		if iL != {{ .Require.Length }} {
			return 0, errors.Wrap(ranger.ErrLengthMismatch, "{{ .QualName }}")
		}
		{{- else if (and .Require.MaxLength .IsNativeType) }}
		if iL > {{ .Require.MaxLength }} {
			return 0, errors.Wrap(ranger.ErrTooMany, "{{ .QualName }}")
		}
		{{ end }}
		n += ni
		if iL > uint64(len(data[n:])) {
			return 0, errors.Wrap(ranger.ErrShortRead, "{{ .QualName }}")
		}
		if iL > {{ .MaxByteRange }} {
			return 0, errors.Wrap(ranger.ErrTooMany, "Out of range in {{ .QualName }}")
		}

		ni, err = obj.{{ .FieldName }}.UnmarshalFrom(data[n:uint64(n)+iL])
		if err != nil {
			return 0, errors.Wrap(err, "Unmarshaling into {{ .QualName }}")
		}

		n += ni
{{- else -}}
		{{ declare .Item .TypeName "unmarshal" "iL" "uint64" }}
		{{ declare .Item .TypeName "unmarshal" "ni" "int" }}
		{{ declare .Item .TypeName "unmarshal" "err" "error" }}
		iL, ni = binary.Uvarint(data[n:])
		if ni <= 0 {
			{{ if .Item }}
			return 0, errors.Wrapf(ranger.ErrShortRead, "Obtaining length of {{ .QualName }} index %d", i)
			{{ else }}
			return 0, errors.Wrap(ranger.ErrShortRead, "Obtaining length of {{ .QualName }}")
			{{ end }}
		}
		{{- if (and .Require.Length .IsNativeType) }}
		if iL != {{ .Require.Length }} {
			{{ if .Item }}
			return 0, errors.Wrapf(ranger.ErrLengthMismatch, "{{ .QualName }} index %d", i)
			{{ else }}
			return 0, errors.Wrap(ranger.ErrLengthMismatch, "{{ .QualName }}")
			{{ end }}
		}
		{{- else if (and .Require.MaxLength .IsNativeType) }}
		if iL > {{ .Require.MaxLength }} {
			{{ if .Item }}
			return 0, errors.Wrapf(ranger.ErrTooMany, "{{ .QualName }} index %d", i)
			{{ else }}
			return 0, errors.Wrap(ranger.ErrTooMany, "{{ .QualName }}")
			{{ end }}
		}
		{{ end }}
		n += ni
		if iL > uint64(len(data[n:])) {
			{{ if .Item }}
			return 0, errors.Wrapf(ranger.ErrShortRead, "{{ .QualName }} index %d", i)
			{{ else }}
			return 0, errors.Wrap(ranger.ErrShortRead, "{{ .QualName }}")
			{{ end }}
		}
		if iL > {{ .MaxByteRange }} {
			return 0, errors.Wrap(ranger.ErrTooMany, "Out of range in {{ .QualName }}")
		}

		ni, err = obj.{{ .FieldName }}{{ if .Item }}[i]{{ end }}.UnmarshalFrom(data[n:uint64(n)+iL])
		if err != nil {
			{{ if .Item }}
			return 0, errors.Wrapf(ranger.ErrShortRead, "Unmarshaling into {{ .QualName }} index %d", i)
			{{ else }}
			return 0, errors.Wrap(ranger.ErrShortRead, "Unmarshaling into {{ .QualName }}")
			{{ end }}
		}
		n += ni
{{- end -}}
{{- end -}}
{{- end }}
{{- define "marshalType" }}
{{- if .IsNativeType }}
{{- if .Require.Static }}
	{{- if .Item }}
	if len(data[n:]) < {{ typeLength .ValueType "item" .Require.Static }} {
		return 0, errors.Wrap(ranger.ErrShortWrite, "{{ .QualName }}")
	}
	{{ marshaler .ValueType "item" .Require.Static }}
	n += {{ typeLength .ValueType "item" .Require.Static }}
	{{- else }}
	if len(data[n:]) < {{ typeLength .ValueType (printf "obj.%s" .FieldName) .Require.Static }} {
		return 0, errors.Wrap(ranger.ErrShortWrite, "{{ .QualName }}")
	}
	{{ marshaler .ValueType (printf "obj.%s" .FieldName) .Require.Static }}
	n += {{ typeLength .ValueType (printf "obj.%s" .FieldName) .Require.Static }}
	{{- end }}
{{- else }}
{{- if .IsBytesType -}}
	if len(data[n:]) < ranger.UvarintSize(uint64(len({{ if .Item }}item{{ else }}obj.{{ .FieldName }}{{ end }}))) + len({{ if .Item }}item{{ else }}obj.{{ .FieldName }}{{ end }}) {
		return 0, errors.Wrap(ranger.ErrShortWrite, "{{ .QualName }}")
	}
	n += binary.PutUvarint(data[n:], uint64(len({{ if .Item }}item{{ else }}obj.{{ .FieldName }}{{ end }})))
{{- end }}
{{- if .Item }}
n += {{ marshaler .ValueType "item" .Require.Static }}
{{- else }}
n += {{ marshaler .ValueType (printf "obj.%s" .FieldName) .Require.Static }}
{{- end }}
{{- end -}}
{{- else -}}
{{- if .IsInterface }}
	{{ declare .Item .TypeName "marshal" "ni" "int" }}
	{{ declare .Item .TypeName "marshal" "err" "error" }}
	{{- if .Item }}
		{{ marshaler .GetInterface.Input "item" true }}
		if len(data[n:]) < {{ typeLength .ValueType "item" .Require.Static }} {
			return 0, errors.Wrap(ranger.ErrShortWrite, "{{ .QualName }}")
		}
		n += {{ typeLength .GetInterface.Input "item" true }}
		ni, err = {{ if .Item }}item{{ else }}obj.{{ .FieldName }}{{ end }}.MarshalTo(data[n:n+{{ if .Item }}item{{ else }}obj.{{ .FieldName }}{{ end }}.Size()])
		if err != nil {
			return 0, errors.Wrap(err, "{{ .QualName }}")
		}
		n += ni
	{{- else }}
	if obj.{{ .FieldName }} != nil {
		{{ marshaler .GetInterface.Input (printf "obj.%s.%s()" .FieldName .GetInterface.Output) true }}
		n += {{ typeLength .GetInterface.Input (printf "obj.%s.%s()" .FieldName .GetInterface.Output) true }}
		if len(data[n:]) < obj.{{ .FieldName }}.Size() {
			return 0, errors.Wrap(ranger.ErrShortWrite, "{{ .QualName }}")
		}
		n += binary.PutUvarint(data[n:], uint64(obj.{{ .FieldName }}.Size()))
		ni, err = {{ if .Item }}item{{ else }}obj.{{ .FieldName }}{{ end }}.MarshalTo(data[n:n+{{ if .Item }}item{{ else }}obj.{{ .FieldName }}{{ end }}.Size()])
		if err != nil {
			return 0, errors.Wrap(err, "{{ .QualName }}")
		}
		n += ni
	} else {
		return 0, errors.Wrap(ranger.ErrShortWrite, "{{ .QualName }} interface is nil, cannot continue")
	}
	{{- end }}
{{- else }}
	{{ declare .Item .TypeName "marshal" "ni" "int" }}
	{{ declare .Item .TypeName "marshal" "err" "error" }}
	if {{ if .Item }}item{{ else }}obj.{{ .FieldName }}{{ end }} != nil {
		if len(data[n:]) < ranger.UvarintSize(uint64({{ if .Item }}item{{ else }}obj.{{ .FieldName }}{{ end }}.Size()))+{{ if .Item }}item{{ else }}obj.{{ .FieldName }}{{ end }}.Size() {
			return 0, errors.Wrap(ranger.ErrShortWrite, "{{ .QualName }}")
		}
		n += binary.PutUvarint(data[n:], uint64({{ if .Item }}item{{ else }}obj.{{ .FieldName }}{{ end }}.Size()))
		ni, err = {{ if .Item }}item{{ else }}obj.{{ .FieldName }}{{ end }}.MarshalTo(data[n:n+{{ if .Item }}item{{ else }}obj.{{ .FieldName }}{{ end }}.Size()])
		if err != nil {
			return 0, errors.Wrap(err, "{{ .QualName }}")
		}
		n += ni
	} else {
		n += ranger.UvarintSize(0)
	}
{{- end -}}
{{- end -}}
{{- end -}}
{{- $outer := . }}
{{- if .Comment }}
// Package {{ .Package }} {{ .Comment }}
{{- end }}
package {{ .Package }}

import (
	"encoding/binary"
	"math"

	"github.com/pkg/errors"
	"github.com/cachecashproject/go-cachecash/ranger"
)

{{ range $typekey, $type := .Types -}}
{{- if $type.Comment }}
// {{ $typekey }} {{ $type.Comment }}
{{- end }}
{{ if not $type.IsInterface }}
type {{ $typekey }} struct {
{{- range $value := $type.Fields -}}{{- with $key := $value.FieldName -}}
	{{- if $value.Comment }}
	// {{ $key }} {{ $value.Comment }}
	{{- end }}
	{{ if $value.Embedded }}*{{ end }}{{ $key }} {{ if (not $value.Embedded) }}{{ if (eq $value.StructureType "array") }}[]{{ end }}{{ end }}{{ if (and (and (not $value.Embedded) (not $value.IsInterface)) (not $value.IsNativeType)) }}*{{ end }}{{ if (not $value.Embedded) }}{{ $value.ValueType }}{{ end }}
{{- end }}
{{- end }}
}

// Marshal returns a byte array containing the marshaled representation of {{ $typekey }}, or nil and an error.
func (obj *{{ $typekey }}) Marshal() ([]byte, error) {
	data := make([]byte, obj.Size())
	n, err := obj.MarshalTo(data)
	if err != nil {
		return nil, errors.Wrap(err, {{ printf "%q" $typekey }})
	}

	if n != len(data) {
		return nil, errors.Wrap(ranger.ErrMarshalLength, {{ printf "%q" $typekey }})
	}

	return data, nil
}

// MarshalTo accepts a byte array with pre-allocated space (see Size()) for {{ $typekey }}.
// It returns how many bytes it wrote to the array, or 0 and an error.
func (obj *{{ $typekey }}) MarshalTo(data []byte) (int, error) {
	var n int

{{ range $value := $type.Fields }}{{ with $key := $value.FieldName }}
{{- if (isMarshalable $value) }}
{{- if (and $value.Require.Length (not (or $value.Embedded (or $value.IsNativeType $value.IsInterface)))) }}
	if len(obj.{{ $key }}) != {{ $value.Require.Length }} {
		return 0, errors.Wrapf(ranger.ErrLengthValidation, "{{ $typekey }}.{{ $key }} - %d/{{ $value.Require.Length }}", len(obj.{{ $key }}))
	}
{{- end }}
{{- if (and $value.Require.MaxLength (not (or $value.Embedded (or $value.IsNativeType $value.IsInterface)))) }}
	if len(obj.{{ $key }}) > {{ $value.Require.MaxLength }} {
		return 0, errors.Wrap(ranger.ErrTooMany, "{{ $typekey }}.{{ $key }}")
	}
{{- end }}
{{ if (eq $value.StructureType "scalar") }}
{{ template "marshalType" $value }}
{{ else }}
	{{- if $value.Match.LengthOfField }}
	if len(obj.{{ $key }}) != len(obj.{{ $value.Match.LengthOfField }}) {
		return 0, errors.Wrap(ranger.ErrLengthMismatch, "{{ $typekey }}: {{ $key }} and {{ $value.Match.LengthOfField }}")
	}
	{{- end }}

	{{- if (and $value.Require.Length (not (or $value.IsNativeType $value.IsInterface))) }}
	if len(obj.{{ $key }}) != {{ $value.Require.Length }} {
		return 0, errors.Wrap(ranger.ErrLengthMismatch, "{{ $typekey }}.{{ $key }}")
	}
	{{- else if (and $value.Require.MaxLength (not (or $value.IsNativeType $value.IsInterface))) }}
	if len(obj.{{ $key }}) > {{ $value.Require.MaxLength }} {
		return 0, errors.Wrap(ranger.ErrTooMany, "{{ $typekey }}.{{ $key }}")
	}
	{{ end }}
	n += binary.PutUvarint(data[n:], uint64(len(obj.{{ $key }})))
	for _, item := range obj.{{ $key }} {
	{{- template "marshalType" (itemValue $value)}}
	}
{{- end }}
{{- end }}
{{- end -}}
{{- end }}
	return n, nil
}

// Size returns the computed size of {{ $typekey }} as would-be marshaled
// without actually marshaling it.
func (obj *{{ $typekey }}) Size() int {
	var n int
{{ range $value := $type.Fields }}{{ with $key := $value.FieldName }}
{{- if (isMarshalable $value) }}
{{- if $value.IsInterface }}
	if obj.{{ $key }} == nil {
		n += ranger.UvarintSize(0)
	} else {
		n += {{ typeLength $value.GetInterface.Input "" true }}
	}
{{- end -}}
{{- if (eq $value.StructureType "scalar") }}
{{ if (not $value.IsNativeType) }}
	if obj.{{ $key }} == nil {
		n += ranger.UvarintSize(0)
	} else {
		n += {{ typeLength $value.ValueType (printf "obj.%s" $key) $value.Require.Static }}
	}
{{ else }}
	n += {{ typeLength $value.ValueType (printf "obj.%s" $key) $value.Require.Static }}
{{ end }}

{{- end -}}
{{- if (eq $value.StructureType "array") }}
	if obj.{{ $key }} == nil {
		n += ranger.UvarintSize(0)
	} else {
		n += ranger.UvarintSize(uint64(len(obj.{{ $key }})))
		for _, item := range obj.{{ $key }} {
			{{- if $value.IsNativeType }}
			n += {{ typeLength $value.ValueType "item" $value.Require.Static }}
			{{- else }}
			n += ranger.UvarintSize(uint64(item.Size()))
			n += item.Size()
			{{- end }}
		}
	}
{{- end -}}
{{- end -}}
{{- end -}}
{{- end }}
	return n
}

// Unmarshal accepts {{ $typekey }}'s binary representation and transforms the
// {{ $typekey }} used as the object. It returns any error.
func (obj *{{ $typekey }}) Unmarshal(data []byte) error {
	_, err := obj.UnmarshalFrom(data)
	return err
}

// UnmarshalFrom is very similar to Unmarshal, but also returns the count of data it read.
func (obj *{{ $typekey }}) UnmarshalFrom(data []byte) (int, error) {
{{- if (eq (len $type.Fields) 0) }}
	return 0, nil
{{ else -}}
	if len(data) == 0 {
		return 0, errors.Wrap(ranger.ErrShortRead, "{{ $typekey }}")
	}
	var n int
{{ range $value := $type.Fields }}{{ with $key := $value.FieldName }}
{{- if (isMarshalable $value) }}
{{ if (eq $value.StructureType "scalar") }}
{{ if $value.Embedded -}}
	{{ declare false $value.TypeName "unmarshal" "iL" "uint64" }}
	{{ declare false $value.TypeName "unmarshal" "ni" "int" }}
	{{ declare false $value.TypeName "unmarshal" "err" "error" }}
	iL, ni = binary.Uvarint(data[n:])
	if ni <= 0 {
		return 0, errors.Wrap(ranger.ErrShortRead, "Obtaining length of {{ $value.QualName }}")
	}
	n += ni

	if iL > uint64(len(data[n:])) {
		return 0, errors.Wrap(ranger.ErrShortRead, "{{ $typekey }}.{{ $key }}")
	}

	obj.{{ $key }} = &{{ $value.ValueType }}{}

	ni, err = obj.{{ $key }}.UnmarshalFrom(data[n:uint64(n)+iL])
	if err != nil {
		return 0, errors.Wrap(err, "{{ $typekey }}.{{ $key }}")
	}
	n += ni
	if iL != uint64(obj.{{ $key }}.Size()) {
		return 0, errors.Wrap(ranger.ErrUnmarshalLength, "{{ $typekey }}.{{ $key }}")
	}
{{- else -}}
	{{- if (and $value.Require.MaxLength (or (and (not $value.Embedded) (and (not $value.IsInterface) (not $value.IsNativeType))) $value.IsBytesType))}}
	if len(obj.{{ $key }}) > {{ $value.Require.MaxLength }} {
		return 0, errors.Wrap(ranger.ErrTooMany, "{{ $typekey }}.{{ $key }}")
	}
	{{- end }}
	{{ template "unmarshalType" $value }}
{{ end }}
{{ end }}
{{- if (eq $value.StructureType "array") }}
	{{ declare false $value.TypeName "unmarshal" "iLen" "uint64" }}
	{{ declare false $value.TypeName "unmarshal" "ni" "int" }}
	iLen, ni = binary.Uvarint(data[n:])
	if ni <= 0 {
		return 0, errors.Wrap(ranger.ErrShortRead, "Obtaining length of {{ $typekey }}.{{ $key }}")
	}
	n += ni

	{{- if $value.Require.Length }}
	if iLen != {{ $value.Require.Length }} {
		return 0, errors.Wrap(ranger.ErrLengthMismatch, "{{ $typekey }}.{{ $key }}")
	}
	{{- else if $value.Require.MaxLength }}
	if iLen > {{ $value.Require.MaxLength }} {
		return 0, errors.Wrap(ranger.ErrTooMany, "{{ $typekey }}.{{ $key }}")
	}
	{{ end }}

	obj.{{ $key }} = make([]{{ if (not $value.IsNativeType) }}*{{ end }}{{ $value.ValueType }}, iLen)
	for i := uint64(0); i < iLen; i++ {
		{{- if (not $value.IsNativeType) }}
		obj.{{ $key }}[i] = &{{ $value.ValueType }}{}
		{{- else if (eq $value.ValueType "[]byte") }}
		obj.{{ $key }}[i] = []byte{}
		{{- end }}
		{{ template "unmarshalType" (itemValue $value) -}}
	}
{{- end }}
{{- if (and $value.Require.Length (or (and (not $value.Embedded) (and (not $value.IsInterface) (not $value.IsNativeType))) $value.IsBytesType))}}
	if len(obj.{{ $key }}) != {{ $value.Require.Length }} {
		return 0, errors.Wrapf(ranger.ErrLengthValidation, "{{ $typekey }}.{{ $key }} - %d/{{ $value.Require.Length }}", len(obj.{{ $key }}))
	}
{{- end -}}
{{- end }}
{{- end }}
{{- end }}
{{ range $value := $type.Fields }}{{ with $key := $value.FieldName }}
{{ if (and (eq $value.StructureType "array") $value.Match.LengthOfField) }}
	if len(obj.{{ $key }}) != len(obj.{{ $value.Match.LengthOfField }}) {
		return 0, errors.Wrap(ranger.ErrLengthMismatch, "{{ $typekey }}: {{ $key }} and {{ $value.Match.LengthOfField }}")
	}
{{- end }}
{{- end -}}
{{- end -}}

	if len(data[n:]) != 0 {
		return 0, errors.Wrap(ranger.ErrUnmarshalLength, "{{ $typekey }}")
	}
	return n, nil
{{ end }}
}

{{ end }}{{end}}
